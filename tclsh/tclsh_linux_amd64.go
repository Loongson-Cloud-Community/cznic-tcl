// Code generated by 'ccgo -o /home/jnml/src/modernc.org/tcl/tclsh/tclsh_linux_amd64.go -ccgo-long-double-is-double -ccgo-verify-structs tclAppInit.c -lmodernc.org/tcl/lib -DBUILD_tcl -I. -I/home/jnml/src/modernc.org/tcl/testdata/tcl8.6.10/unix -I/home/jnml/src/modernc.org/tcl/testdata/tcl8.6.10/generic -I/home/jnml/src/modernc.org/tcl/testdata/tcl8.6.10/libtommath -DPACKAGE_NAME="tcl" -DPACKAGE_TARNAME="tcl" -DPACKAGE_VERSION="8.6" -DPACKAGE_STRING="tcl 8.6" -DPACKAGE_BUGREPORT="" -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_SYS_PARAM_H=1 -DTCL_CFGVAL_ENCODING="iso8859-1" -DHAVE_ZLIB=1 -DMODULE_SCOPE=extern __attribute__((__visibility__("hidden"))) -DHAVE_HIDDEN=1 -DHAVE_CAST_TO_UNION=1 -DTCL_SHLIB_EXT="" -DTCL_MEM_DEBUG=1 -DTCL_TOMMATH=1 -DMP_PREC=4 -D_LARGEFILE64_SOURCE=1 -DTCL_WIDE_INT_IS_LONG=1 -DHAVE_GETCWD=1 -DHAVE_MKSTEMP=1 -DHAVE_OPENDIR=1 -DHAVE_STRTOL=1 -DHAVE_WAITPID=1 -DHAVE_GETNAMEINFO=1 -DHAVE_GETADDRINFO=1 -DHAVE_FREEADDRINFO=1 -DHAVE_GAI_STRERROR=1 -DHAVE_STRUCT_ADDRINFO=1 -DHAVE_STRUCT_IN6_ADDR=1 -DHAVE_STRUCT_SOCKADDR_IN6=1 -DHAVE_STRUCT_SOCKADDR_STORAGE=1 -DHAVE_TERMIOS_H=1 -DHAVE_SYS_IOCTL_H=1 -DHAVE_SYS_TIME_H=1 -DTIME_WITH_SYS_TIME=1 -DHAVE_GMTIME_R=1 -DHAVE_LOCALTIME_R=1 -DHAVE_MKTIME=1 -DHAVE_TM_GMTOFF=1 -DHAVE_TIMEZONE_VAR=1 -DHAVE_STRUCT_STAT_ST_BLOCKS=1 -DHAVE_STRUCT_STAT_ST_BLKSIZE=1 -DHAVE_BLKCNT_T=1 -DHAVE_INTPTR_T=1 -DHAVE_UINTPTR_T=1 -DNO_UNION_WAIT=1 -DHAVE_SIGNED_CHAR=1 -DHAVE_LANGINFO=1 -DHAVE_MKSTEMPS=1 -DHAVE_FTS=1 -DTCL_UNLOAD_DLLS=1 -DSTATIC_BUILD -DMP_FIXED_CUTOFFS -DMP_NO_STDINT -DCFG_INSTALL_LIBDIR="/usr/local/lib" -DCFG_INSTALL_BINDIR="/usr/local/bin" -DCFG_INSTALL_SCRDIR="/usr/local/lib/tcl8.6" -DCFG_INSTALL_INCDIR="/usr/local/include" -DCFG_INSTALL_DOCDIR="/usr/local/man" -DCFG_RUNTIME_LIBDIR="/usr/local/lib" -DCFG_RUNTIME_BINDIR="/usr/local/bin" -DCFG_RUNTIME_SCRDIR="/usr/local/lib/tcl8.6" -DCFG_RUNTIME_INCDIR="/usr/local/include" -DCFG_RUNTIME_DOCDIR="/usr/local/man" -DTCL_LIBRARY="/usr/local/lib/tcl8.6" -DTCL_PACKAGE_PATH="/usr/local/lib "', DO NOT EDIT.

package main

import (
	"fmt"
	"math"
	"reflect"
	"unsafe"

	"modernc.org/crt/v3"
	"modernc.org/tcl/lib"
)

var _ = math.Pi
var _ reflect.Kind
var _ unsafe.Pointer

func main() { crt.Start(main1) }

type ptrdiff_t = int64 /* <builtin>:3:26 */

type size_t = uint64 /* <builtin>:9:23 */

type wchar_t = int32 /* <builtin>:15:24 */

// The tag name of this struct is _G_fpos_t to preserve historic
//   C++ mangled names for functions taking fpos_t arguments.
//   That name should not be used in new code.
type _G_fpos_t = struct {
	__pos   int64
	__state struct {
		__count int32
		__value struct{ __wch uint32 }
	}
}

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// The tag name of this struct is _G_fpos64_t to preserve historic
//   C++ mangled names for functions taking fpos_t and/or fpos64_t
//   arguments.  That name should not be used in new code.
type _G_fpos64_t = struct {
	__pos   int64
	__state struct {
		__count int32
		__value struct{ __wch uint32 }
	}
}

type _IO_FILE = struct {
	_flags          int32
	_IO_read_ptr    uintptr
	_IO_read_end    uintptr
	_IO_read_base   uintptr
	_IO_write_base  uintptr
	_IO_write_ptr   uintptr
	_IO_write_end   uintptr
	_IO_buf_base    uintptr
	_IO_buf_end     uintptr
	_IO_save_base   uintptr
	_IO_backup_base uintptr
	_IO_save_end    uintptr
	_markers        uintptr
	_chain          uintptr
	_fileno         int32
	_flags2         int32
	_old_offset     int64
	_cur_column     uint16
	_vtable_offset  int8
	_shortbuf       [1]int8
	_lock           uintptr
	_offset         int64
	_codecvt        uintptr
	_wide_data      uintptr
	_freeres_list   uintptr
	_freeres_buf    uintptr
	__pad5          size_t
	_mode           int32
	_unused2        [20]int8
}

// The opaque type of streams.  This is the definition used elsewhere.
type FILE = _IO_FILE /* FILE.h:7:25 */

// These macros are used by bits/stdio.h and internal headers.

// Many more flag bits are defined internally.

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
//This file is part of GCC.
//
//GCC is free software; you can redistribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation; either version 3, or (at your option)
//any later version.
//
//GCC is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//Under Section 7 of GPL version 3, you are granted additional
//permissions described in the GCC Runtime Library Exception, version
//3.1, as published by the Free Software Foundation.
//
//You should have received a copy of the GNU General Public License and
//a copy of the GCC Runtime Library Exception along with this program;
//see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
//<http://www.gnu.org/licenses/>.

// ISO C Standard:  7.15  Variable arguments  <stdarg.h>

// Define __gnuc_va_list.

// Define the standard macros for the user,
//   if this invocation was from the user program.

// Define va_list, if desired, from __gnuc_va_list.
// We deliberately do not define va_list when called from
//   stdio.h, because ANSI C says that stdio.h is not supposed to define
//   va_list.  stdio.h needs to have access to that data type,
//   but must not use that name.  It should use the name __gnuc_va_list,
//   which is safe because it is reserved for the implementation.

// The macro _VA_LIST_ is the same thing used by this file in Ultrix.
//   But on BSD NET2 we must not test or define or undef it.
//   (Note that the comments in NET 2's ansi.h
//   are incorrect for _VA_LIST_--see stdio.h!)
// The macro _VA_LIST_DEFINED is used in Windows NT 3.5
// The macro _VA_LIST is used in SCO Unix 3.2.
// The macro _VA_LIST_T_H is used in the Bull dpx2
// The macro __va_list__ is used by BeOS.
type va_list = uintptr /* stdarg.h:99:24 */

type off_t = int64   /* stdio.h:63:17 */
type off64_t = int64 /* stdio.h:70:19 */

type ssize_t = int64 /* stdio.h:77:19 */

// The type of the second argument to `fgetpos' and `fsetpos'.
type fpos_t = _G_fpos_t     /* stdio.h:84:18 */
type fpos64_t = _G_fpos64_t /* stdio.h:89:20 */

// If we are compiling with optimizing read this file.  It contains
//   several optimizing inline functions and macros.

//----------------------------------------------------------------------------
// Support for functions with a variable number of arguments.
//
// The following TCL_VARARGS* macros are to support old extensions
// written for older versions of Tcl where the macros permitted
// support for the varargs.h system as well as stdarg.h .
//
// New code should just directly be written to use stdarg.h conventions.

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
//This file is part of GCC.
//
//GCC is free software; you can redistribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation; either version 3, or (at your option)
//any later version.
//
//GCC is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//Under Section 7 of GPL version 3, you are granted additional
//permissions described in the GCC Runtime Library Exception, version
//3.1, as published by the Free Software Foundation.
//
//You should have received a copy of the GNU General Public License and
//a copy of the GCC Runtime Library Exception along with this program;
//see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
//<http://www.gnu.org/licenses/>.

// ISO C Standard:  7.15  Variable arguments  <stdarg.h>

// Allow a part of Tcl's API to be explicitly marked as deprecated.
//
// Used to make TIP 330/336 generate moans even if people use the
// compatibility macros. Change your code, guys! We won't support you forever.

//----------------------------------------------------------------------------
// Macros used to declare a function to be exported by a DLL. Used by Windows,
// maps to no-op declarations on non-Windows systems. The default build on
// windows is for a DLL, which causes the DLLIMPORT and DLLEXPORT macros to be
// nonempty. To build a static library, the macro STATIC_BUILD should be
// defined.
//
// Note: when building static but linking dynamically to MSVCRT we must still
//       correctly decorate the C library imported function.  Use CRTIMPORT
//       for this purpose.  _DLL is defined by the compiler when linking to
//       MSVCRT.

// These macros are used to control whether functions are being declared for
// import or export. If a function is being declared while it is being built
// to be included in a shared library, then it should have the DLLEXPORT
// storage class. If is being declared for use by a module that is going to
// link against the shared library, then it should have the DLLIMPORT storage
// class. If the symbol is beind declared for a static build or for use from a
// stub library, then the storage class should be empty.
//
// The convention is that a macro called BUILD_xxxx, where xxxx is the name of
// a library we are building, is set on the compile line for sources that are
// to be placed in the library. When this macro is set, the storage class will
// be set to DLLEXPORT. At the end of the header file, the storage class will
// be reset to DLLIMPORT.

// The following _ANSI_ARGS_ macro is to support old extensions
// written for older versions of Tcl where it permitted support
// for compilers written in the pre-prototype era of C.
//
// New code should use prototypes.

// Definitions that allow this header file to be used either with or without
// ANSI C features.

// Make sure EXTERN isn't defined elsewhere.

//----------------------------------------------------------------------------
// The following code is copied from winnt.h. If we don't replicate it here,
// then <windows.h> can't be included after tcl.h, since tcl.h also defines
// VOID. This block is skipped under Cygwin and Mingw.

// Macro to use instead of "void" for arguments that must have type "void *"
// in ANSI C; maps them to type "char *" in non-ANSI systems.

// Miscellaneous declarations.

type ClientData = uintptr /* tcl.h:340:15 */

// Darwin specific configure overrides (to support fat compiles, where
// configure runs only once for multiple architectures):

// Define Tcl_WideInt to be a type that is (at least) 64-bits wide, and define
// Tcl_WideUInt to be the unsigned variant of that type (assuming that where
// we have one, we can have the other.)
//
// Also defines the following macros:
// TCL_WIDE_INT_IS_LONG - if wide ints are really longs (i.e. we're on a
//	LP64 system such as modern Solaris or Linux ... not including Win64)
// Tcl_WideAsLong - forgetful converter from wideInt to long.
// Tcl_LongAsWide - sign-extending converter from long to wideInt.
// Tcl_WideAsDouble - converter from wideInt to double.
// Tcl_DoubleAsWide - converter from double to wideInt.
//
// The following invariant should hold for any long value 'longVal':
//	longVal == Tcl_WideAsLong(Tcl_LongAsWide(longVal))
//
// Note on converting between Tcl_WideInt and strings. This implementation (in
// tclObj.c) depends on the function
// sprintf(...,"%" TCL_LL_MODIFIER "d",...).

type Tcl_WideInt = int64   /* tcl.h:415:28 */
type Tcl_WideUInt = uint64 /* tcl.h:416:36 */

//----------------------------------------------------------------------------
// Data structures defined opaquely in this module. The definitions below just
// provide dummy types. A few fields are made visible in Tcl_Interp
// structures, namely those used for returning a string result from commands.
// Direct access to the result field is discouraged in Tcl 8.0. The
// interpreter result is either an object or a string, and the two values are
// kept consistent unless some C code sets interp->result directly.
// Programmers should use either the function Tcl_GetObjResult() or
// Tcl_GetStringResult() to read the interpreter's result. See the SetResult
// man page for details.
//
// Note: any change to the Tcl_Interp definition below must be mirrored in the
// "real" definition in tclInt.h.
//
// Note: Tcl_ObjCmdProc functions do not directly set result and freeProc.
// Instead, they set a Tcl_Obj member in the "real" structure that can be
// accessed with Tcl_GetObjResult() and Tcl_SetObjResult().

type Tcl_Interp1 = struct {
	resultDontUse    uintptr
	freeProcDontUse  uintptr
	errorLineDontUse int32
	_                [4]byte
}

//----------------------------------------------------------------------------
// Data structures defined opaquely in this module. The definitions below just
// provide dummy types. A few fields are made visible in Tcl_Interp
// structures, namely those used for returning a string result from commands.
// Direct access to the result field is discouraged in Tcl 8.0. The
// interpreter result is either an object or a string, and the two values are
// kept consistent unless some C code sets interp->result directly.
// Programmers should use either the function Tcl_GetObjResult() or
// Tcl_GetStringResult() to read the interpreter's result. See the SetResult
// man page for details.
//
// Note: any change to the Tcl_Interp definition below must be mirrored in the
// "real" definition in tclInt.h.
//
// Note: Tcl_ObjCmdProc functions do not directly set result and freeProc.
// Instead, they set a Tcl_Obj member in the "real" structure that can be
// accessed with Tcl_GetObjResult() and Tcl_SetObjResult().

type Tcl_Interp = Tcl_Interp1 /* tcl.h:525:1 */

type Tcl_AsyncHandler = uintptr       /* tcl.h:527:34 */
type Tcl_Channel = uintptr            /* tcl.h:528:29 */
type Tcl_ChannelTypeVersion = uintptr /* tcl.h:529:40 */
type Tcl_Command = uintptr            /* tcl.h:530:29 */
type Tcl_Condition = uintptr          /* tcl.h:531:31 */
type Tcl_Dict = uintptr               /* tcl.h:532:26 */
type Tcl_EncodingState = uintptr      /* tcl.h:533:35 */
type Tcl_Encoding = uintptr           /* tcl.h:534:30 */
type Tcl_Event1 = struct {
	proc    uintptr
	nextPtr uintptr
}

type Tcl_Event = Tcl_Event1      /* tcl.h:535:26 */
type Tcl_InterpState = uintptr   /* tcl.h:536:33 */
type Tcl_LoadHandle = uintptr    /* tcl.h:537:32 */
type Tcl_Mutex = uintptr         /* tcl.h:538:27 */
type Tcl_Pid = uintptr           /* tcl.h:539:25 */
type Tcl_RegExp = uintptr        /* tcl.h:540:28 */
type Tcl_ThreadDataKey = uintptr /* tcl.h:541:35 */
type Tcl_ThreadId = uintptr      /* tcl.h:542:30 */
type Tcl_TimerToken = uintptr    /* tcl.h:543:32 */
type Tcl_Trace = uintptr         /* tcl.h:544:27 */
type Tcl_Var = uintptr           /* tcl.h:545:25 */
type Tcl_ZlibStream = uintptr    /* tcl.h:546:32 */

// Threading function return types used for abstracting away platform
// differences when writing a Tcl_ThreadCreateProc. See the NewThread function
// in generic/tclThreadTest.c for it's usage.

// Definition of values for default stacksize and the possible flags to be
// given to Tcl_CreateThread.

// Flag values passed to Tcl_StringCaseMatch.

// Flag values passed to Tcl_GetRegExpFromObj.

// Flags values passed to Tcl_RegExpExecObj.

// Structures filled in by Tcl_RegExpInfo. Note that all offset values are
// relative to the start of the match string, not the beginning of the entire
// string.

type Tcl_RegExpIndices1 = struct {
	start int64
	end   int64
}

// Threading function return types used for abstracting away platform
// differences when writing a Tcl_ThreadCreateProc. See the NewThread function
// in generic/tclThreadTest.c for it's usage.

// Definition of values for default stacksize and the possible flags to be
// given to Tcl_CreateThread.

// Flag values passed to Tcl_StringCaseMatch.

// Flag values passed to Tcl_GetRegExpFromObj.

// Flags values passed to Tcl_RegExpExecObj.

// Structures filled in by Tcl_RegExpInfo. Note that all offset values are
// relative to the start of the match string, not the beginning of the entire
// string.

type Tcl_RegExpIndices = Tcl_RegExpIndices1 /* tcl.h:628:3 */

type Tcl_RegExpInfo1 = struct {
	nsubs       int32
	matches     uintptr
	extendStart int64
	reserved    int64
}

type Tcl_RegExpInfo = Tcl_RegExpInfo1 /* tcl.h:637:3 */

// Picky compilers complain if this typdef doesn't appear before the struct's
// reference in tclDecls.h.

type Tcl_Stat_ = uintptr    /* tcl.h:644:21 */
type Tcl_OldStat_ = uintptr /* tcl.h:645:21 */

//----------------------------------------------------------------------------
// When a TCL command returns, the interpreter contains a result from the
// command. Programmers are strongly encouraged to use one of the functions
// Tcl_GetObjResult() or Tcl_GetStringResult() to read the interpreter's
// result. See the SetResult man page for details. Besides this result, the
// command function returns an integer code, which is one of the following:
//
// TCL_OK		Command completed normally; the interpreter's result
//			contains the command's result.
// TCL_ERROR		The command couldn't be completed successfully; the
//			interpreter's result describes what went wrong.
// TCL_RETURN		The command requests that the current function return;
//			the interpreter's result contains the function's
//			return value.
// TCL_BREAK		The command requests that the innermost loop be
//			exited; the interpreter's result is meaningless.
// TCL_CONTINUE		Go on to the next iteration of the current loop; the
//			interpreter's result is meaningless.

//----------------------------------------------------------------------------
// Flags to control what substitutions are performed by Tcl_SubstObj():

// Argument descriptors for math function callbacks in expressions:

type Tcl_ValueType = uint32 /* tcl.h:692:3 */

type Tcl_Value1 = struct {
	__type      Tcl_ValueType
	intValue    int64
	doubleValue float64
	wideValue   Tcl_WideInt
}

type Tcl_Value = Tcl_Value1 /* tcl.h:700:3 */

// Forward declaration of Tcl_Obj to prevent an error when the forward
// reference to Tcl_Obj is encountered in the function types declared below.

type Tcl_Obj1 = struct {
	refCount    int32
	bytes       uintptr
	length      int32
	typePtr     uintptr
	internalRep struct {
		longValue int64
		_         [8]byte
	}
}

//----------------------------------------------------------------------------
// The following structure represents a type of object, which is a particular
// internal representation for an object plus a set of functions that provide
// standard operations on objects of that type.

type Tcl_ObjType1 = struct {
	name             uintptr
	freeIntRepProc   uintptr
	dupIntRepProc    uintptr
	updateStringProc uintptr
	setFromAnyProc   uintptr
}

//----------------------------------------------------------------------------
// The following structure represents a type of object, which is a particular
// internal representation for an object plus a set of functions that provide
// standard operations on objects of that type.

type Tcl_ObjType = Tcl_ObjType1 /* tcl.h:796:3 */

// One of the following structures exists for each object in the Tcl system.
// An object stores a value as either a string, some internal representation,
// or both.

type Tcl_Obj = Tcl_Obj1 /* tcl.h:843:3 */

//----------------------------------------------------------------------------
// The following structure contains the state needed by Tcl_SaveResult. No-one
// outside of Tcl should access any of these fields. This structure is
// typically allocated on the stack.

type Tcl_SavedResult1 = struct {
	result       uintptr
	freeProc     uintptr
	objResultPtr uintptr
	appendResult uintptr
	appendAvl    int32
	appendUsed   int32
	resultSpace  [201]int8
	_            [7]byte
}

//----------------------------------------------------------------------------
// The following structure contains the state needed by Tcl_SaveResult. No-one
// outside of Tcl should access any of these fields. This structure is
// typically allocated on the stack.

type Tcl_SavedResult = Tcl_SavedResult1 /* tcl.h:872:3 */

//----------------------------------------------------------------------------
// The following definitions support Tcl's namespace facility. Note: the first
// five fields must match exactly the fields in a Namespace structure (see
// tclInt.h).

type Tcl_Namespace1 = struct {
	name       uintptr
	fullName   uintptr
	clientData ClientData
	deleteProc uintptr
	parentPtr  uintptr
}

//----------------------------------------------------------------------------
// The following definitions support Tcl's namespace facility. Note: the first
// five fields must match exactly the fields in a Namespace structure (see
// tclInt.h).

type Tcl_Namespace = Tcl_Namespace1 /* tcl.h:897:3 */

//----------------------------------------------------------------------------
// The following structure represents a call frame, or activation record. A
// call frame defines a naming context for a procedure call: its local scope
// (for local variables) and its namespace scope (used for non-local
// variables; often the global :: namespace). A call frame can also define the
// naming context for a namespace eval or namespace inscope command: the
// namespace in which the command's code should execute. The Tcl_CallFrame
// structures exist only while procedures or namespace eval/inscope's are
// being executed, and provide a Tcl call stack.
//
// A call frame is initialized and pushed using Tcl_PushCallFrame and popped
// using Tcl_PopCallFrame. Storage for a Tcl_CallFrame must be provided by the
// Tcl_PushCallFrame caller, and callers typically allocate them on the C call
// stack for efficiency. For this reason, Tcl_CallFrame is defined as a
// structure and not as an opaque token. However, most Tcl_CallFrame fields
// are hidden since applications should not access them directly; others are
// declared as "dummyX".
//
// WARNING!! The structure definition must be kept consistent with the
// CallFrame structure in tclInt.h. If you change one, change the other.

type Tcl_CallFrame1 = struct {
	nsPtr   uintptr
	dummy1  int32
	dummy2  int32
	dummy3  uintptr
	dummy4  uintptr
	dummy5  uintptr
	dummy6  int32
	dummy7  uintptr
	dummy8  uintptr
	dummy9  int32
	dummy10 uintptr
	dummy11 uintptr
	dummy12 uintptr
	dummy13 uintptr
}

//----------------------------------------------------------------------------
// The following structure represents a call frame, or activation record. A
// call frame defines a naming context for a procedure call: its local scope
// (for local variables) and its namespace scope (used for non-local
// variables; often the global :: namespace). A call frame can also define the
// naming context for a namespace eval or namespace inscope command: the
// namespace in which the command's code should execute. The Tcl_CallFrame
// structures exist only while procedures or namespace eval/inscope's are
// being executed, and provide a Tcl call stack.
//
// A call frame is initialized and pushed using Tcl_PushCallFrame and popped
// using Tcl_PopCallFrame. Storage for a Tcl_CallFrame must be provided by the
// Tcl_PushCallFrame caller, and callers typically allocate them on the C call
// stack for efficiency. For this reason, Tcl_CallFrame is defined as a
// structure and not as an opaque token. However, most Tcl_CallFrame fields
// are hidden since applications should not access them directly; others are
// declared as "dummyX".
//
// WARNING!! The structure definition must be kept consistent with the
// CallFrame structure in tclInt.h. If you change one, change the other.

type Tcl_CallFrame = Tcl_CallFrame1 /* tcl.h:937:3 */

//----------------------------------------------------------------------------
// Information about commands that is returned by Tcl_GetCommandInfo and
// passed to Tcl_SetCommandInfo. objProc is an objc/objv object-based command
// function while proc is a traditional Tcl argc/argv string-based function.
// Tcl_CreateObjCommand and Tcl_CreateCommand ensure that both objProc and
// proc are non-NULL and can be called to execute the command. However, it may
// be faster to call one instead of the other. The member isNativeObjectProc
// is set to 1 if an object-based function was registered by
// Tcl_CreateObjCommand, and to 0 if a string-based function was registered by
// Tcl_CreateCommand. The other function is typically set to a compatibility
// wrapper that does string-to-object or object-to-string argument conversions
// then calls the other function.

type Tcl_CmdInfo1 = struct {
	isNativeObjectProc int32
	objProc            uintptr
	objClientData      ClientData
	proc               uintptr
	clientData         ClientData
	deleteProc         uintptr
	deleteData         ClientData
	namespacePtr       uintptr
}

//----------------------------------------------------------------------------
// Information about commands that is returned by Tcl_GetCommandInfo and
// passed to Tcl_SetCommandInfo. objProc is an objc/objv object-based command
// function while proc is a traditional Tcl argc/argv string-based function.
// Tcl_CreateObjCommand and Tcl_CreateCommand ensure that both objProc and
// proc are non-NULL and can be called to execute the command. However, it may
// be faster to call one instead of the other. The member isNativeObjectProc
// is set to 1 if an object-based function was registered by
// Tcl_CreateObjCommand, and to 0 if a string-based function was registered by
// Tcl_CreateCommand. The other function is typically set to a compatibility
// wrapper that does string-to-object or object-to-string argument conversions
// then calls the other function.

type Tcl_CmdInfo = Tcl_CmdInfo1 /* tcl.h:973:3 */

//----------------------------------------------------------------------------
// The structure defined below is used to hold dynamic strings. The only
// fields that clients should use are string and length, accessible via the
// macros Tcl_DStringValue and Tcl_DStringLength.

type Tcl_DString1 = struct {
	string      uintptr
	length      int32
	spaceAvl    int32
	staticSpace [200]int8
}

//----------------------------------------------------------------------------
// The structure defined below is used to hold dynamic strings. The only
// fields that clients should use are string and length, accessible via the
// macros Tcl_DStringValue and Tcl_DStringLength.

type Tcl_DString = Tcl_DString1 /* tcl.h:993:3 */

// Definitions for the maximum number of digits of precision that may be
// specified in the "tcl_precision" variable, and the number of bytes of
// buffer space required by Tcl_PrintDouble.

// Definition for a number of bytes of buffer space sufficient to hold the
// string representation of an integer in base 10 (assuming the existence of
// 64-bit integers).

// Flag values passed to Tcl_ConvertElement.
// TCL_DONT_USE_BRACES forces it not to enclose the element in braces, but to
//	use backslash quoting instead.
// TCL_DONT_QUOTE_HASH disables the default quoting of the '#' character. It
//	is safe to leave the hash unquoted when the element is not the first
//	element of a list, and this flag can be used by the caller to indicate
//	that condition.

// Flag that may be passed to Tcl_GetIndexFromObj to force it to disallow
// abbreviated strings.

//----------------------------------------------------------------------------
// Flag values passed to Tcl_RecordAndEval, Tcl_EvalObj, Tcl_EvalObjv.
// WARNING: these bit choices must not conflict with the bit choices for
// evalFlag bits in tclInt.h!
//
// Meanings:
//	TCL_NO_EVAL:		Just record this command
//	TCL_EVAL_GLOBAL:	Execute script in global namespace
//	TCL_EVAL_DIRECT:	Do not compile this script
//	TCL_EVAL_INVOKE:	Magical Tcl_EvalObjv mode for aliases/ensembles
//				o Run in iPtr->lookupNsPtr or global namespace
//				o Cut out of error traces
//				o Don't reset the flags controlling ensemble
//				  error message rewriting.
//	TCL_CANCEL_UNWIND:	Magical Tcl_CancelEval mode that causes the
//				stack for the script in progress to be
//				completely unwound.
//	TCL_EVAL_NOERR:	Do no exception reporting at all, just return
//				as the caller will report.

// Special freeProc values that may be passed to Tcl_SetResult (see the man
// page for details):

// Flag values passed to variable-related functions.
// WARNING: these bit choices must not conflict with the bit choice for
// TCL_CANCEL_UNWIND, above.

// Required to support old variable/vdelete/vinfo traces.
// Indicate the semantics of the result of a trace.

// Flag values for ensemble commands.

// Flag values passed to command-related functions.

// The TCL_PARSE_PART1 flag is deprecated and has no effect. The part1 is now
// always parsed whenever the part2 is NULL. (This is to avoid a common error
// when converting code to use the new object based APIs and forgetting to
// give the flag)

// Types for linked variables:

//----------------------------------------------------------------------------
// Forward declarations of Tcl_HashTable and related types.

type Tcl_HashKeyType1 = struct {
	version         int32
	flags           int32
	hashKeyProc     uintptr
	compareKeysProc uintptr
	allocEntryProc  uintptr
	freeEntryProc   uintptr
}

// Definitions for the maximum number of digits of precision that may be
// specified in the "tcl_precision" variable, and the number of bytes of
// buffer space required by Tcl_PrintDouble.

// Definition for a number of bytes of buffer space sufficient to hold the
// string representation of an integer in base 10 (assuming the existence of
// 64-bit integers).

// Flag values passed to Tcl_ConvertElement.
// TCL_DONT_USE_BRACES forces it not to enclose the element in braces, but to
//	use backslash quoting instead.
// TCL_DONT_QUOTE_HASH disables the default quoting of the '#' character. It
//	is safe to leave the hash unquoted when the element is not the first
//	element of a list, and this flag can be used by the caller to indicate
//	that condition.

// Flag that may be passed to Tcl_GetIndexFromObj to force it to disallow
// abbreviated strings.

//----------------------------------------------------------------------------
// Flag values passed to Tcl_RecordAndEval, Tcl_EvalObj, Tcl_EvalObjv.
// WARNING: these bit choices must not conflict with the bit choices for
// evalFlag bits in tclInt.h!
//
// Meanings:
//	TCL_NO_EVAL:		Just record this command
//	TCL_EVAL_GLOBAL:	Execute script in global namespace
//	TCL_EVAL_DIRECT:	Do not compile this script
//	TCL_EVAL_INVOKE:	Magical Tcl_EvalObjv mode for aliases/ensembles
//				o Run in iPtr->lookupNsPtr or global namespace
//				o Cut out of error traces
//				o Don't reset the flags controlling ensemble
//				  error message rewriting.
//	TCL_CANCEL_UNWIND:	Magical Tcl_CancelEval mode that causes the
//				stack for the script in progress to be
//				completely unwound.
//	TCL_EVAL_NOERR:	Do no exception reporting at all, just return
//				as the caller will report.

// Special freeProc values that may be passed to Tcl_SetResult (see the man
// page for details):

// Flag values passed to variable-related functions.
// WARNING: these bit choices must not conflict with the bit choice for
// TCL_CANCEL_UNWIND, above.

// Required to support old variable/vdelete/vinfo traces.
// Indicate the semantics of the result of a trace.

// Flag values for ensemble commands.

// Flag values passed to command-related functions.

// The TCL_PARSE_PART1 flag is deprecated and has no effect. The part1 is now
// always parsed whenever the part2 is NULL. (This is to avoid a common error
// when converting code to use the new object based APIs and forgetting to
// give the flag)

// Types for linked variables:

//----------------------------------------------------------------------------
// Forward declarations of Tcl_HashTable and related types.

type Tcl_HashKeyType = Tcl_HashKeyType1 /* tcl.h:1152:32 */
type Tcl_HashTable1 = struct {
	buckets       uintptr
	staticBuckets [4]uintptr
	numBuckets    int32
	numEntries    int32
	rebuildSize   int32
	downShift     int32
	mask          int32
	keyType       int32
	findProc      uintptr
	createProc    uintptr
	typePtr       uintptr
}

type Tcl_HashTable = Tcl_HashTable1 /* tcl.h:1153:30 */
type Tcl_HashEntry1 = struct {
	nextPtr    uintptr
	tablePtr   uintptr
	hash       uintptr
	clientData ClientData
	key        struct{ oneWordValue uintptr }
}

type Tcl_HashEntry = Tcl_HashEntry1 /* tcl.h:1154:30 */

// Structure definition for information used to keep track of searches through
// hash tables:

type Tcl_HashSearch1 = struct {
	tablePtr     uintptr
	nextIndex    int32
	nextEntryPtr uintptr
}

// Structure definition for information used to keep track of searches through
// hash tables:

type Tcl_HashSearch = Tcl_HashSearch1 /* tcl.h:1314:3 */

// Acceptable key types for hash tables:
//
// TCL_STRING_KEYS:		The keys are strings, they are copied into the
//				entry.
// TCL_ONE_WORD_KEYS:		The keys are pointers, the pointer is stored
//				in the entry.
// TCL_CUSTOM_TYPE_KEYS:	The keys are arbitrary types which are copied
//				into the entry.
// TCL_CUSTOM_PTR_KEYS:		The keys are pointers to arbitrary types, the
//				pointer is stored in the entry.
//
// While maintaining binary compatibility the above have to be distinct values
// as they are used to differentiate between old versions of the hash table
// which don't have a typePtr and new ones which do. Once binary compatibility
// is discarded in favour of making more wide spread changes TCL_STRING_KEYS
// can be the same as TCL_CUSTOM_TYPE_KEYS, and TCL_ONE_WORD_KEYS can be the
// same as TCL_CUSTOM_PTR_KEYS because they simply determine how the key is
// accessed from the entry and not the behaviour.

// Structure definition for information used to keep track of searches through
// dictionaries. These fields should not be accessed by code outside
// tclDictObj.c

type Tcl_DictSearch = struct {
	next          uintptr
	epoch         int32
	dictionaryPtr Tcl_Dict
} /* tcl.h:1354:3 */

// Positions to pass to Tcl_QueueEvent:

type Tcl_QueuePosition = uint32 /* tcl.h:1389:3 */

// Values to pass to Tcl_SetServiceMode to specify the behavior of notifier
// event routines.

// The following structure keeps is used to hold a time value, either as an
// absolute time (the number of seconds from the epoch) or as an elapsed time.
// On Unix systems the epoch is Midnight Jan 1, 1970 GMT.

type Tcl_Time1 = struct {
	sec  int64
	usec int64
}

// Values to pass to Tcl_SetServiceMode to specify the behavior of notifier
// event routines.

// The following structure keeps is used to hold a time value, either as an
// absolute time (the number of seconds from the epoch) or as an elapsed time.
// On Unix systems the epoch is Midnight Jan 1, 1970 GMT.

type Tcl_Time = Tcl_Time1 /* tcl.h:1408:3 */

// struct Tcl_ChannelType:
//
// One such structure exists for each type (kind) of channel. It collects
// together in one place all the functions that are part of the specific
// channel type.
//
// It is recommend that the Tcl_Channel* functions are used to access elements
// of this structure, instead of direct accessing.

type Tcl_ChannelType1 = struct {
	typeName         uintptr
	version          Tcl_ChannelTypeVersion
	closeProc        uintptr
	inputProc        uintptr
	outputProc       uintptr
	seekProc         uintptr
	setOptionProc    uintptr
	getOptionProc    uintptr
	watchProc        uintptr
	getHandleProc    uintptr
	close2Proc       uintptr
	blockModeProc    uintptr
	flushProc        uintptr
	handlerProc      uintptr
	wideSeekProc     uintptr
	threadActionProc uintptr
	truncateProc     uintptr
}

// struct Tcl_ChannelType:
//
// One such structure exists for each type (kind) of channel. It collects
// together in one place all the functions that are part of the specific
// channel type.
//
// It is recommend that the Tcl_Channel* functions are used to access elements
// of this structure, instead of direct accessing.

type Tcl_ChannelType = Tcl_ChannelType1 /* tcl.h:1592:3 */

// The following flags determine whether the blockModeProc above should set
// the channel into blocking or nonblocking mode. They are passed as arguments
// to the blockModeProc function in the above structure.

//----------------------------------------------------------------------------
// Enum for different types of file paths.

type Tcl_PathType = uint32 /* tcl.h:1613:3 */

// The following structure is used to pass glob type data amongst the various
// glob routines and Tcl_FSMatchInDirectory.

type Tcl_GlobTypeData1 = struct {
	__type     int32
	perm       int32
	macType    uintptr
	macCreator uintptr
}

// The following structure is used to pass glob type data amongst the various
// glob routines and Tcl_FSMatchInDirectory.

type Tcl_GlobTypeData = Tcl_GlobTypeData1 /* tcl.h:1625:3 */

type Tcl_FSVersion = uintptr /* tcl.h:1700:31 */

//----------------------------------------------------------------------------
// Data structures related to hooking into the filesystem

// Filesystem version tag.  This was introduced in 8.4.

// struct Tcl_Filesystem:
//
// One such structure exists for each type (kind) of filesystem. It collects
// together in one place all the functions that are part of the specific
// filesystem. Tcl always accesses the filesystem through one of these
// structures.
//
// Not all entries need be non-NULL; any which are NULL are simply ignored.
// However, a complete filesystem should provide all of these functions. The
// explanations in the structure show the importance of each function.

type Tcl_Filesystem1 = struct {
	typeName                 uintptr
	structureLength          int32
	version                  Tcl_FSVersion
	pathInFilesystemProc     uintptr
	dupInternalRepProc       uintptr
	freeInternalRepProc      uintptr
	internalToNormalizedProc uintptr
	createInternalRepProc    uintptr
	normalizePathProc        uintptr
	filesystemPathTypeProc   uintptr
	filesystemSeparatorProc  uintptr
	statProc                 uintptr
	accessProc               uintptr
	openFileChannelProc      uintptr
	matchInDirectoryProc     uintptr
	utimeProc                uintptr
	linkProc                 uintptr
	listVolumesProc          uintptr
	fileAttrStringsProc      uintptr
	fileAttrsGetProc         uintptr
	fileAttrsSetProc         uintptr
	createDirectoryProc      uintptr
	removeDirectoryProc      uintptr
	deleteFileProc           uintptr
	copyFileProc             uintptr
	renameFileProc           uintptr
	copyDirectoryProc        uintptr
	lstatProc                uintptr
	loadFileProc             uintptr
	getCwdProc               uintptr
	chdirProc                uintptr
}

//----------------------------------------------------------------------------
// Data structures related to hooking into the filesystem

// Filesystem version tag.  This was introduced in 8.4.

// struct Tcl_Filesystem:
//
// One such structure exists for each type (kind) of filesystem. It collects
// together in one place all the functions that are part of the specific
// filesystem. Tcl always accesses the filesystem through one of these
// structures.
//
// Not all entries need be non-NULL; any which are NULL are simply ignored.
// However, a complete filesystem should provide all of these functions. The
// explanations in the structure show the importance of each function.

type Tcl_Filesystem = Tcl_Filesystem1 /* tcl.h:1873:3 */

// The following definitions are used as values for the 'linkAction' flag to
// Tcl_FSLink, or the linkProc of any filesystem. Any combination of flags can
// be given. For link creation, the linkProc should create a link which
// matches any of the types given.
//
// TCL_CREATE_SYMBOLIC_LINK -	Create a symbolic or soft link.
// TCL_CREATE_HARD_LINK -	Create a hard link.

//----------------------------------------------------------------------------
// The following structure represents the Notifier functions that you can
// override with the Tcl_SetNotifier call.

type Tcl_NotifierProcs1 = struct {
	setTimerProc          uintptr
	waitForEventProc      uintptr
	createFileHandlerProc uintptr
	deleteFileHandlerProc uintptr
	initNotifierProc      uintptr
	finalizeNotifierProc  uintptr
	alertNotifierProc     uintptr
	serviceModeHookProc   uintptr
}

// The following definitions are used as values for the 'linkAction' flag to
// Tcl_FSLink, or the linkProc of any filesystem. Any combination of flags can
// be given. For link creation, the linkProc should create a link which
// matches any of the types given.
//
// TCL_CREATE_SYMBOLIC_LINK -	Create a symbolic or soft link.
// TCL_CREATE_HARD_LINK -	Create a hard link.

//----------------------------------------------------------------------------
// The following structure represents the Notifier functions that you can
// override with the Tcl_SetNotifier call.

type Tcl_NotifierProcs = Tcl_NotifierProcs1 /* tcl.h:1903:3 */

//----------------------------------------------------------------------------
// The following data structures and declarations are for the new Tcl parser.
//
// For each word of a command, and for each piece of a word such as a variable
// reference, one of the following structures is created to describe the
// token.

type Tcl_Token1 = struct {
	__type        int32
	start         uintptr
	size          int32
	numComponents int32
}

//----------------------------------------------------------------------------
// The following data structures and declarations are for the new Tcl parser.
//
// For each word of a command, and for each piece of a word such as a variable
// reference, one of the following structures is created to describe the
// token.

type Tcl_Token = Tcl_Token1 /* tcl.h:1924:3 */

// Type values defined for Tcl_Token structures. These values are defined as
// mask bits so that it's easy to check for collections of types.
//
// TCL_TOKEN_WORD -		The token describes one word of a command,
//				from the first non-blank character of the word
//				(which may be " or {) up to but not including
//				the space, semicolon, or bracket that
//				terminates the word. NumComponents counts the
//				total number of sub-tokens that make up the
//				word. This includes, for example, sub-tokens
//				of TCL_TOKEN_VARIABLE tokens.
// TCL_TOKEN_SIMPLE_WORD -	This token is just like TCL_TOKEN_WORD except
//				that the word is guaranteed to consist of a
//				single TCL_TOKEN_TEXT sub-token.
// TCL_TOKEN_TEXT -		The token describes a range of literal text
//				that is part of a word. NumComponents is
//				always 0.
// TCL_TOKEN_BS -		The token describes a backslash sequence that
//				must be collapsed. NumComponents is always 0.
// TCL_TOKEN_COMMAND -		The token describes a command whose result
//				must be substituted into the word. The token
//				includes the enclosing brackets. NumComponents
//				is always 0.
// TCL_TOKEN_VARIABLE -		The token describes a variable substitution,
//				including the dollar sign, variable name, and
//				array index (if there is one) up through the
//				right parentheses. NumComponents tells how
//				many additional tokens follow to represent the
//				variable name. The first token will be a
//				TCL_TOKEN_TEXT token that describes the
//				variable name. If the variable is an array
//				reference then there will be one or more
//				additional tokens, of type TCL_TOKEN_TEXT,
//				TCL_TOKEN_BS, TCL_TOKEN_COMMAND, and
//				TCL_TOKEN_VARIABLE, that describe the array
//				index; numComponents counts the total number
//				of nested tokens that make up the variable
//				reference, including sub-tokens of
//				TCL_TOKEN_VARIABLE tokens.
// TCL_TOKEN_SUB_EXPR -		The token describes one subexpression of an
//				expression, from the first non-blank character
//				of the subexpression up to but not including
//				the space, brace, or bracket that terminates
//				the subexpression. NumComponents counts the
//				total number of following subtokens that make
//				up the subexpression; this includes all
//				subtokens for any nested TCL_TOKEN_SUB_EXPR
//				tokens. For example, a numeric value used as a
//				primitive operand is described by a
//				TCL_TOKEN_SUB_EXPR token followed by a
//				TCL_TOKEN_TEXT token. A binary subexpression
//				is described by a TCL_TOKEN_SUB_EXPR token
//				followed by the TCL_TOKEN_OPERATOR token for
//				the operator, then TCL_TOKEN_SUB_EXPR tokens
//				for the left then the right operands.
// TCL_TOKEN_OPERATOR -		The token describes one expression operator.
//				An operator might be the name of a math
//				function such as "abs". A TCL_TOKEN_OPERATOR
//				token is always preceded by one
//				TCL_TOKEN_SUB_EXPR token for the operator's
//				subexpression, and is followed by zero or more
//				TCL_TOKEN_SUB_EXPR tokens for the operator's
//				operands. NumComponents is always 0.
// TCL_TOKEN_EXPAND_WORD -	This token is just like TCL_TOKEN_WORD except
//				that it marks a word that began with the
//				literal character prefix "{*}". This word is
//				marked to be expanded - that is, broken into
//				words after substitution is complete.

// Parsing error types. On any parsing error, one of these values will be
// stored in the error field of the Tcl_Parse structure defined below.

// A structure of the following type is filled in by Tcl_ParseCommand. It
// describes a single command parsed from an input string.

type Tcl_Parse1 = struct {
	commentStart    uintptr
	commentSize     int32
	commandStart    uintptr
	commandSize     int32
	numWords        int32
	tokenPtr        uintptr
	numTokens       int32
	tokensAvailable int32
	errorType       int32
	string          uintptr
	end             uintptr
	interp          uintptr
	term            uintptr
	incomplete      int32
	staticTokens    [20]Tcl_Token
}

// Type values defined for Tcl_Token structures. These values are defined as
// mask bits so that it's easy to check for collections of types.
//
// TCL_TOKEN_WORD -		The token describes one word of a command,
//				from the first non-blank character of the word
//				(which may be " or {) up to but not including
//				the space, semicolon, or bracket that
//				terminates the word. NumComponents counts the
//				total number of sub-tokens that make up the
//				word. This includes, for example, sub-tokens
//				of TCL_TOKEN_VARIABLE tokens.
// TCL_TOKEN_SIMPLE_WORD -	This token is just like TCL_TOKEN_WORD except
//				that the word is guaranteed to consist of a
//				single TCL_TOKEN_TEXT sub-token.
// TCL_TOKEN_TEXT -		The token describes a range of literal text
//				that is part of a word. NumComponents is
//				always 0.
// TCL_TOKEN_BS -		The token describes a backslash sequence that
//				must be collapsed. NumComponents is always 0.
// TCL_TOKEN_COMMAND -		The token describes a command whose result
//				must be substituted into the word. The token
//				includes the enclosing brackets. NumComponents
//				is always 0.
// TCL_TOKEN_VARIABLE -		The token describes a variable substitution,
//				including the dollar sign, variable name, and
//				array index (if there is one) up through the
//				right parentheses. NumComponents tells how
//				many additional tokens follow to represent the
//				variable name. The first token will be a
//				TCL_TOKEN_TEXT token that describes the
//				variable name. If the variable is an array
//				reference then there will be one or more
//				additional tokens, of type TCL_TOKEN_TEXT,
//				TCL_TOKEN_BS, TCL_TOKEN_COMMAND, and
//				TCL_TOKEN_VARIABLE, that describe the array
//				index; numComponents counts the total number
//				of nested tokens that make up the variable
//				reference, including sub-tokens of
//				TCL_TOKEN_VARIABLE tokens.
// TCL_TOKEN_SUB_EXPR -		The token describes one subexpression of an
//				expression, from the first non-blank character
//				of the subexpression up to but not including
//				the space, brace, or bracket that terminates
//				the subexpression. NumComponents counts the
//				total number of following subtokens that make
//				up the subexpression; this includes all
//				subtokens for any nested TCL_TOKEN_SUB_EXPR
//				tokens. For example, a numeric value used as a
//				primitive operand is described by a
//				TCL_TOKEN_SUB_EXPR token followed by a
//				TCL_TOKEN_TEXT token. A binary subexpression
//				is described by a TCL_TOKEN_SUB_EXPR token
//				followed by the TCL_TOKEN_OPERATOR token for
//				the operator, then TCL_TOKEN_SUB_EXPR tokens
//				for the left then the right operands.
// TCL_TOKEN_OPERATOR -		The token describes one expression operator.
//				An operator might be the name of a math
//				function such as "abs". A TCL_TOKEN_OPERATOR
//				token is always preceded by one
//				TCL_TOKEN_SUB_EXPR token for the operator's
//				subexpression, and is followed by zero or more
//				TCL_TOKEN_SUB_EXPR tokens for the operator's
//				operands. NumComponents is always 0.
// TCL_TOKEN_EXPAND_WORD -	This token is just like TCL_TOKEN_WORD except
//				that it marks a word that began with the
//				literal character prefix "{*}". This word is
//				marked to be expanded - that is, broken into
//				words after substitution is complete.

// Parsing error types. On any parsing error, one of these values will be
// stored in the error field of the Tcl_Parse structure defined below.

// A structure of the following type is filled in by Tcl_ParseCommand. It
// describes a single command parsed from an input string.

type Tcl_Parse = Tcl_Parse1 /* tcl.h:2083:3 */

//----------------------------------------------------------------------------
// The following structure represents a user-defined encoding. It collects
// together all the functions that are used by the specific encoding.

type Tcl_EncodingType1 = struct {
	encodingName uintptr
	toUtfProc    uintptr
	fromUtfProc  uintptr
	freeProc     uintptr
	clientData   ClientData
	nullSize     int32
	_            [4]byte
}

//----------------------------------------------------------------------------
// The following structure represents a user-defined encoding. It collects
// together all the functions that are used by the specific encoding.

type Tcl_EncodingType = Tcl_EncodingType1 /* tcl.h:2111:3 */

// The following definitions are used as values for the conversion control
// flags argument when converting text from one character set to another:
//
// TCL_ENCODING_START -		Signifies that the source buffer is the first
//				block in a (potentially multi-block) input
//				stream. Tells the conversion function to reset
//				to an initial state and perform any
//				initialization that needs to occur before the
//				first byte is converted. If the source buffer
//				contains the entire input stream to be
//				converted, this flag should be set.
// TCL_ENCODING_END -		Signifies that the source buffer is the last
//				block in a (potentially multi-block) input
//				stream. Tells the conversion routine to
//				perform any finalization that needs to occur
//				after the last byte is converted and then to
//				reset to an initial state. If the source
//				buffer contains the entire input stream to be
//				converted, this flag should be set.
// TCL_ENCODING_STOPONERROR -	If set, then the converter will return
//				immediately upon encountering an invalid byte
//				sequence or a source character that has no
//				mapping in the target encoding. If clear, then
//				the converter will skip the problem,
//				substituting one or more "close" characters in
//				the destination buffer and then continue to
//				convert the source.
// TCL_ENCODING_NO_TERMINATE - 	If set, Tcl_ExternalToUtf will not append a
//				terminating NUL byte.  Knowing that it will
//				not need space to do so, it will fill all
//				dstLen bytes with encoded UTF-8 content, as
//				other circumstances permit.  If clear, the
//				default behavior is to reserve a byte in
//				the dst space for NUL termination, and to
//				append the NUL byte.
// TCL_ENCODING_CHAR_LIMIT -	If set and dstCharsPtr is not NULL, then
//				Tcl_ExternalToUtf takes the initial value
//				of *dstCharsPtr is taken as a limit of the
//				maximum number of chars to produce in the
//				encoded UTF-8 content.  Otherwise, the
//				number of chars produced is controlled only
//				by other limiting factors.

// The following definitions are the error codes returned by the conversion
// routines:
//
// TCL_OK -			All characters were converted.
// TCL_CONVERT_NOSPACE -	The output buffer would not have been large
//				enough for all of the converted data; as many
//				characters as could fit were converted though.
// TCL_CONVERT_MULTIBYTE -	The last few bytes in the source string were
//				the beginning of a multibyte sequence, but
//				more bytes were needed to complete this
//				sequence. A subsequent call to the conversion
//				routine should pass the beginning of this
//				unconverted sequence plus additional bytes
//				from the source stream to properly convert the
//				formerly split-up multibyte sequence.
// TCL_CONVERT_SYNTAX -		The source stream contained an invalid
//				character sequence. This may occur if the
//				input stream has been damaged or if the input
//				encoding method was misidentified. This error
//				is reported only if TCL_ENCODING_STOPONERROR
//				was specified.
// TCL_CONVERT_UNKNOWN -	The source string contained a character that
//				could not be represented in the target
//				encoding. This error is reported only if
//				TCL_ENCODING_STOPONERROR was specified.

// The maximum number of bytes that are necessary to represent a single
// Unicode character in UTF-8. The valid values should be 3, 4 or 6
// (or perhaps 1 if we want to support a non-unicode enabled core). If 3 or
// 4, then Tcl_UniChar must be 2-bytes in size (UCS-2) (the default). If 6,
// then Tcl_UniChar must be 4-bytes in size (UCS-4). At this time UCS-2 mode
// is the default and recommended mode. UCS-4 is experimental and not
// recommended. It works for the core, but most extensions expect UCS-2.

// This represents a Unicode character. Any changes to this should also be
// reflected in regcustom.h.

type Tcl_UniChar = uint16 /* tcl.h:2228:24 */

//----------------------------------------------------------------------------
// TIP #59: The following structure is used in calls 'Tcl_RegisterConfig' to
// provide the system with the embedded configuration data.

type Tcl_Config1 = struct {
	key   uintptr
	value uintptr
}

//----------------------------------------------------------------------------
// TIP #59: The following structure is used in calls 'Tcl_RegisterConfig' to
// provide the system with the embedded configuration data.

type Tcl_Config = Tcl_Config1 /* tcl.h:2242:3 */
type mp_digit = uint32        /* tcl.h:2268:22 */

//----------------------------------------------------------------------------
// Definitions needed for Tcl_ParseArgvObj routines.
// Based on tkArgv.c.
// Modifications from the original are copyright (c) Sam Bromley 2006

type Tcl_ArgvInfo = struct {
	__type     int32
	keyStr     uintptr
	srcPtr     uintptr
	dstPtr     uintptr
	helpStr    uintptr
	clientData ClientData
} /* tcl.h:2289:3 */

type TclPlatStubs1 = struct {
	magic int32
	hooks uintptr
}

type TclStubHooks = struct {
	tclPlatStubs    uintptr
	tclIntStubs     uintptr
	tclIntPlatStubs uintptr
} /* tclDecls.h:1843:3 */

type TclStubs1 = struct {
	magic                                  int32
	hooks                                  uintptr
	tcl_PkgProvideEx                       uintptr
	tcl_PkgRequireEx                       uintptr
	tcl_Panic                              uintptr
	tcl_Alloc                              uintptr
	tcl_Free                               uintptr
	tcl_Realloc                            uintptr
	tcl_DbCkalloc                          uintptr
	tcl_DbCkfree                           uintptr
	tcl_DbCkrealloc                        uintptr
	tcl_CreateFileHandler                  uintptr
	tcl_DeleteFileHandler                  uintptr
	tcl_SetTimer                           uintptr
	tcl_Sleep                              uintptr
	tcl_WaitForEvent                       uintptr
	tcl_AppendAllObjTypes                  uintptr
	tcl_AppendStringsToObj                 uintptr
	tcl_AppendToObj                        uintptr
	tcl_ConcatObj                          uintptr
	tcl_ConvertToType                      uintptr
	tcl_DbDecrRefCount                     uintptr
	tcl_DbIncrRefCount                     uintptr
	tcl_DbIsShared                         uintptr
	tcl_DbNewBooleanObj                    uintptr
	tcl_DbNewByteArrayObj                  uintptr
	tcl_DbNewDoubleObj                     uintptr
	tcl_DbNewListObj                       uintptr
	tcl_DbNewLongObj                       uintptr
	tcl_DbNewObj                           uintptr
	tcl_DbNewStringObj                     uintptr
	tcl_DuplicateObj                       uintptr
	tclFreeObj                             uintptr
	tcl_GetBoolean                         uintptr
	tcl_GetBooleanFromObj                  uintptr
	tcl_GetByteArrayFromObj                uintptr
	tcl_GetDouble                          uintptr
	tcl_GetDoubleFromObj                   uintptr
	tcl_GetIndexFromObj                    uintptr
	tcl_GetInt                             uintptr
	tcl_GetIntFromObj                      uintptr
	tcl_GetLongFromObj                     uintptr
	tcl_GetObjType                         uintptr
	tcl_GetStringFromObj                   uintptr
	tcl_InvalidateStringRep                uintptr
	tcl_ListObjAppendList                  uintptr
	tcl_ListObjAppendElement               uintptr
	tcl_ListObjGetElements                 uintptr
	tcl_ListObjIndex                       uintptr
	tcl_ListObjLength                      uintptr
	tcl_ListObjReplace                     uintptr
	tcl_NewBooleanObj                      uintptr
	tcl_NewByteArrayObj                    uintptr
	tcl_NewDoubleObj                       uintptr
	tcl_NewIntObj                          uintptr
	tcl_NewListObj                         uintptr
	tcl_NewLongObj                         uintptr
	tcl_NewObj                             uintptr
	tcl_NewStringObj                       uintptr
	tcl_SetBooleanObj                      uintptr
	tcl_SetByteArrayLength                 uintptr
	tcl_SetByteArrayObj                    uintptr
	tcl_SetDoubleObj                       uintptr
	tcl_SetIntObj                          uintptr
	tcl_SetListObj                         uintptr
	tcl_SetLongObj                         uintptr
	tcl_SetObjLength                       uintptr
	tcl_SetStringObj                       uintptr
	tcl_AddErrorInfo                       uintptr
	tcl_AddObjErrorInfo                    uintptr
	tcl_AllowExceptions                    uintptr
	tcl_AppendElement                      uintptr
	tcl_AppendResult                       uintptr
	tcl_AsyncCreate                        uintptr
	tcl_AsyncDelete                        uintptr
	tcl_AsyncInvoke                        uintptr
	tcl_AsyncMark                          uintptr
	tcl_AsyncReady                         uintptr
	tcl_BackgroundError                    uintptr
	tcl_Backslash                          uintptr
	tcl_BadChannelOption                   uintptr
	tcl_CallWhenDeleted                    uintptr
	tcl_CancelIdleCall                     uintptr
	tcl_Close                              uintptr
	tcl_CommandComplete                    uintptr
	tcl_Concat                             uintptr
	tcl_ConvertElement                     uintptr
	tcl_ConvertCountedElement              uintptr
	tcl_CreateAlias                        uintptr
	tcl_CreateAliasObj                     uintptr
	tcl_CreateChannel                      uintptr
	tcl_CreateChannelHandler               uintptr
	tcl_CreateCloseHandler                 uintptr
	tcl_CreateCommand                      uintptr
	tcl_CreateEventSource                  uintptr
	tcl_CreateExitHandler                  uintptr
	tcl_CreateInterp                       uintptr
	tcl_CreateMathFunc                     uintptr
	tcl_CreateObjCommand                   uintptr
	tcl_CreateSlave                        uintptr
	tcl_CreateTimerHandler                 uintptr
	tcl_CreateTrace                        uintptr
	tcl_DeleteAssocData                    uintptr
	tcl_DeleteChannelHandler               uintptr
	tcl_DeleteCloseHandler                 uintptr
	tcl_DeleteCommand                      uintptr
	tcl_DeleteCommandFromToken             uintptr
	tcl_DeleteEvents                       uintptr
	tcl_DeleteEventSource                  uintptr
	tcl_DeleteExitHandler                  uintptr
	tcl_DeleteHashEntry                    uintptr
	tcl_DeleteHashTable                    uintptr
	tcl_DeleteInterp                       uintptr
	tcl_DetachPids                         uintptr
	tcl_DeleteTimerHandler                 uintptr
	tcl_DeleteTrace                        uintptr
	tcl_DontCallWhenDeleted                uintptr
	tcl_DoOneEvent                         uintptr
	tcl_DoWhenIdle                         uintptr
	tcl_DStringAppend                      uintptr
	tcl_DStringAppendElement               uintptr
	tcl_DStringEndSublist                  uintptr
	tcl_DStringFree                        uintptr
	tcl_DStringGetResult                   uintptr
	tcl_DStringInit                        uintptr
	tcl_DStringResult                      uintptr
	tcl_DStringSetLength                   uintptr
	tcl_DStringStartSublist                uintptr
	tcl_Eof                                uintptr
	tcl_ErrnoId                            uintptr
	tcl_ErrnoMsg                           uintptr
	tcl_Eval                               uintptr
	tcl_EvalFile                           uintptr
	tcl_EvalObj                            uintptr
	tcl_EventuallyFree                     uintptr
	tcl_Exit                               uintptr
	tcl_ExposeCommand                      uintptr
	tcl_ExprBoolean                        uintptr
	tcl_ExprBooleanObj                     uintptr
	tcl_ExprDouble                         uintptr
	tcl_ExprDoubleObj                      uintptr
	tcl_ExprLong                           uintptr
	tcl_ExprLongObj                        uintptr
	tcl_ExprObj                            uintptr
	tcl_ExprString                         uintptr
	tcl_Finalize                           uintptr
	tcl_FindExecutable                     uintptr
	tcl_FirstHashEntry                     uintptr
	tcl_Flush                              uintptr
	tcl_FreeResult                         uintptr
	tcl_GetAlias                           uintptr
	tcl_GetAliasObj                        uintptr
	tcl_GetAssocData                       uintptr
	tcl_GetChannel                         uintptr
	tcl_GetChannelBufferSize               uintptr
	tcl_GetChannelHandle                   uintptr
	tcl_GetChannelInstanceData             uintptr
	tcl_GetChannelMode                     uintptr
	tcl_GetChannelName                     uintptr
	tcl_GetChannelOption                   uintptr
	tcl_GetChannelType                     uintptr
	tcl_GetCommandInfo                     uintptr
	tcl_GetCommandName                     uintptr
	tcl_GetErrno                           uintptr
	tcl_GetHostName                        uintptr
	tcl_GetInterpPath                      uintptr
	tcl_GetMaster                          uintptr
	tcl_GetNameOfExecutable                uintptr
	tcl_GetObjResult                       uintptr
	tcl_GetOpenFile                        uintptr
	tcl_GetPathType                        uintptr
	tcl_Gets                               uintptr
	tcl_GetsObj                            uintptr
	tcl_GetServiceMode                     uintptr
	tcl_GetSlave                           uintptr
	tcl_GetStdChannel                      uintptr
	tcl_GetStringResult                    uintptr
	tcl_GetVar                             uintptr
	tcl_GetVar2                            uintptr
	tcl_GlobalEval                         uintptr
	tcl_GlobalEvalObj                      uintptr
	tcl_HideCommand                        uintptr
	tcl_Init                               uintptr
	tcl_InitHashTable                      uintptr
	tcl_InputBlocked                       uintptr
	tcl_InputBuffered                      uintptr
	tcl_InterpDeleted                      uintptr
	tcl_IsSafe                             uintptr
	tcl_JoinPath                           uintptr
	tcl_LinkVar                            uintptr
	reserved188                            uintptr
	tcl_MakeFileChannel                    uintptr
	tcl_MakeSafe                           uintptr
	tcl_MakeTcpClientChannel               uintptr
	tcl_Merge                              uintptr
	tcl_NextHashEntry                      uintptr
	tcl_NotifyChannel                      uintptr
	tcl_ObjGetVar2                         uintptr
	tcl_ObjSetVar2                         uintptr
	tcl_OpenCommandChannel                 uintptr
	tcl_OpenFileChannel                    uintptr
	tcl_OpenTcpClient                      uintptr
	tcl_OpenTcpServer                      uintptr
	tcl_Preserve                           uintptr
	tcl_PrintDouble                        uintptr
	tcl_PutEnv                             uintptr
	tcl_PosixError                         uintptr
	tcl_QueueEvent                         uintptr
	tcl_Read                               uintptr
	tcl_ReapDetachedProcs                  uintptr
	tcl_RecordAndEval                      uintptr
	tcl_RecordAndEvalObj                   uintptr
	tcl_RegisterChannel                    uintptr
	tcl_RegisterObjType                    uintptr
	tcl_RegExpCompile                      uintptr
	tcl_RegExpExec                         uintptr
	tcl_RegExpMatch                        uintptr
	tcl_RegExpRange                        uintptr
	tcl_Release                            uintptr
	tcl_ResetResult                        uintptr
	tcl_ScanElement                        uintptr
	tcl_ScanCountedElement                 uintptr
	tcl_SeekOld                            uintptr
	tcl_ServiceAll                         uintptr
	tcl_ServiceEvent                       uintptr
	tcl_SetAssocData                       uintptr
	tcl_SetChannelBufferSize               uintptr
	tcl_SetChannelOption                   uintptr
	tcl_SetCommandInfo                     uintptr
	tcl_SetErrno                           uintptr
	tcl_SetErrorCode                       uintptr
	tcl_SetMaxBlockTime                    uintptr
	tcl_SetPanicProc                       uintptr
	tcl_SetRecursionLimit                  uintptr
	tcl_SetResult                          uintptr
	tcl_SetServiceMode                     uintptr
	tcl_SetObjErrorCode                    uintptr
	tcl_SetObjResult                       uintptr
	tcl_SetStdChannel                      uintptr
	tcl_SetVar                             uintptr
	tcl_SetVar2                            uintptr
	tcl_SignalId                           uintptr
	tcl_SignalMsg                          uintptr
	tcl_SourceRCFile                       uintptr
	tcl_SplitList                          uintptr
	tcl_SplitPath                          uintptr
	tcl_StaticPackage                      uintptr
	tcl_StringMatch                        uintptr
	tcl_TellOld                            uintptr
	tcl_TraceVar                           uintptr
	tcl_TraceVar2                          uintptr
	tcl_TranslateFileName                  uintptr
	tcl_Ungets                             uintptr
	tcl_UnlinkVar                          uintptr
	tcl_UnregisterChannel                  uintptr
	tcl_UnsetVar                           uintptr
	tcl_UnsetVar2                          uintptr
	tcl_UntraceVar                         uintptr
	tcl_UntraceVar2                        uintptr
	tcl_UpdateLinkedVar                    uintptr
	tcl_UpVar                              uintptr
	tcl_UpVar2                             uintptr
	tcl_VarEval                            uintptr
	tcl_VarTraceInfo                       uintptr
	tcl_VarTraceInfo2                      uintptr
	tcl_Write                              uintptr
	tcl_WrongNumArgs                       uintptr
	tcl_DumpActiveMemory                   uintptr
	tcl_ValidateAllMemory                  uintptr
	tcl_AppendResultVA                     uintptr
	tcl_AppendStringsToObjVA               uintptr
	tcl_HashStats                          uintptr
	tcl_ParseVar                           uintptr
	tcl_PkgPresent                         uintptr
	tcl_PkgPresentEx                       uintptr
	tcl_PkgProvide                         uintptr
	tcl_PkgRequire                         uintptr
	tcl_SetErrorCodeVA                     uintptr
	tcl_VarEvalVA                          uintptr
	tcl_WaitPid                            uintptr
	tcl_PanicVA                            uintptr
	tcl_GetVersion                         uintptr
	tcl_InitMemory                         uintptr
	tcl_StackChannel                       uintptr
	tcl_UnstackChannel                     uintptr
	tcl_GetStackedChannel                  uintptr
	tcl_SetMainLoop                        uintptr
	reserved285                            uintptr
	tcl_AppendObjToObj                     uintptr
	tcl_CreateEncoding                     uintptr
	tcl_CreateThreadExitHandler            uintptr
	tcl_DeleteThreadExitHandler            uintptr
	tcl_DiscardResult                      uintptr
	tcl_EvalEx                             uintptr
	tcl_EvalObjv                           uintptr
	tcl_EvalObjEx                          uintptr
	tcl_ExitThread                         uintptr
	tcl_ExternalToUtf                      uintptr
	tcl_ExternalToUtfDString               uintptr
	tcl_FinalizeThread                     uintptr
	tcl_FinalizeNotifier                   uintptr
	tcl_FreeEncoding                       uintptr
	tcl_GetCurrentThread                   uintptr
	tcl_GetEncoding                        uintptr
	tcl_GetEncodingName                    uintptr
	tcl_GetEncodingNames                   uintptr
	tcl_GetIndexFromObjStruct              uintptr
	tcl_GetThreadData                      uintptr
	tcl_GetVar2Ex                          uintptr
	tcl_InitNotifier                       uintptr
	tcl_MutexLock                          uintptr
	tcl_MutexUnlock                        uintptr
	tcl_ConditionNotify                    uintptr
	tcl_ConditionWait                      uintptr
	tcl_NumUtfChars                        uintptr
	tcl_ReadChars                          uintptr
	tcl_RestoreResult                      uintptr
	tcl_SaveResult                         uintptr
	tcl_SetSystemEncoding                  uintptr
	tcl_SetVar2Ex                          uintptr
	tcl_ThreadAlert                        uintptr
	tcl_ThreadQueueEvent                   uintptr
	tcl_UniCharAtIndex                     uintptr
	tcl_UniCharToLower                     uintptr
	tcl_UniCharToTitle                     uintptr
	tcl_UniCharToUpper                     uintptr
	tcl_UniCharToUtf                       uintptr
	tcl_UtfAtIndex                         uintptr
	tcl_UtfCharComplete                    uintptr
	tcl_UtfBackslash                       uintptr
	tcl_UtfFindFirst                       uintptr
	tcl_UtfFindLast                        uintptr
	tcl_UtfNext                            uintptr
	tcl_UtfPrev                            uintptr
	tcl_UtfToExternal                      uintptr
	tcl_UtfToExternalDString               uintptr
	tcl_UtfToLower                         uintptr
	tcl_UtfToTitle                         uintptr
	tcl_UtfToUniChar                       uintptr
	tcl_UtfToUpper                         uintptr
	tcl_WriteChars                         uintptr
	tcl_WriteObj                           uintptr
	tcl_GetString                          uintptr
	tcl_GetDefaultEncodingDir              uintptr
	tcl_SetDefaultEncodingDir              uintptr
	tcl_AlertNotifier                      uintptr
	tcl_ServiceModeHook                    uintptr
	tcl_UniCharIsAlnum                     uintptr
	tcl_UniCharIsAlpha                     uintptr
	tcl_UniCharIsDigit                     uintptr
	tcl_UniCharIsLower                     uintptr
	tcl_UniCharIsSpace                     uintptr
	tcl_UniCharIsUpper                     uintptr
	tcl_UniCharIsWordChar                  uintptr
	tcl_UniCharLen                         uintptr
	tcl_UniCharNcmp                        uintptr
	tcl_UniCharToUtfDString                uintptr
	tcl_UtfToUniCharDString                uintptr
	tcl_GetRegExpFromObj                   uintptr
	tcl_EvalTokens                         uintptr
	tcl_FreeParse                          uintptr
	tcl_LogCommandInfo                     uintptr
	tcl_ParseBraces                        uintptr
	tcl_ParseCommand                       uintptr
	tcl_ParseExpr                          uintptr
	tcl_ParseQuotedString                  uintptr
	tcl_ParseVarName                       uintptr
	tcl_GetCwd                             uintptr
	tcl_Chdir                              uintptr
	tcl_Access                             uintptr
	tcl_Stat                               uintptr
	tcl_UtfNcmp                            uintptr
	tcl_UtfNcasecmp                        uintptr
	tcl_StringCaseMatch                    uintptr
	tcl_UniCharIsControl                   uintptr
	tcl_UniCharIsGraph                     uintptr
	tcl_UniCharIsPrint                     uintptr
	tcl_UniCharIsPunct                     uintptr
	tcl_RegExpExecObj                      uintptr
	tcl_RegExpGetInfo                      uintptr
	tcl_NewUnicodeObj                      uintptr
	tcl_SetUnicodeObj                      uintptr
	tcl_GetCharLength                      uintptr
	tcl_GetUniChar                         uintptr
	tcl_GetUnicode                         uintptr
	tcl_GetRange                           uintptr
	tcl_AppendUnicodeToObj                 uintptr
	tcl_RegExpMatchObj                     uintptr
	tcl_SetNotifier                        uintptr
	tcl_GetAllocMutex                      uintptr
	tcl_GetChannelNames                    uintptr
	tcl_GetChannelNamesEx                  uintptr
	tcl_ProcObjCmd                         uintptr
	tcl_ConditionFinalize                  uintptr
	tcl_MutexFinalize                      uintptr
	tcl_CreateThread                       uintptr
	tcl_ReadRaw                            uintptr
	tcl_WriteRaw                           uintptr
	tcl_GetTopChannel                      uintptr
	tcl_ChannelBuffered                    uintptr
	tcl_ChannelName                        uintptr
	tcl_ChannelVersion                     uintptr
	tcl_ChannelBlockModeProc               uintptr
	tcl_ChannelCloseProc                   uintptr
	tcl_ChannelClose2Proc                  uintptr
	tcl_ChannelInputProc                   uintptr
	tcl_ChannelOutputProc                  uintptr
	tcl_ChannelSeekProc                    uintptr
	tcl_ChannelSetOptionProc               uintptr
	tcl_ChannelGetOptionProc               uintptr
	tcl_ChannelWatchProc                   uintptr
	tcl_ChannelGetHandleProc               uintptr
	tcl_ChannelFlushProc                   uintptr
	tcl_ChannelHandlerProc                 uintptr
	tcl_JoinThread                         uintptr
	tcl_IsChannelShared                    uintptr
	tcl_IsChannelRegistered                uintptr
	tcl_CutChannel                         uintptr
	tcl_SpliceChannel                      uintptr
	tcl_ClearChannelHandlers               uintptr
	tcl_IsChannelExisting                  uintptr
	tcl_UniCharNcasecmp                    uintptr
	tcl_UniCharCaseMatch                   uintptr
	tcl_FindHashEntry                      uintptr
	tcl_CreateHashEntry                    uintptr
	tcl_InitCustomHashTable                uintptr
	tcl_InitObjHashTable                   uintptr
	tcl_CommandTraceInfo                   uintptr
	tcl_TraceCommand                       uintptr
	tcl_UntraceCommand                     uintptr
	tcl_AttemptAlloc                       uintptr
	tcl_AttemptDbCkalloc                   uintptr
	tcl_AttemptRealloc                     uintptr
	tcl_AttemptDbCkrealloc                 uintptr
	tcl_AttemptSetObjLength                uintptr
	tcl_GetChannelThread                   uintptr
	tcl_GetUnicodeFromObj                  uintptr
	tcl_GetMathFuncInfo                    uintptr
	tcl_ListMathFuncs                      uintptr
	tcl_SubstObj                           uintptr
	tcl_DetachChannel                      uintptr
	tcl_IsStandardChannel                  uintptr
	tcl_FSCopyFile                         uintptr
	tcl_FSCopyDirectory                    uintptr
	tcl_FSCreateDirectory                  uintptr
	tcl_FSDeleteFile                       uintptr
	tcl_FSLoadFile                         uintptr
	tcl_FSMatchInDirectory                 uintptr
	tcl_FSLink                             uintptr
	tcl_FSRemoveDirectory                  uintptr
	tcl_FSRenameFile                       uintptr
	tcl_FSLstat                            uintptr
	tcl_FSUtime                            uintptr
	tcl_FSFileAttrsGet                     uintptr
	tcl_FSFileAttrsSet                     uintptr
	tcl_FSFileAttrStrings                  uintptr
	tcl_FSStat                             uintptr
	tcl_FSAccess                           uintptr
	tcl_FSOpenFileChannel                  uintptr
	tcl_FSGetCwd                           uintptr
	tcl_FSChdir                            uintptr
	tcl_FSConvertToPathType                uintptr
	tcl_FSJoinPath                         uintptr
	tcl_FSSplitPath                        uintptr
	tcl_FSEqualPaths                       uintptr
	tcl_FSGetNormalizedPath                uintptr
	tcl_FSJoinToPath                       uintptr
	tcl_FSGetInternalRep                   uintptr
	tcl_FSGetTranslatedPath                uintptr
	tcl_FSEvalFile                         uintptr
	tcl_FSNewNativePath                    uintptr
	tcl_FSGetNativePath                    uintptr
	tcl_FSFileSystemInfo                   uintptr
	tcl_FSPathSeparator                    uintptr
	tcl_FSListVolumes                      uintptr
	tcl_FSRegister                         uintptr
	tcl_FSUnregister                       uintptr
	tcl_FSData                             uintptr
	tcl_FSGetTranslatedStringPath          uintptr
	tcl_FSGetFileSystemForPath             uintptr
	tcl_FSGetPathType                      uintptr
	tcl_OutputBuffered                     uintptr
	tcl_FSMountsChanged                    uintptr
	tcl_EvalTokensStandard                 uintptr
	tcl_GetTime                            uintptr
	tcl_CreateObjTrace                     uintptr
	tcl_GetCommandInfoFromToken            uintptr
	tcl_SetCommandInfoFromToken            uintptr
	tcl_DbNewWideIntObj                    uintptr
	tcl_GetWideIntFromObj                  uintptr
	tcl_NewWideIntObj                      uintptr
	tcl_SetWideIntObj                      uintptr
	tcl_AllocStatBuf                       uintptr
	tcl_Seek                               uintptr
	tcl_Tell                               uintptr
	tcl_ChannelWideSeekProc                uintptr
	tcl_DictObjPut                         uintptr
	tcl_DictObjGet                         uintptr
	tcl_DictObjRemove                      uintptr
	tcl_DictObjSize                        uintptr
	tcl_DictObjFirst                       uintptr
	tcl_DictObjNext                        uintptr
	tcl_DictObjDone                        uintptr
	tcl_DictObjPutKeyList                  uintptr
	tcl_DictObjRemoveKeyList               uintptr
	tcl_NewDictObj                         uintptr
	tcl_DbNewDictObj                       uintptr
	tcl_RegisterConfig                     uintptr
	tcl_CreateNamespace                    uintptr
	tcl_DeleteNamespace                    uintptr
	tcl_AppendExportList                   uintptr
	tcl_Export                             uintptr
	tcl_Import                             uintptr
	tcl_ForgetImport                       uintptr
	tcl_GetCurrentNamespace                uintptr
	tcl_GetGlobalNamespace                 uintptr
	tcl_FindNamespace                      uintptr
	tcl_FindCommand                        uintptr
	tcl_GetCommandFromObj                  uintptr
	tcl_GetCommandFullName                 uintptr
	tcl_FSEvalFileEx                       uintptr
	tcl_SetExitProc                        uintptr
	tcl_LimitAddHandler                    uintptr
	tcl_LimitRemoveHandler                 uintptr
	tcl_LimitReady                         uintptr
	tcl_LimitCheck                         uintptr
	tcl_LimitExceeded                      uintptr
	tcl_LimitSetCommands                   uintptr
	tcl_LimitSetTime                       uintptr
	tcl_LimitSetGranularity                uintptr
	tcl_LimitTypeEnabled                   uintptr
	tcl_LimitTypeExceeded                  uintptr
	tcl_LimitTypeSet                       uintptr
	tcl_LimitTypeReset                     uintptr
	tcl_LimitGetCommands                   uintptr
	tcl_LimitGetTime                       uintptr
	tcl_LimitGetGranularity                uintptr
	tcl_SaveInterpState                    uintptr
	tcl_RestoreInterpState                 uintptr
	tcl_DiscardInterpState                 uintptr
	tcl_SetReturnOptions                   uintptr
	tcl_GetReturnOptions                   uintptr
	tcl_IsEnsemble                         uintptr
	tcl_CreateEnsemble                     uintptr
	tcl_FindEnsemble                       uintptr
	tcl_SetEnsembleSubcommandList          uintptr
	tcl_SetEnsembleMappingDict             uintptr
	tcl_SetEnsembleUnknownHandler          uintptr
	tcl_SetEnsembleFlags                   uintptr
	tcl_GetEnsembleSubcommandList          uintptr
	tcl_GetEnsembleMappingDict             uintptr
	tcl_GetEnsembleUnknownHandler          uintptr
	tcl_GetEnsembleFlags                   uintptr
	tcl_GetEnsembleNamespace               uintptr
	tcl_SetTimeProc                        uintptr
	tcl_QueryTimeProc                      uintptr
	tcl_ChannelThreadActionProc            uintptr
	tcl_NewBignumObj                       uintptr
	tcl_DbNewBignumObj                     uintptr
	tcl_SetBignumObj                       uintptr
	tcl_GetBignumFromObj                   uintptr
	tcl_TakeBignumFromObj                  uintptr
	tcl_TruncateChannel                    uintptr
	tcl_ChannelTruncateProc                uintptr
	tcl_SetChannelErrorInterp              uintptr
	tcl_GetChannelErrorInterp              uintptr
	tcl_SetChannelError                    uintptr
	tcl_GetChannelError                    uintptr
	tcl_InitBignumFromDouble               uintptr
	tcl_GetNamespaceUnknownHandler         uintptr
	tcl_SetNamespaceUnknownHandler         uintptr
	tcl_GetEncodingFromObj                 uintptr
	tcl_GetEncodingSearchPath              uintptr
	tcl_SetEncodingSearchPath              uintptr
	tcl_GetEncodingNameFromEnvironment     uintptr
	tcl_PkgRequireProc                     uintptr
	tcl_AppendObjToErrorInfo               uintptr
	tcl_AppendLimitedToObj                 uintptr
	tcl_Format                             uintptr
	tcl_AppendFormatToObj                  uintptr
	tcl_ObjPrintf                          uintptr
	tcl_AppendPrintfToObj                  uintptr
	tcl_CancelEval                         uintptr
	tcl_Canceled                           uintptr
	tcl_CreatePipe                         uintptr
	tcl_NRCreateCommand                    uintptr
	tcl_NREvalObj                          uintptr
	tcl_NREvalObjv                         uintptr
	tcl_NRCmdSwap                          uintptr
	tcl_NRAddCallback                      uintptr
	tcl_NRCallObjProc                      uintptr
	tcl_GetFSDeviceFromStat                uintptr
	tcl_GetFSInodeFromStat                 uintptr
	tcl_GetModeFromStat                    uintptr
	tcl_GetLinkCountFromStat               uintptr
	tcl_GetUserIdFromStat                  uintptr
	tcl_GetGroupIdFromStat                 uintptr
	tcl_GetDeviceTypeFromStat              uintptr
	tcl_GetAccessTimeFromStat              uintptr
	tcl_GetModificationTimeFromStat        uintptr
	tcl_GetChangeTimeFromStat              uintptr
	tcl_GetSizeFromStat                    uintptr
	tcl_GetBlocksFromStat                  uintptr
	tcl_GetBlockSizeFromStat               uintptr
	tcl_SetEnsembleParameterList           uintptr
	tcl_GetEnsembleParameterList           uintptr
	tcl_ParseArgsObjv                      uintptr
	tcl_GetErrorLine                       uintptr
	tcl_SetErrorLine                       uintptr
	tcl_TransferResult                     uintptr
	tcl_InterpActive                       uintptr
	tcl_BackgroundException                uintptr
	tcl_ZlibDeflate                        uintptr
	tcl_ZlibInflate                        uintptr
	tcl_ZlibCRC32                          uintptr
	tcl_ZlibAdler32                        uintptr
	tcl_ZlibStreamInit                     uintptr
	tcl_ZlibStreamGetCommandName           uintptr
	tcl_ZlibStreamEof                      uintptr
	tcl_ZlibStreamChecksum                 uintptr
	tcl_ZlibStreamPut                      uintptr
	tcl_ZlibStreamGet                      uintptr
	tcl_ZlibStreamClose                    uintptr
	tcl_ZlibStreamReset                    uintptr
	tcl_SetStartupScript                   uintptr
	tcl_GetStartupScript                   uintptr
	tcl_CloseEx                            uintptr
	tcl_NRExprObj                          uintptr
	tcl_NRSubstObj                         uintptr
	tcl_LoadFile                           uintptr
	tcl_FindSymbol                         uintptr
	tcl_FSUnloadFile                       uintptr
	tcl_ZlibStreamSetCompressionDictionary uintptr
	reserved631                            uintptr
	reserved632                            uintptr
	reserved633                            uintptr
	reserved634                            uintptr
	reserved635                            uintptr
	reserved636                            uintptr
	reserved637                            uintptr
	reserved638                            uintptr
	reserved639                            uintptr
	reserved640                            uintptr
	reserved641                            uintptr
	reserved642                            uintptr
	reserved643                            uintptr
	reserved644                            uintptr
	reserved645                            uintptr
	reserved646                            uintptr
	reserved647                            uintptr
	tclUnusedStubEntry                     uintptr
}

type TclStubs = TclStubs1 /* tclDecls.h:2522:3 */

// !END!: Do not edit above this line.

// Deprecated Tcl procedures:

// Include platform specific public function declarations that are accessible
// via the stubs table. Make all TclOO symbols MODULE_SCOPE (which only
// has effect on building it as a shared library). See ticket [3010352].

// tclPlatDecls.h --
//
//	Declarations of platform specific Tcl APIs.
//
// Copyright (c) 1998-1999 by Scriptics Corporation.
// All rights reserved.

// WARNING: This file is automatically generated by the tools/genStubs.tcl
// script.  Any modifications to the function declarations below should be made
// in the generic/tcl.decls script.

// TCHAR is needed here for win32, so if it is not defined yet do it here.
// This way, we don't need to include <tchar.h> just for one define.

// !BEGIN!: Do not edit below this line.

// Exported function declarations:

type TclPlatStubs = TclPlatStubs1 /* tclPlatDecls.h:86:3 */

// The following #if block allows you to change how Tcl finds the startup
// script, prime the library or encoding paths, fiddle with the argv, etc.,
// without needing to rewrite Tcl_Main()

//----------------------------------------------------------------------
//
// main --
//
//	This is the main program for the application.
//
// Results:
//	None: Tcl_Main never returns here, so this procedure never returns
//	either.
//
// Side effects:
//	Just about anything, since from here we call arbitrary Tcl code.
//
//----------------------------------------------------------------------

func main1(tls *crt.TLS, argc int32, argv uintptr) int32 { /* tclAppInit.c:72:1: */

	tcl.XTcl_MainEx(tls, argc, argv, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) int32 }{Tcl_AppInit})), tcl.XTcl_CreateInterp(tls))
	return 0 // Needed only to prevent compiler warning.
}

//----------------------------------------------------------------------
//
// Tcl_AppInit --
//
//	This procedure performs application-specific initialization. Most
//	applications, especially those that incorporate additional packages,
//	will have their own version of this procedure.
//
// Results:
//	Returns a standard Tcl completion code, and leaves an error message in
//	the interp's result if an error occurs.
//
// Side effects:
//	Depends on the startup script.
//
//----------------------------------------------------------------------

func Tcl_AppInit(tls *crt.TLS, interp uintptr) int32 { /* tclAppInit.c:108:1: */
	if tcl.XTcl_Init(tls, interp) == 1 {
		return 1
	}

	// Call the init procedures for included packages. Each call should look
	// like this:
	//
	// if (Mod_Init(interp) == TCL_ERROR) {
	//     return TCL_ERROR;
	// }
	//
	// where "Mod" is the name of the module. (Dynamically-loadable packages
	// should have the same entry-point name.)

	// Call Tcl_CreateCommand for application-specific commands, if they
	// weren't already created by the init procedures called above.

	// Specify a user-specific startup file to invoke if the application is
	// run interactively. Typically the startup file is "~/.apprc" where "app"
	// is the name of the application. If this line is deleted then no
	// user-specific startup file will be run under any conditions.

	tcl.XTcl_ObjSetVar2(tls, interp, tcl.XTcl_DbNewStringObj(tls, ts /* "tcl_rcFileName" */, -1, ts+15 /* "tclAppInit.c" */, 156), uintptr(0),
		tcl.XTcl_DbNewStringObj(tls, ts+28 /* "~/.tclshrc" */, -1, ts+15 /* "tclAppInit.c" */, 157), 1)

	return 0
}

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

var ts1 = "tcl_rcFileName\x00tclAppInit.c\x00~/.tclshrc\x00"
var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data

func init() {
	var v0 struct {
		__count int32
		__value struct{ __wch uint32 }
	}
	if g, e := unsafe.Sizeof(v0), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v0), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v0.__count), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v0.__count), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v0.__count), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v0.__value), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v0.__value), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v0.__value), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v1 struct {
		__pos   int64
		__state struct {
			__count int32
			__value struct{ __wch uint32 }
		}
	}
	if g, e := unsafe.Sizeof(v1), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v1), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v1.__pos), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v1.__pos), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v1.__pos), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v1.__state), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v1.__state), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v1.__state), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v2 struct {
		__type      Tcl_ValueType
		intValue    int64
		doubleValue float64
		wideValue   Tcl_WideInt
	}
	if g, e := unsafe.Sizeof(v2), uintptr(32); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v2), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v2.__type), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v2.__type), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v2.__type), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v2.intValue), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v2.intValue), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v2.intValue), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v2.doubleValue), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v2.doubleValue), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v2.doubleValue), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v2.wideValue), uintptr(24); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v2.wideValue), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v2.wideValue), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v3 struct {
		__type     int32
		keyStr     uintptr
		srcPtr     uintptr
		dstPtr     uintptr
		helpStr    uintptr
		clientData ClientData
	}
	if g, e := unsafe.Sizeof(v3), uintptr(48); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v3), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v3.__type), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v3.__type), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v3.__type), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v3.keyStr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v3.keyStr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v3.keyStr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v3.srcPtr), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v3.srcPtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v3.srcPtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v3.dstPtr), uintptr(24); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v3.dstPtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v3.dstPtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v3.helpStr), uintptr(32); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v3.helpStr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v3.helpStr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v3.clientData), uintptr(40); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v3.clientData), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v3.clientData), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v4 struct {
		__type     int32
		perm       int32
		macType    uintptr
		macCreator uintptr
	}
	if g, e := unsafe.Sizeof(v4), uintptr(24); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v4), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v4.__type), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v4.__type), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v4.__type), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v4.perm), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v4.perm), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v4.perm), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v4.macType), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v4.macType), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v4.macType), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v4.macCreator), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v4.macCreator), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v4.macCreator), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v5 struct {
		__type        int32
		start         uintptr
		size          int32
		numComponents int32
	}
	if g, e := unsafe.Sizeof(v5), uintptr(24); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v5), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v5.__type), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v5.__type), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v5.__type), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v5.start), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v5.start), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v5.start), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v5.size), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v5.size), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v5.size), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v5.numComponents), uintptr(20); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v5.numComponents), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v5.numComponents), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v6 struct{ __wch uint32 }
	if g, e := unsafe.Sizeof(v6), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v6), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v6.__wch), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v6.__wch), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v6.__wch), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v7 struct {
		_flags          int32
		_IO_read_ptr    uintptr
		_IO_read_end    uintptr
		_IO_read_base   uintptr
		_IO_write_base  uintptr
		_IO_write_ptr   uintptr
		_IO_write_end   uintptr
		_IO_buf_base    uintptr
		_IO_buf_end     uintptr
		_IO_save_base   uintptr
		_IO_backup_base uintptr
		_IO_save_end    uintptr
		_markers        uintptr
		_chain          uintptr
		_fileno         int32
		_flags2         int32
		_old_offset     int64
		_cur_column     uint16
		_vtable_offset  int8
		_shortbuf       [1]int8
		_lock           uintptr
		_offset         int64
		_codecvt        uintptr
		_wide_data      uintptr
		_freeres_list   uintptr
		_freeres_buf    uintptr
		__pad5          size_t
		_mode           int32
		_unused2        [20]int8
	}
	if g, e := unsafe.Sizeof(v7), uintptr(216); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7._flags), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7._flags), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7._flags), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7._IO_read_ptr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7._IO_read_ptr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7._IO_read_ptr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7._IO_read_end), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7._IO_read_end), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7._IO_read_end), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7._IO_read_base), uintptr(24); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7._IO_read_base), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7._IO_read_base), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7._IO_write_base), uintptr(32); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7._IO_write_base), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7._IO_write_base), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7._IO_write_ptr), uintptr(40); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7._IO_write_ptr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7._IO_write_ptr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7._IO_write_end), uintptr(48); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7._IO_write_end), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7._IO_write_end), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7._IO_buf_base), uintptr(56); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7._IO_buf_base), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7._IO_buf_base), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7._IO_buf_end), uintptr(64); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7._IO_buf_end), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7._IO_buf_end), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7._IO_save_base), uintptr(72); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7._IO_save_base), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7._IO_save_base), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7._IO_backup_base), uintptr(80); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7._IO_backup_base), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7._IO_backup_base), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7._IO_save_end), uintptr(88); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7._IO_save_end), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7._IO_save_end), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7._markers), uintptr(96); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7._markers), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7._markers), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7._chain), uintptr(104); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7._chain), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7._chain), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7._fileno), uintptr(112); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7._fileno), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7._fileno), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7._flags2), uintptr(116); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7._flags2), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7._flags2), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7._old_offset), uintptr(120); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7._old_offset), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7._old_offset), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7._cur_column), uintptr(128); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7._cur_column), uintptr(2); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7._cur_column), uintptr(2); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7._vtable_offset), uintptr(130); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7._vtable_offset), uintptr(1); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7._vtable_offset), uintptr(1); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7._shortbuf), uintptr(131); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7._shortbuf), uintptr(1); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7._shortbuf), uintptr(1); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7._lock), uintptr(136); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7._lock), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7._lock), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7._offset), uintptr(144); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7._offset), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7._offset), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7._codecvt), uintptr(152); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7._codecvt), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7._codecvt), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7._wide_data), uintptr(160); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7._wide_data), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7._wide_data), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7._freeres_list), uintptr(168); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7._freeres_list), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7._freeres_list), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7._freeres_buf), uintptr(176); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7._freeres_buf), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7._freeres_buf), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7.__pad5), uintptr(184); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7.__pad5), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7.__pad5), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7._mode), uintptr(192); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7._mode), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7._mode), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v7._unused2), uintptr(196); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v7._unused2), uintptr(20); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v7._unused2), uintptr(1); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v8 struct {
		buckets       uintptr
		staticBuckets [4]uintptr
		numBuckets    int32
		numEntries    int32
		rebuildSize   int32
		downShift     int32
		mask          int32
		keyType       int32
		findProc      uintptr
		createProc    uintptr
		typePtr       uintptr
	}
	if g, e := unsafe.Sizeof(v8), uintptr(88); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v8), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v8.buckets), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v8.buckets), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v8.buckets), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v8.staticBuckets), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v8.staticBuckets), uintptr(32); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v8.staticBuckets), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v8.numBuckets), uintptr(40); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v8.numBuckets), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v8.numBuckets), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v8.numEntries), uintptr(44); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v8.numEntries), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v8.numEntries), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v8.rebuildSize), uintptr(48); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v8.rebuildSize), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v8.rebuildSize), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v8.downShift), uintptr(52); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v8.downShift), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v8.downShift), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v8.mask), uintptr(56); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v8.mask), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v8.mask), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v8.keyType), uintptr(60); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v8.keyType), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v8.keyType), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v8.findProc), uintptr(64); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v8.findProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v8.findProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v8.createProc), uintptr(72); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v8.createProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v8.createProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v8.typePtr), uintptr(80); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v8.typePtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v8.typePtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v9 struct {
		commentStart    uintptr
		commentSize     int32
		commandStart    uintptr
		commandSize     int32
		numWords        int32
		tokenPtr        uintptr
		numTokens       int32
		tokensAvailable int32
		errorType       int32
		string          uintptr
		end             uintptr
		interp          uintptr
		term            uintptr
		incomplete      int32
		staticTokens    [20]Tcl_Token
	}
	if g, e := unsafe.Sizeof(v9), uintptr(576); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v9), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v9.commentStart), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v9.commentStart), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v9.commentStart), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v9.commentSize), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v9.commentSize), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v9.commentSize), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v9.commandStart), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v9.commandStart), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v9.commandStart), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v9.commandSize), uintptr(24); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v9.commandSize), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v9.commandSize), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v9.numWords), uintptr(28); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v9.numWords), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v9.numWords), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v9.tokenPtr), uintptr(32); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v9.tokenPtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v9.tokenPtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v9.numTokens), uintptr(40); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v9.numTokens), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v9.numTokens), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v9.tokensAvailable), uintptr(44); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v9.tokensAvailable), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v9.tokensAvailable), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v9.errorType), uintptr(48); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v9.errorType), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v9.errorType), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v9.string), uintptr(56); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v9.string), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v9.string), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v9.end), uintptr(64); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v9.end), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v9.end), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v9.interp), uintptr(72); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v9.interp), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v9.interp), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v9.term), uintptr(80); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v9.term), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v9.term), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v9.incomplete), uintptr(88); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v9.incomplete), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v9.incomplete), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v9.staticTokens), uintptr(96); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v9.staticTokens), uintptr(480); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v9.staticTokens), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v10 struct {
		encodingName uintptr
		toUtfProc    uintptr
		fromUtfProc  uintptr
		freeProc     uintptr
		clientData   ClientData
		nullSize     int32
		_            [4]byte
	}
	if g, e := unsafe.Sizeof(v10), uintptr(48); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v10), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v10.encodingName), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v10.encodingName), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v10.encodingName), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v10.toUtfProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v10.toUtfProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v10.toUtfProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v10.fromUtfProc), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v10.fromUtfProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v10.fromUtfProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v10.freeProc), uintptr(24); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v10.freeProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v10.freeProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v10.clientData), uintptr(32); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v10.clientData), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v10.clientData), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v10.nullSize), uintptr(40); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v10.nullSize), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v10.nullSize), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v11 struct {
		isNativeObjectProc int32
		objProc            uintptr
		objClientData      ClientData
		proc               uintptr
		clientData         ClientData
		deleteProc         uintptr
		deleteData         ClientData
		namespacePtr       uintptr
	}
	if g, e := unsafe.Sizeof(v11), uintptr(64); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v11), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v11.isNativeObjectProc), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v11.isNativeObjectProc), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v11.isNativeObjectProc), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v11.objProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v11.objProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v11.objProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v11.objClientData), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v11.objClientData), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v11.objClientData), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v11.proc), uintptr(24); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v11.proc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v11.proc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v11.clientData), uintptr(32); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v11.clientData), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v11.clientData), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v11.deleteProc), uintptr(40); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v11.deleteProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v11.deleteProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v11.deleteData), uintptr(48); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v11.deleteData), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v11.deleteData), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v11.namespacePtr), uintptr(56); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v11.namespacePtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v11.namespacePtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v12 struct {
		key   uintptr
		value uintptr
	}
	if g, e := unsafe.Sizeof(v12), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v12), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v12.key), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v12.key), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v12.key), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v12.value), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v12.value), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v12.value), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v13 struct {
		longValue int64
		_         [8]byte
	}
	if g, e := unsafe.Sizeof(v13), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v13), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v13.longValue), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v13.longValue), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v13.longValue), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v14 struct {
		magic                                  int32
		hooks                                  uintptr
		tcl_PkgProvideEx                       uintptr
		tcl_PkgRequireEx                       uintptr
		tcl_Panic                              uintptr
		tcl_Alloc                              uintptr
		tcl_Free                               uintptr
		tcl_Realloc                            uintptr
		tcl_DbCkalloc                          uintptr
		tcl_DbCkfree                           uintptr
		tcl_DbCkrealloc                        uintptr
		tcl_CreateFileHandler                  uintptr
		tcl_DeleteFileHandler                  uintptr
		tcl_SetTimer                           uintptr
		tcl_Sleep                              uintptr
		tcl_WaitForEvent                       uintptr
		tcl_AppendAllObjTypes                  uintptr
		tcl_AppendStringsToObj                 uintptr
		tcl_AppendToObj                        uintptr
		tcl_ConcatObj                          uintptr
		tcl_ConvertToType                      uintptr
		tcl_DbDecrRefCount                     uintptr
		tcl_DbIncrRefCount                     uintptr
		tcl_DbIsShared                         uintptr
		tcl_DbNewBooleanObj                    uintptr
		tcl_DbNewByteArrayObj                  uintptr
		tcl_DbNewDoubleObj                     uintptr
		tcl_DbNewListObj                       uintptr
		tcl_DbNewLongObj                       uintptr
		tcl_DbNewObj                           uintptr
		tcl_DbNewStringObj                     uintptr
		tcl_DuplicateObj                       uintptr
		tclFreeObj                             uintptr
		tcl_GetBoolean                         uintptr
		tcl_GetBooleanFromObj                  uintptr
		tcl_GetByteArrayFromObj                uintptr
		tcl_GetDouble                          uintptr
		tcl_GetDoubleFromObj                   uintptr
		tcl_GetIndexFromObj                    uintptr
		tcl_GetInt                             uintptr
		tcl_GetIntFromObj                      uintptr
		tcl_GetLongFromObj                     uintptr
		tcl_GetObjType                         uintptr
		tcl_GetStringFromObj                   uintptr
		tcl_InvalidateStringRep                uintptr
		tcl_ListObjAppendList                  uintptr
		tcl_ListObjAppendElement               uintptr
		tcl_ListObjGetElements                 uintptr
		tcl_ListObjIndex                       uintptr
		tcl_ListObjLength                      uintptr
		tcl_ListObjReplace                     uintptr
		tcl_NewBooleanObj                      uintptr
		tcl_NewByteArrayObj                    uintptr
		tcl_NewDoubleObj                       uintptr
		tcl_NewIntObj                          uintptr
		tcl_NewListObj                         uintptr
		tcl_NewLongObj                         uintptr
		tcl_NewObj                             uintptr
		tcl_NewStringObj                       uintptr
		tcl_SetBooleanObj                      uintptr
		tcl_SetByteArrayLength                 uintptr
		tcl_SetByteArrayObj                    uintptr
		tcl_SetDoubleObj                       uintptr
		tcl_SetIntObj                          uintptr
		tcl_SetListObj                         uintptr
		tcl_SetLongObj                         uintptr
		tcl_SetObjLength                       uintptr
		tcl_SetStringObj                       uintptr
		tcl_AddErrorInfo                       uintptr
		tcl_AddObjErrorInfo                    uintptr
		tcl_AllowExceptions                    uintptr
		tcl_AppendElement                      uintptr
		tcl_AppendResult                       uintptr
		tcl_AsyncCreate                        uintptr
		tcl_AsyncDelete                        uintptr
		tcl_AsyncInvoke                        uintptr
		tcl_AsyncMark                          uintptr
		tcl_AsyncReady                         uintptr
		tcl_BackgroundError                    uintptr
		tcl_Backslash                          uintptr
		tcl_BadChannelOption                   uintptr
		tcl_CallWhenDeleted                    uintptr
		tcl_CancelIdleCall                     uintptr
		tcl_Close                              uintptr
		tcl_CommandComplete                    uintptr
		tcl_Concat                             uintptr
		tcl_ConvertElement                     uintptr
		tcl_ConvertCountedElement              uintptr
		tcl_CreateAlias                        uintptr
		tcl_CreateAliasObj                     uintptr
		tcl_CreateChannel                      uintptr
		tcl_CreateChannelHandler               uintptr
		tcl_CreateCloseHandler                 uintptr
		tcl_CreateCommand                      uintptr
		tcl_CreateEventSource                  uintptr
		tcl_CreateExitHandler                  uintptr
		tcl_CreateInterp                       uintptr
		tcl_CreateMathFunc                     uintptr
		tcl_CreateObjCommand                   uintptr
		tcl_CreateSlave                        uintptr
		tcl_CreateTimerHandler                 uintptr
		tcl_CreateTrace                        uintptr
		tcl_DeleteAssocData                    uintptr
		tcl_DeleteChannelHandler               uintptr
		tcl_DeleteCloseHandler                 uintptr
		tcl_DeleteCommand                      uintptr
		tcl_DeleteCommandFromToken             uintptr
		tcl_DeleteEvents                       uintptr
		tcl_DeleteEventSource                  uintptr
		tcl_DeleteExitHandler                  uintptr
		tcl_DeleteHashEntry                    uintptr
		tcl_DeleteHashTable                    uintptr
		tcl_DeleteInterp                       uintptr
		tcl_DetachPids                         uintptr
		tcl_DeleteTimerHandler                 uintptr
		tcl_DeleteTrace                        uintptr
		tcl_DontCallWhenDeleted                uintptr
		tcl_DoOneEvent                         uintptr
		tcl_DoWhenIdle                         uintptr
		tcl_DStringAppend                      uintptr
		tcl_DStringAppendElement               uintptr
		tcl_DStringEndSublist                  uintptr
		tcl_DStringFree                        uintptr
		tcl_DStringGetResult                   uintptr
		tcl_DStringInit                        uintptr
		tcl_DStringResult                      uintptr
		tcl_DStringSetLength                   uintptr
		tcl_DStringStartSublist                uintptr
		tcl_Eof                                uintptr
		tcl_ErrnoId                            uintptr
		tcl_ErrnoMsg                           uintptr
		tcl_Eval                               uintptr
		tcl_EvalFile                           uintptr
		tcl_EvalObj                            uintptr
		tcl_EventuallyFree                     uintptr
		tcl_Exit                               uintptr
		tcl_ExposeCommand                      uintptr
		tcl_ExprBoolean                        uintptr
		tcl_ExprBooleanObj                     uintptr
		tcl_ExprDouble                         uintptr
		tcl_ExprDoubleObj                      uintptr
		tcl_ExprLong                           uintptr
		tcl_ExprLongObj                        uintptr
		tcl_ExprObj                            uintptr
		tcl_ExprString                         uintptr
		tcl_Finalize                           uintptr
		tcl_FindExecutable                     uintptr
		tcl_FirstHashEntry                     uintptr
		tcl_Flush                              uintptr
		tcl_FreeResult                         uintptr
		tcl_GetAlias                           uintptr
		tcl_GetAliasObj                        uintptr
		tcl_GetAssocData                       uintptr
		tcl_GetChannel                         uintptr
		tcl_GetChannelBufferSize               uintptr
		tcl_GetChannelHandle                   uintptr
		tcl_GetChannelInstanceData             uintptr
		tcl_GetChannelMode                     uintptr
		tcl_GetChannelName                     uintptr
		tcl_GetChannelOption                   uintptr
		tcl_GetChannelType                     uintptr
		tcl_GetCommandInfo                     uintptr
		tcl_GetCommandName                     uintptr
		tcl_GetErrno                           uintptr
		tcl_GetHostName                        uintptr
		tcl_GetInterpPath                      uintptr
		tcl_GetMaster                          uintptr
		tcl_GetNameOfExecutable                uintptr
		tcl_GetObjResult                       uintptr
		tcl_GetOpenFile                        uintptr
		tcl_GetPathType                        uintptr
		tcl_Gets                               uintptr
		tcl_GetsObj                            uintptr
		tcl_GetServiceMode                     uintptr
		tcl_GetSlave                           uintptr
		tcl_GetStdChannel                      uintptr
		tcl_GetStringResult                    uintptr
		tcl_GetVar                             uintptr
		tcl_GetVar2                            uintptr
		tcl_GlobalEval                         uintptr
		tcl_GlobalEvalObj                      uintptr
		tcl_HideCommand                        uintptr
		tcl_Init                               uintptr
		tcl_InitHashTable                      uintptr
		tcl_InputBlocked                       uintptr
		tcl_InputBuffered                      uintptr
		tcl_InterpDeleted                      uintptr
		tcl_IsSafe                             uintptr
		tcl_JoinPath                           uintptr
		tcl_LinkVar                            uintptr
		reserved188                            uintptr
		tcl_MakeFileChannel                    uintptr
		tcl_MakeSafe                           uintptr
		tcl_MakeTcpClientChannel               uintptr
		tcl_Merge                              uintptr
		tcl_NextHashEntry                      uintptr
		tcl_NotifyChannel                      uintptr
		tcl_ObjGetVar2                         uintptr
		tcl_ObjSetVar2                         uintptr
		tcl_OpenCommandChannel                 uintptr
		tcl_OpenFileChannel                    uintptr
		tcl_OpenTcpClient                      uintptr
		tcl_OpenTcpServer                      uintptr
		tcl_Preserve                           uintptr
		tcl_PrintDouble                        uintptr
		tcl_PutEnv                             uintptr
		tcl_PosixError                         uintptr
		tcl_QueueEvent                         uintptr
		tcl_Read                               uintptr
		tcl_ReapDetachedProcs                  uintptr
		tcl_RecordAndEval                      uintptr
		tcl_RecordAndEvalObj                   uintptr
		tcl_RegisterChannel                    uintptr
		tcl_RegisterObjType                    uintptr
		tcl_RegExpCompile                      uintptr
		tcl_RegExpExec                         uintptr
		tcl_RegExpMatch                        uintptr
		tcl_RegExpRange                        uintptr
		tcl_Release                            uintptr
		tcl_ResetResult                        uintptr
		tcl_ScanElement                        uintptr
		tcl_ScanCountedElement                 uintptr
		tcl_SeekOld                            uintptr
		tcl_ServiceAll                         uintptr
		tcl_ServiceEvent                       uintptr
		tcl_SetAssocData                       uintptr
		tcl_SetChannelBufferSize               uintptr
		tcl_SetChannelOption                   uintptr
		tcl_SetCommandInfo                     uintptr
		tcl_SetErrno                           uintptr
		tcl_SetErrorCode                       uintptr
		tcl_SetMaxBlockTime                    uintptr
		tcl_SetPanicProc                       uintptr
		tcl_SetRecursionLimit                  uintptr
		tcl_SetResult                          uintptr
		tcl_SetServiceMode                     uintptr
		tcl_SetObjErrorCode                    uintptr
		tcl_SetObjResult                       uintptr
		tcl_SetStdChannel                      uintptr
		tcl_SetVar                             uintptr
		tcl_SetVar2                            uintptr
		tcl_SignalId                           uintptr
		tcl_SignalMsg                          uintptr
		tcl_SourceRCFile                       uintptr
		tcl_SplitList                          uintptr
		tcl_SplitPath                          uintptr
		tcl_StaticPackage                      uintptr
		tcl_StringMatch                        uintptr
		tcl_TellOld                            uintptr
		tcl_TraceVar                           uintptr
		tcl_TraceVar2                          uintptr
		tcl_TranslateFileName                  uintptr
		tcl_Ungets                             uintptr
		tcl_UnlinkVar                          uintptr
		tcl_UnregisterChannel                  uintptr
		tcl_UnsetVar                           uintptr
		tcl_UnsetVar2                          uintptr
		tcl_UntraceVar                         uintptr
		tcl_UntraceVar2                        uintptr
		tcl_UpdateLinkedVar                    uintptr
		tcl_UpVar                              uintptr
		tcl_UpVar2                             uintptr
		tcl_VarEval                            uintptr
		tcl_VarTraceInfo                       uintptr
		tcl_VarTraceInfo2                      uintptr
		tcl_Write                              uintptr
		tcl_WrongNumArgs                       uintptr
		tcl_DumpActiveMemory                   uintptr
		tcl_ValidateAllMemory                  uintptr
		tcl_AppendResultVA                     uintptr
		tcl_AppendStringsToObjVA               uintptr
		tcl_HashStats                          uintptr
		tcl_ParseVar                           uintptr
		tcl_PkgPresent                         uintptr
		tcl_PkgPresentEx                       uintptr
		tcl_PkgProvide                         uintptr
		tcl_PkgRequire                         uintptr
		tcl_SetErrorCodeVA                     uintptr
		tcl_VarEvalVA                          uintptr
		tcl_WaitPid                            uintptr
		tcl_PanicVA                            uintptr
		tcl_GetVersion                         uintptr
		tcl_InitMemory                         uintptr
		tcl_StackChannel                       uintptr
		tcl_UnstackChannel                     uintptr
		tcl_GetStackedChannel                  uintptr
		tcl_SetMainLoop                        uintptr
		reserved285                            uintptr
		tcl_AppendObjToObj                     uintptr
		tcl_CreateEncoding                     uintptr
		tcl_CreateThreadExitHandler            uintptr
		tcl_DeleteThreadExitHandler            uintptr
		tcl_DiscardResult                      uintptr
		tcl_EvalEx                             uintptr
		tcl_EvalObjv                           uintptr
		tcl_EvalObjEx                          uintptr
		tcl_ExitThread                         uintptr
		tcl_ExternalToUtf                      uintptr
		tcl_ExternalToUtfDString               uintptr
		tcl_FinalizeThread                     uintptr
		tcl_FinalizeNotifier                   uintptr
		tcl_FreeEncoding                       uintptr
		tcl_GetCurrentThread                   uintptr
		tcl_GetEncoding                        uintptr
		tcl_GetEncodingName                    uintptr
		tcl_GetEncodingNames                   uintptr
		tcl_GetIndexFromObjStruct              uintptr
		tcl_GetThreadData                      uintptr
		tcl_GetVar2Ex                          uintptr
		tcl_InitNotifier                       uintptr
		tcl_MutexLock                          uintptr
		tcl_MutexUnlock                        uintptr
		tcl_ConditionNotify                    uintptr
		tcl_ConditionWait                      uintptr
		tcl_NumUtfChars                        uintptr
		tcl_ReadChars                          uintptr
		tcl_RestoreResult                      uintptr
		tcl_SaveResult                         uintptr
		tcl_SetSystemEncoding                  uintptr
		tcl_SetVar2Ex                          uintptr
		tcl_ThreadAlert                        uintptr
		tcl_ThreadQueueEvent                   uintptr
		tcl_UniCharAtIndex                     uintptr
		tcl_UniCharToLower                     uintptr
		tcl_UniCharToTitle                     uintptr
		tcl_UniCharToUpper                     uintptr
		tcl_UniCharToUtf                       uintptr
		tcl_UtfAtIndex                         uintptr
		tcl_UtfCharComplete                    uintptr
		tcl_UtfBackslash                       uintptr
		tcl_UtfFindFirst                       uintptr
		tcl_UtfFindLast                        uintptr
		tcl_UtfNext                            uintptr
		tcl_UtfPrev                            uintptr
		tcl_UtfToExternal                      uintptr
		tcl_UtfToExternalDString               uintptr
		tcl_UtfToLower                         uintptr
		tcl_UtfToTitle                         uintptr
		tcl_UtfToUniChar                       uintptr
		tcl_UtfToUpper                         uintptr
		tcl_WriteChars                         uintptr
		tcl_WriteObj                           uintptr
		tcl_GetString                          uintptr
		tcl_GetDefaultEncodingDir              uintptr
		tcl_SetDefaultEncodingDir              uintptr
		tcl_AlertNotifier                      uintptr
		tcl_ServiceModeHook                    uintptr
		tcl_UniCharIsAlnum                     uintptr
		tcl_UniCharIsAlpha                     uintptr
		tcl_UniCharIsDigit                     uintptr
		tcl_UniCharIsLower                     uintptr
		tcl_UniCharIsSpace                     uintptr
		tcl_UniCharIsUpper                     uintptr
		tcl_UniCharIsWordChar                  uintptr
		tcl_UniCharLen                         uintptr
		tcl_UniCharNcmp                        uintptr
		tcl_UniCharToUtfDString                uintptr
		tcl_UtfToUniCharDString                uintptr
		tcl_GetRegExpFromObj                   uintptr
		tcl_EvalTokens                         uintptr
		tcl_FreeParse                          uintptr
		tcl_LogCommandInfo                     uintptr
		tcl_ParseBraces                        uintptr
		tcl_ParseCommand                       uintptr
		tcl_ParseExpr                          uintptr
		tcl_ParseQuotedString                  uintptr
		tcl_ParseVarName                       uintptr
		tcl_GetCwd                             uintptr
		tcl_Chdir                              uintptr
		tcl_Access                             uintptr
		tcl_Stat                               uintptr
		tcl_UtfNcmp                            uintptr
		tcl_UtfNcasecmp                        uintptr
		tcl_StringCaseMatch                    uintptr
		tcl_UniCharIsControl                   uintptr
		tcl_UniCharIsGraph                     uintptr
		tcl_UniCharIsPrint                     uintptr
		tcl_UniCharIsPunct                     uintptr
		tcl_RegExpExecObj                      uintptr
		tcl_RegExpGetInfo                      uintptr
		tcl_NewUnicodeObj                      uintptr
		tcl_SetUnicodeObj                      uintptr
		tcl_GetCharLength                      uintptr
		tcl_GetUniChar                         uintptr
		tcl_GetUnicode                         uintptr
		tcl_GetRange                           uintptr
		tcl_AppendUnicodeToObj                 uintptr
		tcl_RegExpMatchObj                     uintptr
		tcl_SetNotifier                        uintptr
		tcl_GetAllocMutex                      uintptr
		tcl_GetChannelNames                    uintptr
		tcl_GetChannelNamesEx                  uintptr
		tcl_ProcObjCmd                         uintptr
		tcl_ConditionFinalize                  uintptr
		tcl_MutexFinalize                      uintptr
		tcl_CreateThread                       uintptr
		tcl_ReadRaw                            uintptr
		tcl_WriteRaw                           uintptr
		tcl_GetTopChannel                      uintptr
		tcl_ChannelBuffered                    uintptr
		tcl_ChannelName                        uintptr
		tcl_ChannelVersion                     uintptr
		tcl_ChannelBlockModeProc               uintptr
		tcl_ChannelCloseProc                   uintptr
		tcl_ChannelClose2Proc                  uintptr
		tcl_ChannelInputProc                   uintptr
		tcl_ChannelOutputProc                  uintptr
		tcl_ChannelSeekProc                    uintptr
		tcl_ChannelSetOptionProc               uintptr
		tcl_ChannelGetOptionProc               uintptr
		tcl_ChannelWatchProc                   uintptr
		tcl_ChannelGetHandleProc               uintptr
		tcl_ChannelFlushProc                   uintptr
		tcl_ChannelHandlerProc                 uintptr
		tcl_JoinThread                         uintptr
		tcl_IsChannelShared                    uintptr
		tcl_IsChannelRegistered                uintptr
		tcl_CutChannel                         uintptr
		tcl_SpliceChannel                      uintptr
		tcl_ClearChannelHandlers               uintptr
		tcl_IsChannelExisting                  uintptr
		tcl_UniCharNcasecmp                    uintptr
		tcl_UniCharCaseMatch                   uintptr
		tcl_FindHashEntry                      uintptr
		tcl_CreateHashEntry                    uintptr
		tcl_InitCustomHashTable                uintptr
		tcl_InitObjHashTable                   uintptr
		tcl_CommandTraceInfo                   uintptr
		tcl_TraceCommand                       uintptr
		tcl_UntraceCommand                     uintptr
		tcl_AttemptAlloc                       uintptr
		tcl_AttemptDbCkalloc                   uintptr
		tcl_AttemptRealloc                     uintptr
		tcl_AttemptDbCkrealloc                 uintptr
		tcl_AttemptSetObjLength                uintptr
		tcl_GetChannelThread                   uintptr
		tcl_GetUnicodeFromObj                  uintptr
		tcl_GetMathFuncInfo                    uintptr
		tcl_ListMathFuncs                      uintptr
		tcl_SubstObj                           uintptr
		tcl_DetachChannel                      uintptr
		tcl_IsStandardChannel                  uintptr
		tcl_FSCopyFile                         uintptr
		tcl_FSCopyDirectory                    uintptr
		tcl_FSCreateDirectory                  uintptr
		tcl_FSDeleteFile                       uintptr
		tcl_FSLoadFile                         uintptr
		tcl_FSMatchInDirectory                 uintptr
		tcl_FSLink                             uintptr
		tcl_FSRemoveDirectory                  uintptr
		tcl_FSRenameFile                       uintptr
		tcl_FSLstat                            uintptr
		tcl_FSUtime                            uintptr
		tcl_FSFileAttrsGet                     uintptr
		tcl_FSFileAttrsSet                     uintptr
		tcl_FSFileAttrStrings                  uintptr
		tcl_FSStat                             uintptr
		tcl_FSAccess                           uintptr
		tcl_FSOpenFileChannel                  uintptr
		tcl_FSGetCwd                           uintptr
		tcl_FSChdir                            uintptr
		tcl_FSConvertToPathType                uintptr
		tcl_FSJoinPath                         uintptr
		tcl_FSSplitPath                        uintptr
		tcl_FSEqualPaths                       uintptr
		tcl_FSGetNormalizedPath                uintptr
		tcl_FSJoinToPath                       uintptr
		tcl_FSGetInternalRep                   uintptr
		tcl_FSGetTranslatedPath                uintptr
		tcl_FSEvalFile                         uintptr
		tcl_FSNewNativePath                    uintptr
		tcl_FSGetNativePath                    uintptr
		tcl_FSFileSystemInfo                   uintptr
		tcl_FSPathSeparator                    uintptr
		tcl_FSListVolumes                      uintptr
		tcl_FSRegister                         uintptr
		tcl_FSUnregister                       uintptr
		tcl_FSData                             uintptr
		tcl_FSGetTranslatedStringPath          uintptr
		tcl_FSGetFileSystemForPath             uintptr
		tcl_FSGetPathType                      uintptr
		tcl_OutputBuffered                     uintptr
		tcl_FSMountsChanged                    uintptr
		tcl_EvalTokensStandard                 uintptr
		tcl_GetTime                            uintptr
		tcl_CreateObjTrace                     uintptr
		tcl_GetCommandInfoFromToken            uintptr
		tcl_SetCommandInfoFromToken            uintptr
		tcl_DbNewWideIntObj                    uintptr
		tcl_GetWideIntFromObj                  uintptr
		tcl_NewWideIntObj                      uintptr
		tcl_SetWideIntObj                      uintptr
		tcl_AllocStatBuf                       uintptr
		tcl_Seek                               uintptr
		tcl_Tell                               uintptr
		tcl_ChannelWideSeekProc                uintptr
		tcl_DictObjPut                         uintptr
		tcl_DictObjGet                         uintptr
		tcl_DictObjRemove                      uintptr
		tcl_DictObjSize                        uintptr
		tcl_DictObjFirst                       uintptr
		tcl_DictObjNext                        uintptr
		tcl_DictObjDone                        uintptr
		tcl_DictObjPutKeyList                  uintptr
		tcl_DictObjRemoveKeyList               uintptr
		tcl_NewDictObj                         uintptr
		tcl_DbNewDictObj                       uintptr
		tcl_RegisterConfig                     uintptr
		tcl_CreateNamespace                    uintptr
		tcl_DeleteNamespace                    uintptr
		tcl_AppendExportList                   uintptr
		tcl_Export                             uintptr
		tcl_Import                             uintptr
		tcl_ForgetImport                       uintptr
		tcl_GetCurrentNamespace                uintptr
		tcl_GetGlobalNamespace                 uintptr
		tcl_FindNamespace                      uintptr
		tcl_FindCommand                        uintptr
		tcl_GetCommandFromObj                  uintptr
		tcl_GetCommandFullName                 uintptr
		tcl_FSEvalFileEx                       uintptr
		tcl_SetExitProc                        uintptr
		tcl_LimitAddHandler                    uintptr
		tcl_LimitRemoveHandler                 uintptr
		tcl_LimitReady                         uintptr
		tcl_LimitCheck                         uintptr
		tcl_LimitExceeded                      uintptr
		tcl_LimitSetCommands                   uintptr
		tcl_LimitSetTime                       uintptr
		tcl_LimitSetGranularity                uintptr
		tcl_LimitTypeEnabled                   uintptr
		tcl_LimitTypeExceeded                  uintptr
		tcl_LimitTypeSet                       uintptr
		tcl_LimitTypeReset                     uintptr
		tcl_LimitGetCommands                   uintptr
		tcl_LimitGetTime                       uintptr
		tcl_LimitGetGranularity                uintptr
		tcl_SaveInterpState                    uintptr
		tcl_RestoreInterpState                 uintptr
		tcl_DiscardInterpState                 uintptr
		tcl_SetReturnOptions                   uintptr
		tcl_GetReturnOptions                   uintptr
		tcl_IsEnsemble                         uintptr
		tcl_CreateEnsemble                     uintptr
		tcl_FindEnsemble                       uintptr
		tcl_SetEnsembleSubcommandList          uintptr
		tcl_SetEnsembleMappingDict             uintptr
		tcl_SetEnsembleUnknownHandler          uintptr
		tcl_SetEnsembleFlags                   uintptr
		tcl_GetEnsembleSubcommandList          uintptr
		tcl_GetEnsembleMappingDict             uintptr
		tcl_GetEnsembleUnknownHandler          uintptr
		tcl_GetEnsembleFlags                   uintptr
		tcl_GetEnsembleNamespace               uintptr
		tcl_SetTimeProc                        uintptr
		tcl_QueryTimeProc                      uintptr
		tcl_ChannelThreadActionProc            uintptr
		tcl_NewBignumObj                       uintptr
		tcl_DbNewBignumObj                     uintptr
		tcl_SetBignumObj                       uintptr
		tcl_GetBignumFromObj                   uintptr
		tcl_TakeBignumFromObj                  uintptr
		tcl_TruncateChannel                    uintptr
		tcl_ChannelTruncateProc                uintptr
		tcl_SetChannelErrorInterp              uintptr
		tcl_GetChannelErrorInterp              uintptr
		tcl_SetChannelError                    uintptr
		tcl_GetChannelError                    uintptr
		tcl_InitBignumFromDouble               uintptr
		tcl_GetNamespaceUnknownHandler         uintptr
		tcl_SetNamespaceUnknownHandler         uintptr
		tcl_GetEncodingFromObj                 uintptr
		tcl_GetEncodingSearchPath              uintptr
		tcl_SetEncodingSearchPath              uintptr
		tcl_GetEncodingNameFromEnvironment     uintptr
		tcl_PkgRequireProc                     uintptr
		tcl_AppendObjToErrorInfo               uintptr
		tcl_AppendLimitedToObj                 uintptr
		tcl_Format                             uintptr
		tcl_AppendFormatToObj                  uintptr
		tcl_ObjPrintf                          uintptr
		tcl_AppendPrintfToObj                  uintptr
		tcl_CancelEval                         uintptr
		tcl_Canceled                           uintptr
		tcl_CreatePipe                         uintptr
		tcl_NRCreateCommand                    uintptr
		tcl_NREvalObj                          uintptr
		tcl_NREvalObjv                         uintptr
		tcl_NRCmdSwap                          uintptr
		tcl_NRAddCallback                      uintptr
		tcl_NRCallObjProc                      uintptr
		tcl_GetFSDeviceFromStat                uintptr
		tcl_GetFSInodeFromStat                 uintptr
		tcl_GetModeFromStat                    uintptr
		tcl_GetLinkCountFromStat               uintptr
		tcl_GetUserIdFromStat                  uintptr
		tcl_GetGroupIdFromStat                 uintptr
		tcl_GetDeviceTypeFromStat              uintptr
		tcl_GetAccessTimeFromStat              uintptr
		tcl_GetModificationTimeFromStat        uintptr
		tcl_GetChangeTimeFromStat              uintptr
		tcl_GetSizeFromStat                    uintptr
		tcl_GetBlocksFromStat                  uintptr
		tcl_GetBlockSizeFromStat               uintptr
		tcl_SetEnsembleParameterList           uintptr
		tcl_GetEnsembleParameterList           uintptr
		tcl_ParseArgsObjv                      uintptr
		tcl_GetErrorLine                       uintptr
		tcl_SetErrorLine                       uintptr
		tcl_TransferResult                     uintptr
		tcl_InterpActive                       uintptr
		tcl_BackgroundException                uintptr
		tcl_ZlibDeflate                        uintptr
		tcl_ZlibInflate                        uintptr
		tcl_ZlibCRC32                          uintptr
		tcl_ZlibAdler32                        uintptr
		tcl_ZlibStreamInit                     uintptr
		tcl_ZlibStreamGetCommandName           uintptr
		tcl_ZlibStreamEof                      uintptr
		tcl_ZlibStreamChecksum                 uintptr
		tcl_ZlibStreamPut                      uintptr
		tcl_ZlibStreamGet                      uintptr
		tcl_ZlibStreamClose                    uintptr
		tcl_ZlibStreamReset                    uintptr
		tcl_SetStartupScript                   uintptr
		tcl_GetStartupScript                   uintptr
		tcl_CloseEx                            uintptr
		tcl_NRExprObj                          uintptr
		tcl_NRSubstObj                         uintptr
		tcl_LoadFile                           uintptr
		tcl_FindSymbol                         uintptr
		tcl_FSUnloadFile                       uintptr
		tcl_ZlibStreamSetCompressionDictionary uintptr
		reserved631                            uintptr
		reserved632                            uintptr
		reserved633                            uintptr
		reserved634                            uintptr
		reserved635                            uintptr
		reserved636                            uintptr
		reserved637                            uintptr
		reserved638                            uintptr
		reserved639                            uintptr
		reserved640                            uintptr
		reserved641                            uintptr
		reserved642                            uintptr
		reserved643                            uintptr
		reserved644                            uintptr
		reserved645                            uintptr
		reserved646                            uintptr
		reserved647                            uintptr
		tclUnusedStubEntry                     uintptr
	}
	if g, e := unsafe.Sizeof(v14), uintptr(5208); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.magic), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.magic), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.magic), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.hooks), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.hooks), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.hooks), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_PkgProvideEx), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_PkgProvideEx), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_PkgProvideEx), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_PkgRequireEx), uintptr(24); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_PkgRequireEx), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_PkgRequireEx), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Panic), uintptr(32); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Panic), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Panic), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Alloc), uintptr(40); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Alloc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Alloc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Free), uintptr(48); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Free), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Free), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Realloc), uintptr(56); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Realloc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Realloc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DbCkalloc), uintptr(64); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DbCkalloc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DbCkalloc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DbCkfree), uintptr(72); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DbCkfree), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DbCkfree), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DbCkrealloc), uintptr(80); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DbCkrealloc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DbCkrealloc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CreateFileHandler), uintptr(88); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CreateFileHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CreateFileHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DeleteFileHandler), uintptr(96); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DeleteFileHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DeleteFileHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetTimer), uintptr(104); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetTimer), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetTimer), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Sleep), uintptr(112); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Sleep), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Sleep), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_WaitForEvent), uintptr(120); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_WaitForEvent), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_WaitForEvent), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AppendAllObjTypes), uintptr(128); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AppendAllObjTypes), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AppendAllObjTypes), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AppendStringsToObj), uintptr(136); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AppendStringsToObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AppendStringsToObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AppendToObj), uintptr(144); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AppendToObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AppendToObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ConcatObj), uintptr(152); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ConcatObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ConcatObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ConvertToType), uintptr(160); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ConvertToType), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ConvertToType), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DbDecrRefCount), uintptr(168); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DbDecrRefCount), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DbDecrRefCount), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DbIncrRefCount), uintptr(176); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DbIncrRefCount), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DbIncrRefCount), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DbIsShared), uintptr(184); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DbIsShared), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DbIsShared), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DbNewBooleanObj), uintptr(192); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DbNewBooleanObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DbNewBooleanObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DbNewByteArrayObj), uintptr(200); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DbNewByteArrayObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DbNewByteArrayObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DbNewDoubleObj), uintptr(208); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DbNewDoubleObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DbNewDoubleObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DbNewListObj), uintptr(216); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DbNewListObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DbNewListObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DbNewLongObj), uintptr(224); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DbNewLongObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DbNewLongObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DbNewObj), uintptr(232); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DbNewObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DbNewObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DbNewStringObj), uintptr(240); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DbNewStringObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DbNewStringObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DuplicateObj), uintptr(248); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DuplicateObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DuplicateObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tclFreeObj), uintptr(256); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tclFreeObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tclFreeObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetBoolean), uintptr(264); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetBoolean), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetBoolean), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetBooleanFromObj), uintptr(272); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetBooleanFromObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetBooleanFromObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetByteArrayFromObj), uintptr(280); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetByteArrayFromObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetByteArrayFromObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetDouble), uintptr(288); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetDouble), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetDouble), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetDoubleFromObj), uintptr(296); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetDoubleFromObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetDoubleFromObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetIndexFromObj), uintptr(304); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetIndexFromObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetIndexFromObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetInt), uintptr(312); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetInt), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetInt), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetIntFromObj), uintptr(320); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetIntFromObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetIntFromObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetLongFromObj), uintptr(328); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetLongFromObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetLongFromObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetObjType), uintptr(336); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetObjType), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetObjType), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetStringFromObj), uintptr(344); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetStringFromObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetStringFromObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_InvalidateStringRep), uintptr(352); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_InvalidateStringRep), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_InvalidateStringRep), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ListObjAppendList), uintptr(360); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ListObjAppendList), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ListObjAppendList), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ListObjAppendElement), uintptr(368); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ListObjAppendElement), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ListObjAppendElement), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ListObjGetElements), uintptr(376); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ListObjGetElements), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ListObjGetElements), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ListObjIndex), uintptr(384); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ListObjIndex), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ListObjIndex), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ListObjLength), uintptr(392); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ListObjLength), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ListObjLength), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ListObjReplace), uintptr(400); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ListObjReplace), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ListObjReplace), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_NewBooleanObj), uintptr(408); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_NewBooleanObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_NewBooleanObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_NewByteArrayObj), uintptr(416); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_NewByteArrayObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_NewByteArrayObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_NewDoubleObj), uintptr(424); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_NewDoubleObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_NewDoubleObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_NewIntObj), uintptr(432); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_NewIntObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_NewIntObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_NewListObj), uintptr(440); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_NewListObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_NewListObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_NewLongObj), uintptr(448); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_NewLongObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_NewLongObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_NewObj), uintptr(456); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_NewObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_NewObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_NewStringObj), uintptr(464); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_NewStringObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_NewStringObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetBooleanObj), uintptr(472); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetBooleanObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetBooleanObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetByteArrayLength), uintptr(480); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetByteArrayLength), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetByteArrayLength), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetByteArrayObj), uintptr(488); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetByteArrayObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetByteArrayObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetDoubleObj), uintptr(496); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetDoubleObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetDoubleObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetIntObj), uintptr(504); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetIntObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetIntObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetListObj), uintptr(512); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetListObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetListObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetLongObj), uintptr(520); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetLongObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetLongObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetObjLength), uintptr(528); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetObjLength), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetObjLength), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetStringObj), uintptr(536); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetStringObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetStringObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AddErrorInfo), uintptr(544); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AddErrorInfo), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AddErrorInfo), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AddObjErrorInfo), uintptr(552); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AddObjErrorInfo), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AddObjErrorInfo), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AllowExceptions), uintptr(560); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AllowExceptions), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AllowExceptions), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AppendElement), uintptr(568); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AppendElement), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AppendElement), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AppendResult), uintptr(576); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AppendResult), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AppendResult), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AsyncCreate), uintptr(584); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AsyncCreate), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AsyncCreate), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AsyncDelete), uintptr(592); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AsyncDelete), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AsyncDelete), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AsyncInvoke), uintptr(600); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AsyncInvoke), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AsyncInvoke), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AsyncMark), uintptr(608); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AsyncMark), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AsyncMark), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AsyncReady), uintptr(616); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AsyncReady), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AsyncReady), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_BackgroundError), uintptr(624); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_BackgroundError), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_BackgroundError), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Backslash), uintptr(632); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Backslash), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Backslash), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_BadChannelOption), uintptr(640); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_BadChannelOption), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_BadChannelOption), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CallWhenDeleted), uintptr(648); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CallWhenDeleted), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CallWhenDeleted), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CancelIdleCall), uintptr(656); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CancelIdleCall), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CancelIdleCall), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Close), uintptr(664); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Close), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Close), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CommandComplete), uintptr(672); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CommandComplete), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CommandComplete), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Concat), uintptr(680); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Concat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Concat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ConvertElement), uintptr(688); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ConvertElement), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ConvertElement), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ConvertCountedElement), uintptr(696); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ConvertCountedElement), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ConvertCountedElement), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CreateAlias), uintptr(704); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CreateAlias), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CreateAlias), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CreateAliasObj), uintptr(712); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CreateAliasObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CreateAliasObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CreateChannel), uintptr(720); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CreateChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CreateChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CreateChannelHandler), uintptr(728); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CreateChannelHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CreateChannelHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CreateCloseHandler), uintptr(736); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CreateCloseHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CreateCloseHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CreateCommand), uintptr(744); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CreateCommand), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CreateCommand), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CreateEventSource), uintptr(752); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CreateEventSource), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CreateEventSource), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CreateExitHandler), uintptr(760); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CreateExitHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CreateExitHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CreateInterp), uintptr(768); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CreateInterp), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CreateInterp), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CreateMathFunc), uintptr(776); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CreateMathFunc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CreateMathFunc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CreateObjCommand), uintptr(784); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CreateObjCommand), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CreateObjCommand), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CreateSlave), uintptr(792); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CreateSlave), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CreateSlave), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CreateTimerHandler), uintptr(800); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CreateTimerHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CreateTimerHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CreateTrace), uintptr(808); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CreateTrace), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CreateTrace), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DeleteAssocData), uintptr(816); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DeleteAssocData), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DeleteAssocData), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DeleteChannelHandler), uintptr(824); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DeleteChannelHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DeleteChannelHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DeleteCloseHandler), uintptr(832); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DeleteCloseHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DeleteCloseHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DeleteCommand), uintptr(840); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DeleteCommand), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DeleteCommand), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DeleteCommandFromToken), uintptr(848); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DeleteCommandFromToken), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DeleteCommandFromToken), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DeleteEvents), uintptr(856); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DeleteEvents), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DeleteEvents), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DeleteEventSource), uintptr(864); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DeleteEventSource), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DeleteEventSource), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DeleteExitHandler), uintptr(872); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DeleteExitHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DeleteExitHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DeleteHashEntry), uintptr(880); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DeleteHashEntry), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DeleteHashEntry), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DeleteHashTable), uintptr(888); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DeleteHashTable), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DeleteHashTable), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DeleteInterp), uintptr(896); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DeleteInterp), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DeleteInterp), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DetachPids), uintptr(904); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DetachPids), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DetachPids), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DeleteTimerHandler), uintptr(912); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DeleteTimerHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DeleteTimerHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DeleteTrace), uintptr(920); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DeleteTrace), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DeleteTrace), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DontCallWhenDeleted), uintptr(928); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DontCallWhenDeleted), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DontCallWhenDeleted), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DoOneEvent), uintptr(936); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DoOneEvent), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DoOneEvent), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DoWhenIdle), uintptr(944); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DoWhenIdle), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DoWhenIdle), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DStringAppend), uintptr(952); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DStringAppend), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DStringAppend), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DStringAppendElement), uintptr(960); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DStringAppendElement), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DStringAppendElement), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DStringEndSublist), uintptr(968); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DStringEndSublist), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DStringEndSublist), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DStringFree), uintptr(976); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DStringFree), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DStringFree), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DStringGetResult), uintptr(984); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DStringGetResult), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DStringGetResult), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DStringInit), uintptr(992); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DStringInit), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DStringInit), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DStringResult), uintptr(1000); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DStringResult), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DStringResult), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DStringSetLength), uintptr(1008); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DStringSetLength), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DStringSetLength), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DStringStartSublist), uintptr(1016); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DStringStartSublist), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DStringStartSublist), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Eof), uintptr(1024); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Eof), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Eof), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ErrnoId), uintptr(1032); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ErrnoId), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ErrnoId), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ErrnoMsg), uintptr(1040); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ErrnoMsg), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ErrnoMsg), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Eval), uintptr(1048); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Eval), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Eval), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_EvalFile), uintptr(1056); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_EvalFile), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_EvalFile), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_EvalObj), uintptr(1064); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_EvalObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_EvalObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_EventuallyFree), uintptr(1072); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_EventuallyFree), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_EventuallyFree), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Exit), uintptr(1080); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Exit), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Exit), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ExposeCommand), uintptr(1088); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ExposeCommand), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ExposeCommand), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ExprBoolean), uintptr(1096); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ExprBoolean), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ExprBoolean), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ExprBooleanObj), uintptr(1104); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ExprBooleanObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ExprBooleanObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ExprDouble), uintptr(1112); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ExprDouble), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ExprDouble), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ExprDoubleObj), uintptr(1120); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ExprDoubleObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ExprDoubleObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ExprLong), uintptr(1128); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ExprLong), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ExprLong), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ExprLongObj), uintptr(1136); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ExprLongObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ExprLongObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ExprObj), uintptr(1144); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ExprObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ExprObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ExprString), uintptr(1152); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ExprString), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ExprString), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Finalize), uintptr(1160); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Finalize), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Finalize), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FindExecutable), uintptr(1168); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FindExecutable), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FindExecutable), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FirstHashEntry), uintptr(1176); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FirstHashEntry), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FirstHashEntry), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Flush), uintptr(1184); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Flush), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Flush), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FreeResult), uintptr(1192); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FreeResult), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FreeResult), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetAlias), uintptr(1200); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetAlias), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetAlias), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetAliasObj), uintptr(1208); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetAliasObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetAliasObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetAssocData), uintptr(1216); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetAssocData), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetAssocData), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetChannel), uintptr(1224); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetChannelBufferSize), uintptr(1232); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetChannelBufferSize), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetChannelBufferSize), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetChannelHandle), uintptr(1240); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetChannelHandle), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetChannelHandle), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetChannelInstanceData), uintptr(1248); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetChannelInstanceData), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetChannelInstanceData), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetChannelMode), uintptr(1256); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetChannelMode), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetChannelMode), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetChannelName), uintptr(1264); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetChannelName), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetChannelName), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetChannelOption), uintptr(1272); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetChannelOption), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetChannelOption), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetChannelType), uintptr(1280); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetChannelType), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetChannelType), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetCommandInfo), uintptr(1288); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetCommandInfo), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetCommandInfo), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetCommandName), uintptr(1296); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetCommandName), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetCommandName), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetErrno), uintptr(1304); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetErrno), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetErrno), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetHostName), uintptr(1312); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetHostName), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetHostName), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetInterpPath), uintptr(1320); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetInterpPath), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetInterpPath), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetMaster), uintptr(1328); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetMaster), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetMaster), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetNameOfExecutable), uintptr(1336); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetNameOfExecutable), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetNameOfExecutable), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetObjResult), uintptr(1344); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetObjResult), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetObjResult), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetOpenFile), uintptr(1352); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetOpenFile), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetOpenFile), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetPathType), uintptr(1360); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetPathType), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetPathType), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Gets), uintptr(1368); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Gets), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Gets), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetsObj), uintptr(1376); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetsObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetsObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetServiceMode), uintptr(1384); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetServiceMode), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetServiceMode), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetSlave), uintptr(1392); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetSlave), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetSlave), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetStdChannel), uintptr(1400); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetStdChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetStdChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetStringResult), uintptr(1408); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetStringResult), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetStringResult), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetVar), uintptr(1416); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetVar), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetVar), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetVar2), uintptr(1424); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetVar2), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetVar2), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GlobalEval), uintptr(1432); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GlobalEval), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GlobalEval), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GlobalEvalObj), uintptr(1440); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GlobalEvalObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GlobalEvalObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_HideCommand), uintptr(1448); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_HideCommand), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_HideCommand), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Init), uintptr(1456); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Init), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Init), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_InitHashTable), uintptr(1464); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_InitHashTable), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_InitHashTable), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_InputBlocked), uintptr(1472); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_InputBlocked), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_InputBlocked), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_InputBuffered), uintptr(1480); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_InputBuffered), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_InputBuffered), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_InterpDeleted), uintptr(1488); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_InterpDeleted), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_InterpDeleted), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_IsSafe), uintptr(1496); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_IsSafe), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_IsSafe), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_JoinPath), uintptr(1504); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_JoinPath), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_JoinPath), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_LinkVar), uintptr(1512); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_LinkVar), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_LinkVar), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.reserved188), uintptr(1520); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.reserved188), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.reserved188), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_MakeFileChannel), uintptr(1528); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_MakeFileChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_MakeFileChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_MakeSafe), uintptr(1536); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_MakeSafe), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_MakeSafe), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_MakeTcpClientChannel), uintptr(1544); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_MakeTcpClientChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_MakeTcpClientChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Merge), uintptr(1552); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Merge), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Merge), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_NextHashEntry), uintptr(1560); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_NextHashEntry), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_NextHashEntry), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_NotifyChannel), uintptr(1568); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_NotifyChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_NotifyChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ObjGetVar2), uintptr(1576); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ObjGetVar2), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ObjGetVar2), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ObjSetVar2), uintptr(1584); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ObjSetVar2), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ObjSetVar2), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_OpenCommandChannel), uintptr(1592); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_OpenCommandChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_OpenCommandChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_OpenFileChannel), uintptr(1600); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_OpenFileChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_OpenFileChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_OpenTcpClient), uintptr(1608); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_OpenTcpClient), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_OpenTcpClient), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_OpenTcpServer), uintptr(1616); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_OpenTcpServer), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_OpenTcpServer), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Preserve), uintptr(1624); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Preserve), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Preserve), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_PrintDouble), uintptr(1632); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_PrintDouble), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_PrintDouble), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_PutEnv), uintptr(1640); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_PutEnv), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_PutEnv), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_PosixError), uintptr(1648); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_PosixError), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_PosixError), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_QueueEvent), uintptr(1656); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_QueueEvent), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_QueueEvent), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Read), uintptr(1664); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Read), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Read), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ReapDetachedProcs), uintptr(1672); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ReapDetachedProcs), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ReapDetachedProcs), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_RecordAndEval), uintptr(1680); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_RecordAndEval), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_RecordAndEval), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_RecordAndEvalObj), uintptr(1688); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_RecordAndEvalObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_RecordAndEvalObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_RegisterChannel), uintptr(1696); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_RegisterChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_RegisterChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_RegisterObjType), uintptr(1704); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_RegisterObjType), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_RegisterObjType), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_RegExpCompile), uintptr(1712); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_RegExpCompile), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_RegExpCompile), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_RegExpExec), uintptr(1720); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_RegExpExec), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_RegExpExec), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_RegExpMatch), uintptr(1728); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_RegExpMatch), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_RegExpMatch), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_RegExpRange), uintptr(1736); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_RegExpRange), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_RegExpRange), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Release), uintptr(1744); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Release), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Release), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ResetResult), uintptr(1752); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ResetResult), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ResetResult), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ScanElement), uintptr(1760); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ScanElement), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ScanElement), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ScanCountedElement), uintptr(1768); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ScanCountedElement), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ScanCountedElement), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SeekOld), uintptr(1776); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SeekOld), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SeekOld), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ServiceAll), uintptr(1784); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ServiceAll), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ServiceAll), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ServiceEvent), uintptr(1792); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ServiceEvent), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ServiceEvent), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetAssocData), uintptr(1800); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetAssocData), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetAssocData), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetChannelBufferSize), uintptr(1808); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetChannelBufferSize), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetChannelBufferSize), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetChannelOption), uintptr(1816); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetChannelOption), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetChannelOption), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetCommandInfo), uintptr(1824); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetCommandInfo), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetCommandInfo), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetErrno), uintptr(1832); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetErrno), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetErrno), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetErrorCode), uintptr(1840); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetErrorCode), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetErrorCode), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetMaxBlockTime), uintptr(1848); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetMaxBlockTime), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetMaxBlockTime), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetPanicProc), uintptr(1856); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetPanicProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetPanicProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetRecursionLimit), uintptr(1864); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetRecursionLimit), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetRecursionLimit), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetResult), uintptr(1872); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetResult), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetResult), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetServiceMode), uintptr(1880); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetServiceMode), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetServiceMode), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetObjErrorCode), uintptr(1888); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetObjErrorCode), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetObjErrorCode), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetObjResult), uintptr(1896); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetObjResult), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetObjResult), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetStdChannel), uintptr(1904); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetStdChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetStdChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetVar), uintptr(1912); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetVar), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetVar), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetVar2), uintptr(1920); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetVar2), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetVar2), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SignalId), uintptr(1928); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SignalId), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SignalId), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SignalMsg), uintptr(1936); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SignalMsg), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SignalMsg), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SourceRCFile), uintptr(1944); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SourceRCFile), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SourceRCFile), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SplitList), uintptr(1952); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SplitList), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SplitList), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SplitPath), uintptr(1960); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SplitPath), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SplitPath), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_StaticPackage), uintptr(1968); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_StaticPackage), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_StaticPackage), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_StringMatch), uintptr(1976); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_StringMatch), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_StringMatch), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_TellOld), uintptr(1984); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_TellOld), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_TellOld), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_TraceVar), uintptr(1992); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_TraceVar), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_TraceVar), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_TraceVar2), uintptr(2000); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_TraceVar2), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_TraceVar2), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_TranslateFileName), uintptr(2008); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_TranslateFileName), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_TranslateFileName), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Ungets), uintptr(2016); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Ungets), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Ungets), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UnlinkVar), uintptr(2024); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UnlinkVar), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UnlinkVar), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UnregisterChannel), uintptr(2032); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UnregisterChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UnregisterChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UnsetVar), uintptr(2040); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UnsetVar), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UnsetVar), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UnsetVar2), uintptr(2048); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UnsetVar2), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UnsetVar2), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UntraceVar), uintptr(2056); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UntraceVar), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UntraceVar), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UntraceVar2), uintptr(2064); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UntraceVar2), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UntraceVar2), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UpdateLinkedVar), uintptr(2072); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UpdateLinkedVar), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UpdateLinkedVar), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UpVar), uintptr(2080); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UpVar), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UpVar), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UpVar2), uintptr(2088); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UpVar2), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UpVar2), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_VarEval), uintptr(2096); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_VarEval), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_VarEval), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_VarTraceInfo), uintptr(2104); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_VarTraceInfo), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_VarTraceInfo), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_VarTraceInfo2), uintptr(2112); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_VarTraceInfo2), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_VarTraceInfo2), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Write), uintptr(2120); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Write), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Write), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_WrongNumArgs), uintptr(2128); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_WrongNumArgs), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_WrongNumArgs), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DumpActiveMemory), uintptr(2136); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DumpActiveMemory), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DumpActiveMemory), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ValidateAllMemory), uintptr(2144); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ValidateAllMemory), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ValidateAllMemory), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AppendResultVA), uintptr(2152); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AppendResultVA), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AppendResultVA), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AppendStringsToObjVA), uintptr(2160); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AppendStringsToObjVA), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AppendStringsToObjVA), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_HashStats), uintptr(2168); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_HashStats), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_HashStats), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ParseVar), uintptr(2176); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ParseVar), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ParseVar), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_PkgPresent), uintptr(2184); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_PkgPresent), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_PkgPresent), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_PkgPresentEx), uintptr(2192); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_PkgPresentEx), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_PkgPresentEx), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_PkgProvide), uintptr(2200); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_PkgProvide), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_PkgProvide), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_PkgRequire), uintptr(2208); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_PkgRequire), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_PkgRequire), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetErrorCodeVA), uintptr(2216); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetErrorCodeVA), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetErrorCodeVA), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_VarEvalVA), uintptr(2224); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_VarEvalVA), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_VarEvalVA), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_WaitPid), uintptr(2232); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_WaitPid), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_WaitPid), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_PanicVA), uintptr(2240); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_PanicVA), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_PanicVA), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetVersion), uintptr(2248); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetVersion), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetVersion), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_InitMemory), uintptr(2256); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_InitMemory), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_InitMemory), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_StackChannel), uintptr(2264); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_StackChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_StackChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UnstackChannel), uintptr(2272); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UnstackChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UnstackChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetStackedChannel), uintptr(2280); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetStackedChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetStackedChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetMainLoop), uintptr(2288); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetMainLoop), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetMainLoop), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.reserved285), uintptr(2296); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.reserved285), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.reserved285), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AppendObjToObj), uintptr(2304); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AppendObjToObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AppendObjToObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CreateEncoding), uintptr(2312); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CreateEncoding), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CreateEncoding), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CreateThreadExitHandler), uintptr(2320); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CreateThreadExitHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CreateThreadExitHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DeleteThreadExitHandler), uintptr(2328); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DeleteThreadExitHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DeleteThreadExitHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DiscardResult), uintptr(2336); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DiscardResult), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DiscardResult), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_EvalEx), uintptr(2344); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_EvalEx), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_EvalEx), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_EvalObjv), uintptr(2352); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_EvalObjv), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_EvalObjv), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_EvalObjEx), uintptr(2360); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_EvalObjEx), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_EvalObjEx), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ExitThread), uintptr(2368); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ExitThread), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ExitThread), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ExternalToUtf), uintptr(2376); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ExternalToUtf), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ExternalToUtf), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ExternalToUtfDString), uintptr(2384); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ExternalToUtfDString), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ExternalToUtfDString), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FinalizeThread), uintptr(2392); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FinalizeThread), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FinalizeThread), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FinalizeNotifier), uintptr(2400); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FinalizeNotifier), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FinalizeNotifier), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FreeEncoding), uintptr(2408); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FreeEncoding), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FreeEncoding), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetCurrentThread), uintptr(2416); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetCurrentThread), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetCurrentThread), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetEncoding), uintptr(2424); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetEncoding), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetEncoding), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetEncodingName), uintptr(2432); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetEncodingName), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetEncodingName), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetEncodingNames), uintptr(2440); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetEncodingNames), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetEncodingNames), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetIndexFromObjStruct), uintptr(2448); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetIndexFromObjStruct), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetIndexFromObjStruct), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetThreadData), uintptr(2456); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetThreadData), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetThreadData), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetVar2Ex), uintptr(2464); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetVar2Ex), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetVar2Ex), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_InitNotifier), uintptr(2472); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_InitNotifier), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_InitNotifier), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_MutexLock), uintptr(2480); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_MutexLock), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_MutexLock), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_MutexUnlock), uintptr(2488); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_MutexUnlock), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_MutexUnlock), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ConditionNotify), uintptr(2496); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ConditionNotify), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ConditionNotify), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ConditionWait), uintptr(2504); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ConditionWait), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ConditionWait), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_NumUtfChars), uintptr(2512); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_NumUtfChars), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_NumUtfChars), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ReadChars), uintptr(2520); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ReadChars), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ReadChars), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_RestoreResult), uintptr(2528); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_RestoreResult), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_RestoreResult), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SaveResult), uintptr(2536); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SaveResult), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SaveResult), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetSystemEncoding), uintptr(2544); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetSystemEncoding), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetSystemEncoding), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetVar2Ex), uintptr(2552); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetVar2Ex), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetVar2Ex), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ThreadAlert), uintptr(2560); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ThreadAlert), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ThreadAlert), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ThreadQueueEvent), uintptr(2568); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ThreadQueueEvent), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ThreadQueueEvent), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UniCharAtIndex), uintptr(2576); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UniCharAtIndex), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UniCharAtIndex), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UniCharToLower), uintptr(2584); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UniCharToLower), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UniCharToLower), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UniCharToTitle), uintptr(2592); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UniCharToTitle), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UniCharToTitle), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UniCharToUpper), uintptr(2600); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UniCharToUpper), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UniCharToUpper), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UniCharToUtf), uintptr(2608); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UniCharToUtf), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UniCharToUtf), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UtfAtIndex), uintptr(2616); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UtfAtIndex), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UtfAtIndex), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UtfCharComplete), uintptr(2624); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UtfCharComplete), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UtfCharComplete), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UtfBackslash), uintptr(2632); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UtfBackslash), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UtfBackslash), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UtfFindFirst), uintptr(2640); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UtfFindFirst), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UtfFindFirst), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UtfFindLast), uintptr(2648); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UtfFindLast), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UtfFindLast), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UtfNext), uintptr(2656); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UtfNext), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UtfNext), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UtfPrev), uintptr(2664); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UtfPrev), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UtfPrev), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UtfToExternal), uintptr(2672); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UtfToExternal), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UtfToExternal), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UtfToExternalDString), uintptr(2680); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UtfToExternalDString), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UtfToExternalDString), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UtfToLower), uintptr(2688); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UtfToLower), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UtfToLower), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UtfToTitle), uintptr(2696); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UtfToTitle), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UtfToTitle), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UtfToUniChar), uintptr(2704); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UtfToUniChar), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UtfToUniChar), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UtfToUpper), uintptr(2712); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UtfToUpper), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UtfToUpper), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_WriteChars), uintptr(2720); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_WriteChars), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_WriteChars), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_WriteObj), uintptr(2728); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_WriteObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_WriteObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetString), uintptr(2736); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetString), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetString), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetDefaultEncodingDir), uintptr(2744); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetDefaultEncodingDir), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetDefaultEncodingDir), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetDefaultEncodingDir), uintptr(2752); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetDefaultEncodingDir), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetDefaultEncodingDir), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AlertNotifier), uintptr(2760); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AlertNotifier), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AlertNotifier), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ServiceModeHook), uintptr(2768); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ServiceModeHook), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ServiceModeHook), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UniCharIsAlnum), uintptr(2776); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UniCharIsAlnum), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UniCharIsAlnum), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UniCharIsAlpha), uintptr(2784); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UniCharIsAlpha), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UniCharIsAlpha), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UniCharIsDigit), uintptr(2792); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UniCharIsDigit), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UniCharIsDigit), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UniCharIsLower), uintptr(2800); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UniCharIsLower), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UniCharIsLower), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UniCharIsSpace), uintptr(2808); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UniCharIsSpace), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UniCharIsSpace), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UniCharIsUpper), uintptr(2816); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UniCharIsUpper), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UniCharIsUpper), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UniCharIsWordChar), uintptr(2824); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UniCharIsWordChar), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UniCharIsWordChar), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UniCharLen), uintptr(2832); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UniCharLen), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UniCharLen), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UniCharNcmp), uintptr(2840); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UniCharNcmp), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UniCharNcmp), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UniCharToUtfDString), uintptr(2848); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UniCharToUtfDString), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UniCharToUtfDString), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UtfToUniCharDString), uintptr(2856); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UtfToUniCharDString), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UtfToUniCharDString), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetRegExpFromObj), uintptr(2864); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetRegExpFromObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetRegExpFromObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_EvalTokens), uintptr(2872); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_EvalTokens), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_EvalTokens), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FreeParse), uintptr(2880); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FreeParse), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FreeParse), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_LogCommandInfo), uintptr(2888); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_LogCommandInfo), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_LogCommandInfo), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ParseBraces), uintptr(2896); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ParseBraces), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ParseBraces), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ParseCommand), uintptr(2904); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ParseCommand), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ParseCommand), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ParseExpr), uintptr(2912); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ParseExpr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ParseExpr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ParseQuotedString), uintptr(2920); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ParseQuotedString), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ParseQuotedString), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ParseVarName), uintptr(2928); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ParseVarName), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ParseVarName), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetCwd), uintptr(2936); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetCwd), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetCwd), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Chdir), uintptr(2944); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Chdir), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Chdir), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Access), uintptr(2952); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Access), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Access), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Stat), uintptr(2960); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Stat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Stat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UtfNcmp), uintptr(2968); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UtfNcmp), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UtfNcmp), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UtfNcasecmp), uintptr(2976); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UtfNcasecmp), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UtfNcasecmp), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_StringCaseMatch), uintptr(2984); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_StringCaseMatch), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_StringCaseMatch), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UniCharIsControl), uintptr(2992); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UniCharIsControl), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UniCharIsControl), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UniCharIsGraph), uintptr(3000); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UniCharIsGraph), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UniCharIsGraph), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UniCharIsPrint), uintptr(3008); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UniCharIsPrint), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UniCharIsPrint), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UniCharIsPunct), uintptr(3016); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UniCharIsPunct), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UniCharIsPunct), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_RegExpExecObj), uintptr(3024); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_RegExpExecObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_RegExpExecObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_RegExpGetInfo), uintptr(3032); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_RegExpGetInfo), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_RegExpGetInfo), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_NewUnicodeObj), uintptr(3040); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_NewUnicodeObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_NewUnicodeObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetUnicodeObj), uintptr(3048); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetUnicodeObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetUnicodeObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetCharLength), uintptr(3056); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetCharLength), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetCharLength), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetUniChar), uintptr(3064); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetUniChar), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetUniChar), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetUnicode), uintptr(3072); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetUnicode), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetUnicode), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetRange), uintptr(3080); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetRange), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetRange), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AppendUnicodeToObj), uintptr(3088); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AppendUnicodeToObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AppendUnicodeToObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_RegExpMatchObj), uintptr(3096); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_RegExpMatchObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_RegExpMatchObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetNotifier), uintptr(3104); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetNotifier), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetNotifier), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetAllocMutex), uintptr(3112); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetAllocMutex), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetAllocMutex), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetChannelNames), uintptr(3120); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetChannelNames), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetChannelNames), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetChannelNamesEx), uintptr(3128); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetChannelNamesEx), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetChannelNamesEx), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ProcObjCmd), uintptr(3136); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ProcObjCmd), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ProcObjCmd), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ConditionFinalize), uintptr(3144); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ConditionFinalize), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ConditionFinalize), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_MutexFinalize), uintptr(3152); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_MutexFinalize), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_MutexFinalize), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CreateThread), uintptr(3160); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CreateThread), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CreateThread), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ReadRaw), uintptr(3168); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ReadRaw), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ReadRaw), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_WriteRaw), uintptr(3176); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_WriteRaw), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_WriteRaw), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetTopChannel), uintptr(3184); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetTopChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetTopChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ChannelBuffered), uintptr(3192); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ChannelBuffered), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ChannelBuffered), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ChannelName), uintptr(3200); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ChannelName), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ChannelName), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ChannelVersion), uintptr(3208); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ChannelVersion), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ChannelVersion), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ChannelBlockModeProc), uintptr(3216); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ChannelBlockModeProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ChannelBlockModeProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ChannelCloseProc), uintptr(3224); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ChannelCloseProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ChannelCloseProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ChannelClose2Proc), uintptr(3232); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ChannelClose2Proc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ChannelClose2Proc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ChannelInputProc), uintptr(3240); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ChannelInputProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ChannelInputProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ChannelOutputProc), uintptr(3248); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ChannelOutputProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ChannelOutputProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ChannelSeekProc), uintptr(3256); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ChannelSeekProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ChannelSeekProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ChannelSetOptionProc), uintptr(3264); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ChannelSetOptionProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ChannelSetOptionProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ChannelGetOptionProc), uintptr(3272); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ChannelGetOptionProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ChannelGetOptionProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ChannelWatchProc), uintptr(3280); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ChannelWatchProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ChannelWatchProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ChannelGetHandleProc), uintptr(3288); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ChannelGetHandleProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ChannelGetHandleProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ChannelFlushProc), uintptr(3296); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ChannelFlushProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ChannelFlushProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ChannelHandlerProc), uintptr(3304); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ChannelHandlerProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ChannelHandlerProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_JoinThread), uintptr(3312); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_JoinThread), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_JoinThread), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_IsChannelShared), uintptr(3320); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_IsChannelShared), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_IsChannelShared), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_IsChannelRegistered), uintptr(3328); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_IsChannelRegistered), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_IsChannelRegistered), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CutChannel), uintptr(3336); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CutChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CutChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SpliceChannel), uintptr(3344); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SpliceChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SpliceChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ClearChannelHandlers), uintptr(3352); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ClearChannelHandlers), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ClearChannelHandlers), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_IsChannelExisting), uintptr(3360); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_IsChannelExisting), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_IsChannelExisting), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UniCharNcasecmp), uintptr(3368); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UniCharNcasecmp), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UniCharNcasecmp), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UniCharCaseMatch), uintptr(3376); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UniCharCaseMatch), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UniCharCaseMatch), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FindHashEntry), uintptr(3384); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FindHashEntry), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FindHashEntry), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CreateHashEntry), uintptr(3392); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CreateHashEntry), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CreateHashEntry), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_InitCustomHashTable), uintptr(3400); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_InitCustomHashTable), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_InitCustomHashTable), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_InitObjHashTable), uintptr(3408); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_InitObjHashTable), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_InitObjHashTable), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CommandTraceInfo), uintptr(3416); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CommandTraceInfo), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CommandTraceInfo), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_TraceCommand), uintptr(3424); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_TraceCommand), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_TraceCommand), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_UntraceCommand), uintptr(3432); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_UntraceCommand), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_UntraceCommand), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AttemptAlloc), uintptr(3440); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AttemptAlloc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AttemptAlloc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AttemptDbCkalloc), uintptr(3448); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AttemptDbCkalloc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AttemptDbCkalloc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AttemptRealloc), uintptr(3456); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AttemptRealloc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AttemptRealloc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AttemptDbCkrealloc), uintptr(3464); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AttemptDbCkrealloc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AttemptDbCkrealloc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AttemptSetObjLength), uintptr(3472); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AttemptSetObjLength), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AttemptSetObjLength), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetChannelThread), uintptr(3480); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetChannelThread), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetChannelThread), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetUnicodeFromObj), uintptr(3488); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetUnicodeFromObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetUnicodeFromObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetMathFuncInfo), uintptr(3496); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetMathFuncInfo), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetMathFuncInfo), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ListMathFuncs), uintptr(3504); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ListMathFuncs), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ListMathFuncs), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SubstObj), uintptr(3512); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SubstObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SubstObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DetachChannel), uintptr(3520); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DetachChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DetachChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_IsStandardChannel), uintptr(3528); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_IsStandardChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_IsStandardChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSCopyFile), uintptr(3536); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSCopyFile), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSCopyFile), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSCopyDirectory), uintptr(3544); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSCopyDirectory), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSCopyDirectory), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSCreateDirectory), uintptr(3552); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSCreateDirectory), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSCreateDirectory), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSDeleteFile), uintptr(3560); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSDeleteFile), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSDeleteFile), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSLoadFile), uintptr(3568); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSLoadFile), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSLoadFile), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSMatchInDirectory), uintptr(3576); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSMatchInDirectory), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSMatchInDirectory), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSLink), uintptr(3584); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSLink), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSLink), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSRemoveDirectory), uintptr(3592); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSRemoveDirectory), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSRemoveDirectory), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSRenameFile), uintptr(3600); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSRenameFile), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSRenameFile), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSLstat), uintptr(3608); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSLstat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSLstat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSUtime), uintptr(3616); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSUtime), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSUtime), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSFileAttrsGet), uintptr(3624); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSFileAttrsGet), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSFileAttrsGet), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSFileAttrsSet), uintptr(3632); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSFileAttrsSet), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSFileAttrsSet), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSFileAttrStrings), uintptr(3640); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSFileAttrStrings), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSFileAttrStrings), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSStat), uintptr(3648); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSStat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSStat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSAccess), uintptr(3656); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSAccess), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSAccess), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSOpenFileChannel), uintptr(3664); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSOpenFileChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSOpenFileChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSGetCwd), uintptr(3672); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSGetCwd), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSGetCwd), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSChdir), uintptr(3680); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSChdir), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSChdir), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSConvertToPathType), uintptr(3688); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSConvertToPathType), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSConvertToPathType), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSJoinPath), uintptr(3696); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSJoinPath), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSJoinPath), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSSplitPath), uintptr(3704); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSSplitPath), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSSplitPath), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSEqualPaths), uintptr(3712); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSEqualPaths), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSEqualPaths), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSGetNormalizedPath), uintptr(3720); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSGetNormalizedPath), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSGetNormalizedPath), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSJoinToPath), uintptr(3728); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSJoinToPath), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSJoinToPath), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSGetInternalRep), uintptr(3736); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSGetInternalRep), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSGetInternalRep), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSGetTranslatedPath), uintptr(3744); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSGetTranslatedPath), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSGetTranslatedPath), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSEvalFile), uintptr(3752); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSEvalFile), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSEvalFile), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSNewNativePath), uintptr(3760); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSNewNativePath), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSNewNativePath), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSGetNativePath), uintptr(3768); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSGetNativePath), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSGetNativePath), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSFileSystemInfo), uintptr(3776); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSFileSystemInfo), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSFileSystemInfo), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSPathSeparator), uintptr(3784); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSPathSeparator), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSPathSeparator), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSListVolumes), uintptr(3792); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSListVolumes), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSListVolumes), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSRegister), uintptr(3800); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSRegister), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSRegister), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSUnregister), uintptr(3808); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSUnregister), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSUnregister), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSData), uintptr(3816); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSData), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSData), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSGetTranslatedStringPath), uintptr(3824); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSGetTranslatedStringPath), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSGetTranslatedStringPath), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSGetFileSystemForPath), uintptr(3832); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSGetFileSystemForPath), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSGetFileSystemForPath), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSGetPathType), uintptr(3840); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSGetPathType), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSGetPathType), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_OutputBuffered), uintptr(3848); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_OutputBuffered), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_OutputBuffered), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSMountsChanged), uintptr(3856); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSMountsChanged), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSMountsChanged), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_EvalTokensStandard), uintptr(3864); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_EvalTokensStandard), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_EvalTokensStandard), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetTime), uintptr(3872); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetTime), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetTime), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CreateObjTrace), uintptr(3880); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CreateObjTrace), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CreateObjTrace), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetCommandInfoFromToken), uintptr(3888); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetCommandInfoFromToken), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetCommandInfoFromToken), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetCommandInfoFromToken), uintptr(3896); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetCommandInfoFromToken), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetCommandInfoFromToken), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DbNewWideIntObj), uintptr(3904); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DbNewWideIntObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DbNewWideIntObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetWideIntFromObj), uintptr(3912); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetWideIntFromObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetWideIntFromObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_NewWideIntObj), uintptr(3920); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_NewWideIntObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_NewWideIntObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetWideIntObj), uintptr(3928); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetWideIntObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetWideIntObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AllocStatBuf), uintptr(3936); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AllocStatBuf), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AllocStatBuf), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Seek), uintptr(3944); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Seek), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Seek), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Tell), uintptr(3952); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Tell), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Tell), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ChannelWideSeekProc), uintptr(3960); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ChannelWideSeekProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ChannelWideSeekProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DictObjPut), uintptr(3968); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DictObjPut), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DictObjPut), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DictObjGet), uintptr(3976); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DictObjGet), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DictObjGet), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DictObjRemove), uintptr(3984); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DictObjRemove), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DictObjRemove), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DictObjSize), uintptr(3992); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DictObjSize), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DictObjSize), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DictObjFirst), uintptr(4000); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DictObjFirst), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DictObjFirst), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DictObjNext), uintptr(4008); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DictObjNext), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DictObjNext), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DictObjDone), uintptr(4016); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DictObjDone), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DictObjDone), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DictObjPutKeyList), uintptr(4024); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DictObjPutKeyList), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DictObjPutKeyList), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DictObjRemoveKeyList), uintptr(4032); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DictObjRemoveKeyList), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DictObjRemoveKeyList), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_NewDictObj), uintptr(4040); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_NewDictObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_NewDictObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DbNewDictObj), uintptr(4048); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DbNewDictObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DbNewDictObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_RegisterConfig), uintptr(4056); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_RegisterConfig), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_RegisterConfig), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CreateNamespace), uintptr(4064); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CreateNamespace), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CreateNamespace), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DeleteNamespace), uintptr(4072); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DeleteNamespace), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DeleteNamespace), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AppendExportList), uintptr(4080); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AppendExportList), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AppendExportList), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Export), uintptr(4088); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Export), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Export), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Import), uintptr(4096); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Import), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Import), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ForgetImport), uintptr(4104); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ForgetImport), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ForgetImport), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetCurrentNamespace), uintptr(4112); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetCurrentNamespace), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetCurrentNamespace), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetGlobalNamespace), uintptr(4120); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetGlobalNamespace), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetGlobalNamespace), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FindNamespace), uintptr(4128); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FindNamespace), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FindNamespace), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FindCommand), uintptr(4136); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FindCommand), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FindCommand), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetCommandFromObj), uintptr(4144); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetCommandFromObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetCommandFromObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetCommandFullName), uintptr(4152); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetCommandFullName), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetCommandFullName), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSEvalFileEx), uintptr(4160); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSEvalFileEx), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSEvalFileEx), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetExitProc), uintptr(4168); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetExitProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetExitProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_LimitAddHandler), uintptr(4176); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_LimitAddHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_LimitAddHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_LimitRemoveHandler), uintptr(4184); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_LimitRemoveHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_LimitRemoveHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_LimitReady), uintptr(4192); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_LimitReady), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_LimitReady), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_LimitCheck), uintptr(4200); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_LimitCheck), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_LimitCheck), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_LimitExceeded), uintptr(4208); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_LimitExceeded), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_LimitExceeded), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_LimitSetCommands), uintptr(4216); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_LimitSetCommands), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_LimitSetCommands), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_LimitSetTime), uintptr(4224); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_LimitSetTime), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_LimitSetTime), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_LimitSetGranularity), uintptr(4232); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_LimitSetGranularity), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_LimitSetGranularity), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_LimitTypeEnabled), uintptr(4240); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_LimitTypeEnabled), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_LimitTypeEnabled), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_LimitTypeExceeded), uintptr(4248); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_LimitTypeExceeded), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_LimitTypeExceeded), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_LimitTypeSet), uintptr(4256); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_LimitTypeSet), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_LimitTypeSet), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_LimitTypeReset), uintptr(4264); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_LimitTypeReset), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_LimitTypeReset), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_LimitGetCommands), uintptr(4272); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_LimitGetCommands), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_LimitGetCommands), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_LimitGetTime), uintptr(4280); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_LimitGetTime), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_LimitGetTime), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_LimitGetGranularity), uintptr(4288); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_LimitGetGranularity), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_LimitGetGranularity), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SaveInterpState), uintptr(4296); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SaveInterpState), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SaveInterpState), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_RestoreInterpState), uintptr(4304); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_RestoreInterpState), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_RestoreInterpState), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DiscardInterpState), uintptr(4312); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DiscardInterpState), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DiscardInterpState), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetReturnOptions), uintptr(4320); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetReturnOptions), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetReturnOptions), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetReturnOptions), uintptr(4328); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetReturnOptions), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetReturnOptions), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_IsEnsemble), uintptr(4336); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_IsEnsemble), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_IsEnsemble), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CreateEnsemble), uintptr(4344); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CreateEnsemble), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CreateEnsemble), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FindEnsemble), uintptr(4352); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FindEnsemble), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FindEnsemble), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetEnsembleSubcommandList), uintptr(4360); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetEnsembleSubcommandList), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetEnsembleSubcommandList), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetEnsembleMappingDict), uintptr(4368); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetEnsembleMappingDict), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetEnsembleMappingDict), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetEnsembleUnknownHandler), uintptr(4376); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetEnsembleUnknownHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetEnsembleUnknownHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetEnsembleFlags), uintptr(4384); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetEnsembleFlags), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetEnsembleFlags), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetEnsembleSubcommandList), uintptr(4392); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetEnsembleSubcommandList), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetEnsembleSubcommandList), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetEnsembleMappingDict), uintptr(4400); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetEnsembleMappingDict), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetEnsembleMappingDict), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetEnsembleUnknownHandler), uintptr(4408); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetEnsembleUnknownHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetEnsembleUnknownHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetEnsembleFlags), uintptr(4416); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetEnsembleFlags), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetEnsembleFlags), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetEnsembleNamespace), uintptr(4424); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetEnsembleNamespace), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetEnsembleNamespace), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetTimeProc), uintptr(4432); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetTimeProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetTimeProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_QueryTimeProc), uintptr(4440); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_QueryTimeProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_QueryTimeProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ChannelThreadActionProc), uintptr(4448); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ChannelThreadActionProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ChannelThreadActionProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_NewBignumObj), uintptr(4456); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_NewBignumObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_NewBignumObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_DbNewBignumObj), uintptr(4464); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_DbNewBignumObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_DbNewBignumObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetBignumObj), uintptr(4472); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetBignumObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetBignumObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetBignumFromObj), uintptr(4480); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetBignumFromObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetBignumFromObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_TakeBignumFromObj), uintptr(4488); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_TakeBignumFromObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_TakeBignumFromObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_TruncateChannel), uintptr(4496); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_TruncateChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_TruncateChannel), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ChannelTruncateProc), uintptr(4504); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ChannelTruncateProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ChannelTruncateProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetChannelErrorInterp), uintptr(4512); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetChannelErrorInterp), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetChannelErrorInterp), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetChannelErrorInterp), uintptr(4520); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetChannelErrorInterp), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetChannelErrorInterp), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetChannelError), uintptr(4528); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetChannelError), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetChannelError), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetChannelError), uintptr(4536); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetChannelError), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetChannelError), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_InitBignumFromDouble), uintptr(4544); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_InitBignumFromDouble), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_InitBignumFromDouble), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetNamespaceUnknownHandler), uintptr(4552); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetNamespaceUnknownHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetNamespaceUnknownHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetNamespaceUnknownHandler), uintptr(4560); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetNamespaceUnknownHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetNamespaceUnknownHandler), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetEncodingFromObj), uintptr(4568); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetEncodingFromObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetEncodingFromObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetEncodingSearchPath), uintptr(4576); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetEncodingSearchPath), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetEncodingSearchPath), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetEncodingSearchPath), uintptr(4584); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetEncodingSearchPath), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetEncodingSearchPath), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetEncodingNameFromEnvironment), uintptr(4592); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetEncodingNameFromEnvironment), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetEncodingNameFromEnvironment), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_PkgRequireProc), uintptr(4600); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_PkgRequireProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_PkgRequireProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AppendObjToErrorInfo), uintptr(4608); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AppendObjToErrorInfo), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AppendObjToErrorInfo), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AppendLimitedToObj), uintptr(4616); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AppendLimitedToObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AppendLimitedToObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Format), uintptr(4624); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Format), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Format), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AppendFormatToObj), uintptr(4632); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AppendFormatToObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AppendFormatToObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ObjPrintf), uintptr(4640); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ObjPrintf), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ObjPrintf), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_AppendPrintfToObj), uintptr(4648); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_AppendPrintfToObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_AppendPrintfToObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CancelEval), uintptr(4656); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CancelEval), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CancelEval), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_Canceled), uintptr(4664); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_Canceled), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_Canceled), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CreatePipe), uintptr(4672); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CreatePipe), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CreatePipe), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_NRCreateCommand), uintptr(4680); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_NRCreateCommand), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_NRCreateCommand), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_NREvalObj), uintptr(4688); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_NREvalObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_NREvalObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_NREvalObjv), uintptr(4696); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_NREvalObjv), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_NREvalObjv), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_NRCmdSwap), uintptr(4704); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_NRCmdSwap), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_NRCmdSwap), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_NRAddCallback), uintptr(4712); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_NRAddCallback), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_NRAddCallback), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_NRCallObjProc), uintptr(4720); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_NRCallObjProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_NRCallObjProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetFSDeviceFromStat), uintptr(4728); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetFSDeviceFromStat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetFSDeviceFromStat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetFSInodeFromStat), uintptr(4736); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetFSInodeFromStat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetFSInodeFromStat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetModeFromStat), uintptr(4744); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetModeFromStat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetModeFromStat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetLinkCountFromStat), uintptr(4752); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetLinkCountFromStat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetLinkCountFromStat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetUserIdFromStat), uintptr(4760); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetUserIdFromStat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetUserIdFromStat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetGroupIdFromStat), uintptr(4768); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetGroupIdFromStat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetGroupIdFromStat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetDeviceTypeFromStat), uintptr(4776); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetDeviceTypeFromStat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetDeviceTypeFromStat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetAccessTimeFromStat), uintptr(4784); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetAccessTimeFromStat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetAccessTimeFromStat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetModificationTimeFromStat), uintptr(4792); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetModificationTimeFromStat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetModificationTimeFromStat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetChangeTimeFromStat), uintptr(4800); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetChangeTimeFromStat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetChangeTimeFromStat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetSizeFromStat), uintptr(4808); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetSizeFromStat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetSizeFromStat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetBlocksFromStat), uintptr(4816); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetBlocksFromStat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetBlocksFromStat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetBlockSizeFromStat), uintptr(4824); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetBlockSizeFromStat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetBlockSizeFromStat), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetEnsembleParameterList), uintptr(4832); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetEnsembleParameterList), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetEnsembleParameterList), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetEnsembleParameterList), uintptr(4840); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetEnsembleParameterList), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetEnsembleParameterList), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ParseArgsObjv), uintptr(4848); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ParseArgsObjv), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ParseArgsObjv), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetErrorLine), uintptr(4856); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetErrorLine), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetErrorLine), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetErrorLine), uintptr(4864); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetErrorLine), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetErrorLine), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_TransferResult), uintptr(4872); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_TransferResult), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_TransferResult), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_InterpActive), uintptr(4880); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_InterpActive), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_InterpActive), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_BackgroundException), uintptr(4888); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_BackgroundException), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_BackgroundException), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ZlibDeflate), uintptr(4896); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ZlibDeflate), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ZlibDeflate), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ZlibInflate), uintptr(4904); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ZlibInflate), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ZlibInflate), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ZlibCRC32), uintptr(4912); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ZlibCRC32), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ZlibCRC32), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ZlibAdler32), uintptr(4920); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ZlibAdler32), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ZlibAdler32), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ZlibStreamInit), uintptr(4928); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ZlibStreamInit), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ZlibStreamInit), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ZlibStreamGetCommandName), uintptr(4936); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ZlibStreamGetCommandName), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ZlibStreamGetCommandName), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ZlibStreamEof), uintptr(4944); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ZlibStreamEof), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ZlibStreamEof), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ZlibStreamChecksum), uintptr(4952); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ZlibStreamChecksum), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ZlibStreamChecksum), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ZlibStreamPut), uintptr(4960); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ZlibStreamPut), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ZlibStreamPut), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ZlibStreamGet), uintptr(4968); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ZlibStreamGet), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ZlibStreamGet), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ZlibStreamClose), uintptr(4976); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ZlibStreamClose), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ZlibStreamClose), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ZlibStreamReset), uintptr(4984); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ZlibStreamReset), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ZlibStreamReset), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_SetStartupScript), uintptr(4992); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_SetStartupScript), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_SetStartupScript), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_GetStartupScript), uintptr(5000); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_GetStartupScript), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_GetStartupScript), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_CloseEx), uintptr(5008); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_CloseEx), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_CloseEx), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_NRExprObj), uintptr(5016); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_NRExprObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_NRExprObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_NRSubstObj), uintptr(5024); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_NRSubstObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_NRSubstObj), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_LoadFile), uintptr(5032); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_LoadFile), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_LoadFile), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FindSymbol), uintptr(5040); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FindSymbol), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FindSymbol), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_FSUnloadFile), uintptr(5048); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_FSUnloadFile), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_FSUnloadFile), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tcl_ZlibStreamSetCompressionDictionary), uintptr(5056); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tcl_ZlibStreamSetCompressionDictionary), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tcl_ZlibStreamSetCompressionDictionary), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.reserved631), uintptr(5064); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.reserved631), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.reserved631), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.reserved632), uintptr(5072); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.reserved632), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.reserved632), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.reserved633), uintptr(5080); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.reserved633), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.reserved633), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.reserved634), uintptr(5088); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.reserved634), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.reserved634), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.reserved635), uintptr(5096); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.reserved635), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.reserved635), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.reserved636), uintptr(5104); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.reserved636), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.reserved636), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.reserved637), uintptr(5112); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.reserved637), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.reserved637), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.reserved638), uintptr(5120); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.reserved638), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.reserved638), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.reserved639), uintptr(5128); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.reserved639), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.reserved639), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.reserved640), uintptr(5136); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.reserved640), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.reserved640), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.reserved641), uintptr(5144); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.reserved641), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.reserved641), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.reserved642), uintptr(5152); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.reserved642), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.reserved642), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.reserved643), uintptr(5160); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.reserved643), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.reserved643), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.reserved644), uintptr(5168); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.reserved644), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.reserved644), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.reserved645), uintptr(5176); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.reserved645), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.reserved645), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.reserved646), uintptr(5184); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.reserved646), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.reserved646), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.reserved647), uintptr(5192); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.reserved647), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.reserved647), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v14.tclUnusedStubEntry), uintptr(5200); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v14.tclUnusedStubEntry), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v14.tclUnusedStubEntry), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v15 struct {
		magic int32
		hooks uintptr
	}
	if g, e := unsafe.Sizeof(v15), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v15), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v15.magic), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v15.magic), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v15.magic), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v15.hooks), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v15.hooks), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v15.hooks), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v16 struct {
		name             uintptr
		freeIntRepProc   uintptr
		dupIntRepProc    uintptr
		updateStringProc uintptr
		setFromAnyProc   uintptr
	}
	if g, e := unsafe.Sizeof(v16), uintptr(40); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v16), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v16.name), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v16.name), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v16.name), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v16.freeIntRepProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v16.freeIntRepProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v16.freeIntRepProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v16.dupIntRepProc), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v16.dupIntRepProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v16.dupIntRepProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v16.updateStringProc), uintptr(24); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v16.updateStringProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v16.updateStringProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v16.setFromAnyProc), uintptr(32); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v16.setFromAnyProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v16.setFromAnyProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v17 struct {
		name       uintptr
		fullName   uintptr
		clientData ClientData
		deleteProc uintptr
		parentPtr  uintptr
	}
	if g, e := unsafe.Sizeof(v17), uintptr(40); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v17), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v17.name), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v17.name), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v17.name), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v17.fullName), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v17.fullName), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v17.fullName), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v17.clientData), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v17.clientData), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v17.clientData), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v17.deleteProc), uintptr(24); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v17.deleteProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v17.deleteProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v17.parentPtr), uintptr(32); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v17.parentPtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v17.parentPtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v18 struct {
		next          uintptr
		epoch         int32
		dictionaryPtr Tcl_Dict
	}
	if g, e := unsafe.Sizeof(v18), uintptr(24); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v18), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v18.next), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v18.next), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v18.next), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v18.epoch), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v18.epoch), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v18.epoch), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v18.dictionaryPtr), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v18.dictionaryPtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v18.dictionaryPtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v19 struct {
		nextPtr    uintptr
		tablePtr   uintptr
		hash       uintptr
		clientData ClientData
		key        struct{ oneWordValue uintptr }
	}
	if g, e := unsafe.Sizeof(v19), uintptr(40); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v19), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v19.nextPtr), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v19.nextPtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v19.nextPtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v19.tablePtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v19.tablePtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v19.tablePtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v19.hash), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v19.hash), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v19.hash), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v19.clientData), uintptr(24); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v19.clientData), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v19.clientData), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v19.key), uintptr(32); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v19.key), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v19.key), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v20 struct {
		nsPtr   uintptr
		dummy1  int32
		dummy2  int32
		dummy3  uintptr
		dummy4  uintptr
		dummy5  uintptr
		dummy6  int32
		dummy7  uintptr
		dummy8  uintptr
		dummy9  int32
		dummy10 uintptr
		dummy11 uintptr
		dummy12 uintptr
		dummy13 uintptr
	}
	if g, e := unsafe.Sizeof(v20), uintptr(104); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v20), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v20.nsPtr), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v20.nsPtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v20.nsPtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v20.dummy1), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v20.dummy1), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v20.dummy1), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v20.dummy2), uintptr(12); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v20.dummy2), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v20.dummy2), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v20.dummy3), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v20.dummy3), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v20.dummy3), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v20.dummy4), uintptr(24); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v20.dummy4), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v20.dummy4), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v20.dummy5), uintptr(32); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v20.dummy5), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v20.dummy5), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v20.dummy6), uintptr(40); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v20.dummy6), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v20.dummy6), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v20.dummy7), uintptr(48); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v20.dummy7), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v20.dummy7), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v20.dummy8), uintptr(56); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v20.dummy8), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v20.dummy8), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v20.dummy9), uintptr(64); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v20.dummy9), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v20.dummy9), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v20.dummy10), uintptr(72); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v20.dummy10), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v20.dummy10), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v20.dummy11), uintptr(80); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v20.dummy11), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v20.dummy11), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v20.dummy12), uintptr(88); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v20.dummy12), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v20.dummy12), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v20.dummy13), uintptr(96); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v20.dummy13), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v20.dummy13), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v21 struct {
		nsubs       int32
		matches     uintptr
		extendStart int64
		reserved    int64
	}
	if g, e := unsafe.Sizeof(v21), uintptr(32); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v21), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v21.nsubs), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v21.nsubs), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v21.nsubs), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v21.matches), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v21.matches), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v21.matches), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v21.extendStart), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v21.extendStart), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v21.extendStart), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v21.reserved), uintptr(24); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v21.reserved), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v21.reserved), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v22 struct{ oneWordValue uintptr }
	if g, e := unsafe.Sizeof(v22), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v22), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v22.oneWordValue), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v22.oneWordValue), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v22.oneWordValue), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v23 struct {
		proc    uintptr
		nextPtr uintptr
	}
	if g, e := unsafe.Sizeof(v23), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v23), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v23.proc), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v23.proc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v23.proc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v23.nextPtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v23.nextPtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v23.nextPtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v24 struct {
		refCount    int32
		bytes       uintptr
		length      int32
		typePtr     uintptr
		internalRep struct {
			longValue int64
			_         [8]byte
		}
	}
	if g, e := unsafe.Sizeof(v24), uintptr(48); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v24), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v24.refCount), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v24.refCount), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v24.refCount), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v24.bytes), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v24.bytes), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v24.bytes), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v24.length), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v24.length), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v24.length), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v24.typePtr), uintptr(24); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v24.typePtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v24.typePtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v24.internalRep), uintptr(32); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v24.internalRep), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v24.internalRep), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v25 struct {
		result       uintptr
		freeProc     uintptr
		objResultPtr uintptr
		appendResult uintptr
		appendAvl    int32
		appendUsed   int32
		resultSpace  [201]int8
		_            [7]byte
	}
	if g, e := unsafe.Sizeof(v25), uintptr(248); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v25), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v25.result), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v25.result), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v25.result), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v25.freeProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v25.freeProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v25.freeProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v25.objResultPtr), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v25.objResultPtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v25.objResultPtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v25.appendResult), uintptr(24); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v25.appendResult), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v25.appendResult), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v25.appendAvl), uintptr(32); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v25.appendAvl), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v25.appendAvl), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v25.appendUsed), uintptr(36); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v25.appendUsed), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v25.appendUsed), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v25.resultSpace), uintptr(40); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v25.resultSpace), uintptr(201); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v25.resultSpace), uintptr(1); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v26 struct {
		resultDontUse    uintptr
		freeProcDontUse  uintptr
		errorLineDontUse int32
		_                [4]byte
	}
	if g, e := unsafe.Sizeof(v26), uintptr(24); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v26), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v26.resultDontUse), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v26.resultDontUse), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v26.resultDontUse), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v26.freeProcDontUse), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v26.freeProcDontUse), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v26.freeProcDontUse), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v26.errorLineDontUse), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v26.errorLineDontUse), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v26.errorLineDontUse), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v27 struct {
		sec  int64
		usec int64
	}
	if g, e := unsafe.Sizeof(v27), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v27), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v27.sec), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v27.sec), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v27.sec), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v27.usec), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v27.usec), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v27.usec), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v28 struct {
		setTimerProc          uintptr
		waitForEventProc      uintptr
		createFileHandlerProc uintptr
		deleteFileHandlerProc uintptr
		initNotifierProc      uintptr
		finalizeNotifierProc  uintptr
		alertNotifierProc     uintptr
		serviceModeHookProc   uintptr
	}
	if g, e := unsafe.Sizeof(v28), uintptr(64); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v28), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v28.setTimerProc), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v28.setTimerProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v28.setTimerProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v28.waitForEventProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v28.waitForEventProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v28.waitForEventProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v28.createFileHandlerProc), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v28.createFileHandlerProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v28.createFileHandlerProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v28.deleteFileHandlerProc), uintptr(24); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v28.deleteFileHandlerProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v28.deleteFileHandlerProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v28.initNotifierProc), uintptr(32); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v28.initNotifierProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v28.initNotifierProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v28.finalizeNotifierProc), uintptr(40); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v28.finalizeNotifierProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v28.finalizeNotifierProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v28.alertNotifierProc), uintptr(48); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v28.alertNotifierProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v28.alertNotifierProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v28.serviceModeHookProc), uintptr(56); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v28.serviceModeHookProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v28.serviceModeHookProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v29 struct {
		start int64
		end   int64
	}
	if g, e := unsafe.Sizeof(v29), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v29), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v29.start), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v29.start), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v29.start), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v29.end), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v29.end), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v29.end), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v30 struct {
		string      uintptr
		length      int32
		spaceAvl    int32
		staticSpace [200]int8
	}
	if g, e := unsafe.Sizeof(v30), uintptr(216); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v30), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v30.string), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v30.string), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v30.string), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v30.length), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v30.length), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v30.length), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v30.spaceAvl), uintptr(12); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v30.spaceAvl), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v30.spaceAvl), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v30.staticSpace), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v30.staticSpace), uintptr(200); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v30.staticSpace), uintptr(1); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v31 struct {
		tablePtr     uintptr
		nextIndex    int32
		nextEntryPtr uintptr
	}
	if g, e := unsafe.Sizeof(v31), uintptr(24); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v31), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v31.tablePtr), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v31.tablePtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v31.tablePtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v31.nextIndex), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v31.nextIndex), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v31.nextIndex), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v31.nextEntryPtr), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v31.nextEntryPtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v31.nextEntryPtr), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v32 struct {
		tclPlatStubs    uintptr
		tclIntStubs     uintptr
		tclIntPlatStubs uintptr
	}
	if g, e := unsafe.Sizeof(v32), uintptr(24); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v32), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v32.tclPlatStubs), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v32.tclPlatStubs), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v32.tclPlatStubs), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v32.tclIntStubs), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v32.tclIntStubs), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v32.tclIntStubs), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v32.tclIntPlatStubs), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v32.tclIntPlatStubs), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v32.tclIntPlatStubs), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v33 struct {
		typeName                 uintptr
		structureLength          int32
		version                  Tcl_FSVersion
		pathInFilesystemProc     uintptr
		dupInternalRepProc       uintptr
		freeInternalRepProc      uintptr
		internalToNormalizedProc uintptr
		createInternalRepProc    uintptr
		normalizePathProc        uintptr
		filesystemPathTypeProc   uintptr
		filesystemSeparatorProc  uintptr
		statProc                 uintptr
		accessProc               uintptr
		openFileChannelProc      uintptr
		matchInDirectoryProc     uintptr
		utimeProc                uintptr
		linkProc                 uintptr
		listVolumesProc          uintptr
		fileAttrStringsProc      uintptr
		fileAttrsGetProc         uintptr
		fileAttrsSetProc         uintptr
		createDirectoryProc      uintptr
		removeDirectoryProc      uintptr
		deleteFileProc           uintptr
		copyFileProc             uintptr
		renameFileProc           uintptr
		copyDirectoryProc        uintptr
		lstatProc                uintptr
		loadFileProc             uintptr
		getCwdProc               uintptr
		chdirProc                uintptr
	}
	if g, e := unsafe.Sizeof(v33), uintptr(248); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.typeName), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.typeName), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.typeName), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.structureLength), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.structureLength), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.structureLength), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.version), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.version), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.version), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.pathInFilesystemProc), uintptr(24); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.pathInFilesystemProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.pathInFilesystemProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.dupInternalRepProc), uintptr(32); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.dupInternalRepProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.dupInternalRepProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.freeInternalRepProc), uintptr(40); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.freeInternalRepProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.freeInternalRepProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.internalToNormalizedProc), uintptr(48); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.internalToNormalizedProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.internalToNormalizedProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.createInternalRepProc), uintptr(56); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.createInternalRepProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.createInternalRepProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.normalizePathProc), uintptr(64); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.normalizePathProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.normalizePathProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.filesystemPathTypeProc), uintptr(72); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.filesystemPathTypeProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.filesystemPathTypeProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.filesystemSeparatorProc), uintptr(80); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.filesystemSeparatorProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.filesystemSeparatorProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.statProc), uintptr(88); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.statProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.statProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.accessProc), uintptr(96); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.accessProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.accessProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.openFileChannelProc), uintptr(104); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.openFileChannelProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.openFileChannelProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.matchInDirectoryProc), uintptr(112); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.matchInDirectoryProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.matchInDirectoryProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.utimeProc), uintptr(120); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.utimeProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.utimeProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.linkProc), uintptr(128); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.linkProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.linkProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.listVolumesProc), uintptr(136); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.listVolumesProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.listVolumesProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.fileAttrStringsProc), uintptr(144); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.fileAttrStringsProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.fileAttrStringsProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.fileAttrsGetProc), uintptr(152); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.fileAttrsGetProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.fileAttrsGetProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.fileAttrsSetProc), uintptr(160); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.fileAttrsSetProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.fileAttrsSetProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.createDirectoryProc), uintptr(168); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.createDirectoryProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.createDirectoryProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.removeDirectoryProc), uintptr(176); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.removeDirectoryProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.removeDirectoryProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.deleteFileProc), uintptr(184); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.deleteFileProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.deleteFileProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.copyFileProc), uintptr(192); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.copyFileProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.copyFileProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.renameFileProc), uintptr(200); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.renameFileProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.renameFileProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.copyDirectoryProc), uintptr(208); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.copyDirectoryProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.copyDirectoryProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.lstatProc), uintptr(216); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.lstatProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.lstatProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.loadFileProc), uintptr(224); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.loadFileProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.loadFileProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.getCwdProc), uintptr(232); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.getCwdProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.getCwdProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v33.chdirProc), uintptr(240); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v33.chdirProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v33.chdirProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v34 struct {
		typeName         uintptr
		version          Tcl_ChannelTypeVersion
		closeProc        uintptr
		inputProc        uintptr
		outputProc       uintptr
		seekProc         uintptr
		setOptionProc    uintptr
		getOptionProc    uintptr
		watchProc        uintptr
		getHandleProc    uintptr
		close2Proc       uintptr
		blockModeProc    uintptr
		flushProc        uintptr
		handlerProc      uintptr
		wideSeekProc     uintptr
		threadActionProc uintptr
		truncateProc     uintptr
	}
	if g, e := unsafe.Sizeof(v34), uintptr(136); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v34), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v34.typeName), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v34.typeName), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v34.typeName), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v34.version), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v34.version), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v34.version), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v34.closeProc), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v34.closeProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v34.closeProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v34.inputProc), uintptr(24); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v34.inputProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v34.inputProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v34.outputProc), uintptr(32); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v34.outputProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v34.outputProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v34.seekProc), uintptr(40); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v34.seekProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v34.seekProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v34.setOptionProc), uintptr(48); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v34.setOptionProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v34.setOptionProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v34.getOptionProc), uintptr(56); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v34.getOptionProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v34.getOptionProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v34.watchProc), uintptr(64); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v34.watchProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v34.watchProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v34.getHandleProc), uintptr(72); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v34.getHandleProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v34.getHandleProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v34.close2Proc), uintptr(80); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v34.close2Proc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v34.close2Proc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v34.blockModeProc), uintptr(88); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v34.blockModeProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v34.blockModeProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v34.flushProc), uintptr(96); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v34.flushProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v34.flushProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v34.handlerProc), uintptr(104); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v34.handlerProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v34.handlerProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v34.wideSeekProc), uintptr(112); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v34.wideSeekProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v34.wideSeekProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v34.threadActionProc), uintptr(120); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v34.threadActionProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v34.threadActionProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v34.truncateProc), uintptr(128); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v34.truncateProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v34.truncateProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	var v35 struct {
		version         int32
		flags           int32
		hashKeyProc     uintptr
		compareKeysProc uintptr
		allocEntryProc  uintptr
		freeEntryProc   uintptr
	}
	if g, e := unsafe.Sizeof(v35), uintptr(40); g != e {
		panic(fmt.Sprintf(`invalid struct/union size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v35), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union alignment, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v35.version), uintptr(0); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v35.version), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v35.version), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v35.flags), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v35.flags), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v35.flags), uintptr(4); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v35.hashKeyProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v35.hashKeyProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v35.hashKeyProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v35.compareKeysProc), uintptr(16); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v35.compareKeysProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v35.compareKeysProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v35.allocEntryProc), uintptr(24); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v35.allocEntryProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v35.allocEntryProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Offsetof(v35.freeEntryProc), uintptr(32); g != e {
		panic(fmt.Sprintf(`invalid struct/union field offset, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Sizeof(v35.freeEntryProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
	if g, e := unsafe.Alignof(v35.freeEntryProc), uintptr(8); g != e {
		panic(fmt.Sprintf(`invalid struct/union field size, got %v, expected %v`, g, e))
	}
}
