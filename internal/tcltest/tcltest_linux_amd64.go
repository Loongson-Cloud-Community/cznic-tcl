// Code generated by 'ccgo -o /home/jnml/src/modernc.org/tcl/internal/tcltest/tcltest_linux_amd64.go -ccgo-long-double-is-double -ccgo-pkgname tcltest ../generic/tclOOStubLib.c ../generic/tclStubLib.c ../generic/tclTomMathStubLib.c -lmodernc.org/tcl/lib -DBUILD_tcl -I. -I/home/jnml/src/modernc.org/tcl/testdata/tcl8.6.10/unix -I/home/jnml/src/modernc.org/tcl/testdata/tcl8.6.10/generic -I/home/jnml/src/modernc.org/tcl/testdata/tcl8.6.10/libtommath -DPACKAGE_NAME="tcl" -DPACKAGE_TARNAME="tcl" -DPACKAGE_VERSION="8.6" -DPACKAGE_STRING="tcl 8.6" -DPACKAGE_BUGREPORT="" -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_SYS_PARAM_H=1 -DTCL_CFGVAL_ENCODING="iso8859-1" -DHAVE_ZLIB=1 -DMODULE_SCOPE=extern __attribute__((__visibility__("hidden"))) -DHAVE_HIDDEN=1 -DHAVE_CAST_TO_UNION=1 -DTCL_SHLIB_EXT="" -DTCL_CFG_OPTIMIZED=1 -DTCL_TOMMATH=1 -DMP_PREC=4 -D_LARGEFILE64_SOURCE=1 -DTCL_WIDE_INT_IS_LONG=1 -DHAVE_GETCWD=1 -DHAVE_MKSTEMP=1 -DHAVE_OPENDIR=1 -DHAVE_STRTOL=1 -DHAVE_WAITPID=1 -DHAVE_GETNAMEINFO=1 -DHAVE_GETADDRINFO=1 -DHAVE_FREEADDRINFO=1 -DHAVE_GAI_STRERROR=1 -DHAVE_STRUCT_ADDRINFO=1 -DHAVE_STRUCT_IN6_ADDR=1 -DHAVE_STRUCT_SOCKADDR_IN6=1 -DHAVE_STRUCT_SOCKADDR_STORAGE=1 -DHAVE_TERMIOS_H=1 -DHAVE_SYS_IOCTL_H=1 -DHAVE_SYS_TIME_H=1 -DTIME_WITH_SYS_TIME=1 -DHAVE_GMTIME_R=1 -DHAVE_LOCALTIME_R=1 -DHAVE_MKTIME=1 -DHAVE_TM_GMTOFF=1 -DHAVE_TIMEZONE_VAR=1 -DHAVE_STRUCT_STAT_ST_BLOCKS=1 -DHAVE_STRUCT_STAT_ST_BLKSIZE=1 -DHAVE_BLKCNT_T=1 -DHAVE_INTPTR_T=1 -DHAVE_UINTPTR_T=1 -DNO_UNION_WAIT=1 -DHAVE_SIGNED_CHAR=1 -DHAVE_LANGINFO=1 -DHAVE_MKSTEMPS=1 -DHAVE_FTS=1 -DTCL_UNLOAD_DLLS=1 -DMP_FIXED_CUTOFFS -DMP_NO_STDINT -DTCL_BUILDTIME_LIBRARY="/home/jnml/src/modernc.org/tcl/testdata/tcl8.6.10/library" -DTCL_TEST /home/jnml/src/modernc.org/tcl/testdata/tcl8.6.10/unix/tclAppInit.c /home/jnml/src/modernc.org/tcl/testdata/tcl8.6.10/generic/tclTest.c /home/jnml/src/modernc.org/tcl/testdata/tcl8.6.10/generic/tclTestObj.c /home/jnml/src/modernc.org/tcl/testdata/tcl8.6.10/generic/tclTestProcBodyObj.c /home/jnml/src/modernc.org/tcl/testdata/tcl8.6.10/generic/tclThreadTest.c /home/jnml/src/modernc.org/tcl/testdata/tcl8.6.10/unix/tclUnixTest.c', DO NOT EDIT.

package tcltest

import (
	"math"
	"reflect"
	"unsafe"

	"modernc.org/crt/v3"
	"modernc.org/tcl/lib"
)

var _ = math.Pi
var _ reflect.Kind
var _ unsafe.Pointer

type ptrdiff_t = int64 /* <builtin>:3:26 */

type size_t = uint64 /* <builtin>:9:23 */

type wchar_t = int32 /* <builtin>:15:24 */

// Include generic Linux declarations.
// O_*, F_*, FD_* bit values for Linux.
//   Copyright (C) 2001-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// This file contains shared definitions between Linux architectures
//   and is included by <bits/fcntl.h> to declare them.  The various
//   #ifndef cases allow the architecture specific file to define those
//   values with different values.
//
//   A minimal <bits/fcntl.h> contains just:
//
//   struct flock {...}
//   #ifdef __USE_LARGEFILE64
//   struct flock64 {...}
//   #endif
//   #include <bits/fcntl-linux.h>

// open/fcntl.

// open file description locks.
//
//   Usually record locks held by a process are released on *any* close and are
//   not inherited across a fork.
//
//   These cmd values will set locks that conflict with process-associated record
//   locks, but are "owned" by the opened file description, not the process.
//   This means that they are inherited across fork or clone with CLONE_FILES
//   like BSD (flock) locks, and they are only released automatically when the
//   last reference to the the file description against which they were acquired
//   is put.

// For now, Linux has no separate synchronicity options for read
//   operations.  We define O_RSYNC therefore as the same as O_SYNC
//   since this is a superset.

// Values for the second argument to `fcntl'.

// For F_[GET|SET]FD.

// For posix fcntl() and `l_type' field of a `struct flock' for lockf().

// For old implementation of BSD flock.

// Operations for BSD flock, also used by the kernel implementation.

// Define some more compatibility macros to be backward compatible with
//   BSD systems which did not managed to hide these kernel macros.

// Advise to `posix_fadvise'.

// Values for `*at' functions.

// Detect if open needs mode as a third argument (or for openat as a fourth
//   argument).

// POSIX.1-2001 specifies that these types are defined by <fcntl.h>.
//   Earlier POSIX standards permitted any type ending in `_t' to be defined
//   by any POSIX header, so we don't conditionalize the definitions here.
type mode_t = uint32 /* fcntl.h:50:18 */

type off_t = int64 /* fcntl.h:56:17 */

type off64_t = int64 /* fcntl.h:64:19 */

type pid_t = int32 /* fcntl.h:69:17 */

// For XPG all symbols from <sys/stat.h> should also be available.
// NB: Include guard matches what <linux/time.h> uses.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// POSIX.1b structure for a time value.  This is like a `struct timeval' but
//   has nanoseconds instead of microseconds.
type timespec = struct {
	tv_sec  int64
	tv_nsec int64
}

// Copyright (C) 1999-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Versions of the `struct stat' data structure.

// x86-64 versions of the `xmknod' interface.

type stat = struct {
	st_dev     uint64
	st_ino     uint64
	st_nlink   uint64
	st_mode    uint32
	st_uid     uint32
	st_gid     uint32
	__pad0     int32
	st_rdev    uint64
	st_size    int64
	st_blksize int64
	st_blocks  int64
	st_atim    struct {
		tv_sec  int64
		tv_nsec int64
	}
	st_mtim struct {
		tv_sec  int64
		tv_nsec int64
	}
	st_ctim struct {
		tv_sec  int64
		tv_nsec int64
	}
	__glibc_reserved [3]int64
}

// Wide character type.
//   Locale-writers should change this as necessary to
//   be big enough to hold unique values not between 0 and 127,
//   and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//    are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// The Single Unix specification says that some more types are
//   available here.
type gid_t = uint32 /* pwd.h:38:17 */

type uid_t = uint32 /* pwd.h:43:17 */

type _IO_FILE = struct {
	_flags          int32
	_IO_read_ptr    uintptr
	_IO_read_end    uintptr
	_IO_read_base   uintptr
	_IO_write_base  uintptr
	_IO_write_ptr   uintptr
	_IO_write_end   uintptr
	_IO_buf_base    uintptr
	_IO_buf_end     uintptr
	_IO_save_base   uintptr
	_IO_backup_base uintptr
	_IO_save_end    uintptr
	_markers        uintptr
	_chain          uintptr
	_fileno         int32
	_flags2         int32
	_old_offset     int64
	_cur_column     uint16
	_vtable_offset  int8
	_shortbuf       [1]int8
	_lock           uintptr
	_offset         int64
	_codecvt        uintptr
	_wide_data      uintptr
	_freeres_list   uintptr
	_freeres_buf    uintptr
	__pad5          size_t
	_mode           int32
	_unused2        [20]int8
}

// The opaque type of streams.  This is the definition used elsewhere.
type FILE = _IO_FILE /* FILE.h:7:25 */

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.14 Signal handling <signal.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Signal number definitions.  Linux version.
//   Copyright (C) 1995-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Signal number constants.  Generic template.
//   Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Fake signal functions.

// We define here all the signal names listed in POSIX (1003.1-2008);
//   as of 1003.1-2013, no additional signals have been added by POSIX.
//   We also define here signal names that historically exist in every
//   real-world POSIX variant (e.g. SIGWINCH).
//
//   Signals in the 1-15 range are defined with their historical numbers.
//   For other signals, we use the BSD numbers.
//   There are two unallocated signal numbers in the 1-31 range: 7 and 29.
//   Signal number 0 is reserved for use as kill(pid, 0), to test whether
//   a process exists without sending it a signal.

// ISO C99 signals.

// Historical signals specified by POSIX.

// New(er) POSIX signals (1003.1-2008, 1003.1-2013).

// Nonstandard signals found in all modern POSIX systems
//   (including both BSD and Linux).

// Archaic names for compatibility.

// Not all systems support real-time signals.  bits/signum.h indicates
//   that they are supported by overriding __SIGRTMAX to a value greater
//   than __SIGRTMIN.  These constants give the kernel-level hard limits,
//   but some real-time signals may be used internally by glibc.  Do not
//   use these constants in application code; use SIGRTMIN and SIGRTMAX
//   (defined in signal.h) instead.

// Biggest signal number + 1 (including real-time signals).

// Adjustments and additions to the signal number constants for
//   most Linux systems.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// An integral type that can be modified atomically, without the
//   possibility of a signal arriving in the middle of the operation.
type sig_atomic_t = int32 /* sig_atomic_t.h:8:24 */

// A set of signals to be blocked, unblocked, or waited for.
type sigset_t = struct{ __val [16]uint64 } /* sigset_t.h:7:20 */

// We need `struct timespec' later on.
// NB: Include guard matches what <linux/time.h> uses.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Define __sigval_t.
//   Copyright (C) 1997-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Type for data associated with a signal.
type sigval = struct {
	sival_int int32
	_         [4]byte
}

// Some fields of siginfo_t have architecture-specific variations.
// Architecture-specific adjustments to siginfo_t.  x86 version.

type siginfo_t = struct {
	si_signo  int32
	si_errno  int32
	si_code   int32
	__pad0    int32
	_sifields struct{ _pad [28]int32 }
} /* siginfo_t.h:124:5 */

// Architectures might also add architecture-specific constants.
//   These are all considered GNU extensions.

// Define __sigval_t.
//   Copyright (C) 1997-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// To avoid sigval_t (not a standard type name) having C++ name
//   mangling depending on whether the selected standard includes union
//   sigval, it should not be defined at all when using a standard for
//   which the sigval name is not reserved; in that case, headers should
//   not include <bits/types/sigval_t.h> and should use only the
//   internal __sigval_t name.

type sigval_t = sigval /* sigval_t.h:16:20 */

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Define __sigval_t.
//   Copyright (C) 1997-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Forward declaration.
type pthread_attr_t1 = struct{ __size [56]int8 }

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Define __sigval_t.
//   Copyright (C) 1997-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Forward declaration.
type pthread_attr_t = pthread_attr_t1 /* sigevent_t.h:17:30 */

// Structure to transport application-defined values with signals.
type sigevent = struct {
	sigev_value struct {
		sival_int int32
		_         [4]byte
	}
	sigev_signo  int32
	sigev_notify int32
	_sigev_un    struct{ _pad [12]int32 }
}

// Structure to transport application-defined values with signals.
type sigevent_t = sigevent /* sigevent_t.h:42:5 */

// 4.4 BSD uses the name `sig_t' for this.
type sig_t = uintptr /* signal.h:190:24 */

// Get the system-specific definitions of `struct sigaction'
//   and the `SA_*' and `SIG_*'. constants.
// The proper definitions for Linux's sigaction.
//   Copyright (C) 1993-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Structure describing the action to be taken when a signal arrives.
type sigaction = struct {
	__sigaction_handler struct{ sa_handler uintptr }
	sa_mask             struct{ __val [16]uint64 }
	sa_flags            int32
	sa_restorer         uintptr
}

type _fpxreg = struct {
	significand       [4]uint16
	exponent          uint16
	__glibc_reserved1 [3]uint16
}

type _xmmreg = struct{ element [4]uint32 }

type _fpstate = struct {
	cwd       uint16
	swd       uint16
	ftw       uint16
	fop       uint16
	rip       uint64
	rdp       uint64
	mxcsr     uint32
	mxcr_mask uint32
	_st       [8]struct {
		significand       [4]uint16
		exponent          uint16
		__glibc_reserved1 [3]uint16
	}
	_xmm              [16]struct{ element [4]uint32 }
	__glibc_reserved1 [24]uint32
}

type _xsave_hdr = struct {
	xstate_bv         uint64
	__glibc_reserved1 [2]uint64
	__glibc_reserved2 [5]uint64
}

type _ymmh_state = struct{ ymmh_space [64]uint32 }

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
//This file is part of GCC.
//
//GCC is free software; you can redistribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation; either version 3, or (at your option)
//any later version.
//
//GCC is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//Under Section 7 of GPL version 3, you are granted additional
//permissions described in the GCC Runtime Library Exception, version
//3.1, as published by the Free Software Foundation.
//
//You should have received a copy of the GNU General Public License and
//a copy of the GCC Runtime Library Exception along with this program;
//see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
//<http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//   wants us just to define one data type.  So don't define
//   the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//   There's no way to win with the other order!  Sun lossage.

// On 4.3bsd-net2, make sure ansi.h is included, so we have
//   one less case to deal with in the following.
// On FreeBSD 5, machine/ansi.h does not exist anymore...

// In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
//   defined if the corresponding type is *not* defined.
//   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
//   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//   Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//   _TYPE_size_t which will typedef size_t.  fixincludes patched the
//   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//   not defined, and so that defining this macro defines _GCC_SIZE_T.
//   If we find that the macros are still defined at this point, we must
//   invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//   __WCHAR_TYPE__ have reasonable values.  This can happen if the
//   parts of GCC is compiled by an older compiler, that actually
//   include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

// Wide character type.
//   Locale-writers should change this as necessary to
//   be big enough to hold unique values not between 0 and 127,
//   and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//    are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// Define stack_t.  Linux version.
//   Copyright (C) 1998-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
//This file is part of GCC.
//
//GCC is free software; you can redistribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation; either version 3, or (at your option)
//any later version.
//
//GCC is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//Under Section 7 of GPL version 3, you are granted additional
//permissions described in the GCC Runtime Library Exception, version
//3.1, as published by the Free Software Foundation.
//
//You should have received a copy of the GNU General Public License and
//a copy of the GCC Runtime Library Exception along with this program;
//see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
//<http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//   wants us just to define one data type.  So don't define
//   the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//   There's no way to win with the other order!  Sun lossage.

// On 4.3bsd-net2, make sure ansi.h is included, so we have
//   one less case to deal with in the following.
// On FreeBSD 5, machine/ansi.h does not exist anymore...

// In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
//   defined if the corresponding type is *not* defined.
//   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
//   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//   Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//   _TYPE_size_t which will typedef size_t.  fixincludes patched the
//   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//   not defined, and so that defining this macro defines _GCC_SIZE_T.
//   If we find that the macros are still defined at this point, we must
//   invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//   __WCHAR_TYPE__ have reasonable values.  This can happen if the
//   parts of GCC is compiled by an older compiler, that actually
//   include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

// Wide character type.
//   Locale-writers should change this as necessary to
//   be big enough to hold unique values not between 0 and 127,
//   and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//    are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// Structure describing a signal stack.
type stack_t = struct {
	ss_sp    uintptr
	ss_flags int32
	ss_size  size_t
} /* stack_t.h:31:5 */

// This will define `ucontext_t' and `mcontext_t'.
// Copyright (C) 2001-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Define stack_t.  Linux version.
//   Copyright (C) 1998-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Type for general register.
type greg_t = int64 /* ucontext.h:37:37 */

// Number of general registers.

// Container for all general registers.
type gregset_t = [23]greg_t /* ucontext.h:46:16 */

type _libc_fpxreg = struct {
	significand       [4]uint16
	exponent          uint16
	__glibc_reserved1 [3]uint16
}

type _libc_xmmreg = struct{ element [4]uint32 }

type _libc_fpstate = struct {
	cwd       uint16
	swd       uint16
	ftw       uint16
	fop       uint16
	rip       uint64
	rdp       uint64
	mxcsr     uint32
	mxcr_mask uint32
	_st       [8]struct {
		significand       [4]uint16
		exponent          uint16
		__glibc_reserved1 [3]uint16
	}
	_xmm              [16]struct{ element [4]uint32 }
	__glibc_reserved1 [24]uint32
}

// Structure to describe FPU registers.
type fpregset_t = uintptr /* ucontext.h:130:30 */

// Context to describe whole processor state.
type mcontext_t = struct {
	gregs       gregset_t
	fpregs      fpregset_t
	__reserved1 [8]uint64
} /* ucontext.h:139:3 */

// Userlevel context.
type ucontext_t1 = struct {
	uc_flags     uint64
	uc_link      uintptr
	uc_stack     stack_t
	uc_mcontext  mcontext_t
	uc_sigmask   sigset_t
	__fpregs_mem struct {
		cwd       uint16
		swd       uint16
		ftw       uint16
		fop       uint16
		rip       uint64
		rdp       uint64
		mxcsr     uint32
		mxcr_mask uint32
		_st       [8]struct {
			significand       [4]uint16
			exponent          uint16
			__glibc_reserved1 [3]uint16
		}
		_xmm              [16]struct{ element [4]uint32 }
		__glibc_reserved1 [24]uint32
	}
	__ssp [4]uint64
}

// Userlevel context.
type ucontext_t = ucontext_t1 /* ucontext.h:151:5 */

// Thread identifiers.  The structure of the attribute type is not
//   exposed on purpose.
type pthread_t = uint64 /* pthreadtypes.h:27:27 */

// Data structures for mutex handling.  The structure of the attribute
//   type is not exposed on purpose.
type pthread_mutexattr_t = struct{ __size [4]int8 } /* pthreadtypes.h:36:3 */

// Data structure for condition variable handling.  The structure of
//   the attribute type is not exposed on purpose.
type pthread_condattr_t = struct{ __size [4]int8 } /* pthreadtypes.h:45:3 */

// Keys for thread-specific data
type pthread_key_t = uint32 /* pthreadtypes.h:49:22 */

// Once-only execution
type pthread_once_t = int32 /* pthreadtypes.h:53:30 */

type pthread_mutex_t = struct {
	__data struct {
		__lock    int32
		__count   uint32
		__owner   int32
		__nusers  uint32
		__kind    int32
		__spins   int16
		__elision int16
		__list    struct {
			__prev uintptr
			__next uintptr
		}
	}
} /* pthreadtypes.h:72:3 */

type pthread_cond_t = struct {
	__data struct {
		__0            struct{ __wseq uint64 }
		__8            struct{ __g1_start uint64 }
		__g_refs       [2]uint32
		__g_size       [2]uint32
		__g1_orig_size uint32
		__wrefs        uint32
		__g_signals    [2]uint32
	}
} /* pthreadtypes.h:80:3 */

// Data structure for reader-writer lock variable handling.  The
//   structure of the attribute type is deliberately not exposed.
type pthread_rwlock_t = struct {
	__data struct {
		__readers       uint32
		__writers       uint32
		__wrphase_futex uint32
		__writers_futex uint32
		__pad3          uint32
		__pad4          uint32
		__cur_writer    int32
		__shared        int32
		__rwelision     int8
		__pad1          [7]uint8
		__pad2          uint64
		__flags         uint32
		_               [4]byte
	}
} /* pthreadtypes.h:91:3 */

type pthread_rwlockattr_t = struct{ __size [8]int8 } /* pthreadtypes.h:97:3 */

// POSIX spinlock data type.
type pthread_spinlock_t = int32 /* pthreadtypes.h:103:22 */

// POSIX barriers data type.  The structure of the type is
//   deliberately not exposed.
type pthread_barrier_t = struct{ __size [32]int8 } /* pthreadtypes.h:112:3 */

type pthread_barrierattr_t = struct{ __size [4]int8 } /* pthreadtypes.h:118:3 */

// Compatibility header for old-style Unix parameters and limits.
//   Copyright (C) 1995-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
//This file is part of GCC.
//
//GCC is free software; you can redistribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation; either version 3, or (at your option)
//any later version.
//
//GCC is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//Under Section 7 of GPL version 3, you are granted additional
//permissions described in the GCC Runtime Library Exception, version
//3.1, as published by the Free Software Foundation.
//
//You should have received a copy of the GNU General Public License and
//a copy of the GCC Runtime Library Exception along with this program;
//see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
//<http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//   wants us just to define one data type.  So don't define
//   the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//   There's no way to win with the other order!  Sun lossage.

// On 4.3bsd-net2, make sure ansi.h is included, so we have
//   one less case to deal with in the following.
// On FreeBSD 5, machine/ansi.h does not exist anymore...

// In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
//   defined if the corresponding type is *not* defined.
//   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
//   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//   Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//   _TYPE_size_t which will typedef size_t.  fixincludes patched the
//   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//   not defined, and so that defining this macro defines _GCC_SIZE_T.
//   If we find that the macros are still defined at this point, we must
//   invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//   __WCHAR_TYPE__ have reasonable values.  This can happen if the
//   parts of GCC is compiled by an older compiler, that actually
//   include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

// Wide character type.
//   Locale-writers should change this as necessary to
//   be big enough to hold unique values not between 0 and 127,
//   and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//    are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type u_char = uint8                    /* types.h:33:18 */
type u_short = uint16                  /* types.h:34:19 */
type u_int = uint32                    /* types.h:35:17 */
type u_long = uint64                   /* types.h:36:18 */
type quad_t = int64                    /* types.h:37:18 */
type u_quad_t = uint64                 /* types.h:38:20 */
type fsid_t = struct{ __val [2]int32 } /* types.h:39:18 */
type loff_t = int64                    /* types.h:42:18 */

type ino_t = uint64   /* types.h:47:17 */
type ino64_t = uint64 /* types.h:54:19 */

type dev_t = uint64 /* types.h:59:17 */

type nlink_t = uint64 /* types.h:74:19 */

type id_t = uint32 /* types.h:103:16 */

type ssize_t = int64 /* types.h:108:19 */

type daddr_t = int32   /* types.h:114:19 */
type caddr_t = uintptr /* types.h:115:19 */

type key_t = int32 /* types.h:121:17 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Returned by `clock'.
type clock_t = int64 /* clock_t.h:7:19 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Clock ID used in clock and timer functions.
type clockid_t = int32 /* clockid_t.h:7:21 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Returned by `time'.
type time_t = int64 /* time_t.h:7:18 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Timer ID returned by `timer_create'.
type timer_t = uintptr /* timer_t.h:7:19 */

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
//This file is part of GCC.
//
//GCC is free software; you can redistribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation; either version 3, or (at your option)
//any later version.
//
//GCC is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//Under Section 7 of GPL version 3, you are granted additional
//permissions described in the GCC Runtime Library Exception, version
//3.1, as published by the Free Software Foundation.
//
//You should have received a copy of the GNU General Public License and
//a copy of the GCC Runtime Library Exception along with this program;
//see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
//<http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//   wants us just to define one data type.  So don't define
//   the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//   There's no way to win with the other order!  Sun lossage.

// On 4.3bsd-net2, make sure ansi.h is included, so we have
//   one less case to deal with in the following.
// On FreeBSD 5, machine/ansi.h does not exist anymore...

// In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
//   defined if the corresponding type is *not* defined.
//   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
//   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//   Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//   _TYPE_size_t which will typedef size_t.  fixincludes patched the
//   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//   not defined, and so that defining this macro defines _GCC_SIZE_T.
//   If we find that the macros are still defined at this point, we must
//   invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//   __WCHAR_TYPE__ have reasonable values.  This can happen if the
//   parts of GCC is compiled by an older compiler, that actually
//   include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

// Wide character type.
//   Locale-writers should change this as necessary to
//   be big enough to hold unique values not between 0 and 127,
//   and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//    are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// Old compatibility names for C types.
type ulong = uint64  /* types.h:148:27 */
type ushort = uint16 /* types.h:149:28 */
type uint = uint32   /* types.h:150:22 */

// These size-specific names are used by some of the inet code.

// Define intN_t types.
//   Copyright (C) 2017-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type int8_t = int8   /* stdint-intn.h:24:18 */
type int16_t = int16 /* stdint-intn.h:25:19 */
type int32_t = int32 /* stdint-intn.h:26:19 */
type int64_t = int64 /* stdint-intn.h:27:19 */

// These were defined by ISO C without the first `_'.
type u_int8_t = uint8   /* types.h:160:23 */
type u_int16_t = uint16 /* types.h:161:28 */
type u_int32_t = uint32 /* types.h:162:22 */
type u_int64_t = uint64 /* types.h:164:27 */

type register_t = int32 /* types.h:169:13 */

// It also defines `fd_set' and the FD_* macros for `select'.
// `fd_set' type and related macros, and `select'/`pselect' declarations.
//   Copyright (C) 1996-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	POSIX 1003.1g: 6.2 Select from File Descriptor Sets <sys/select.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Get definition of needed basic types.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Get __FD_* definitions.
// Copyright (C) 1997-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// We don't use `memset' because this would require a prototype and
//   the array isn't too big.

// Get sigset_t.

// Get definition of timer specification structures.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// A time value that is accurate to the nearest
//   microsecond but also has a range of years.
type timeval = struct {
	tv_sec  int64
	tv_usec int64
}

// NB: Include guard matches what <linux/time.h> uses.

type suseconds_t = int64 /* select.h:43:23 */

// Some versions of <linux/posix_types.h> define this macros.
// It's easier to assume 8-bit bytes than to get CHAR_BIT.

// fd_set for select and pselect.
type fd_set = struct{ __fds_bits [16]int64 } /* select.h:70:5 */

// Maximum number of file descriptors in `fd_set'.

// Sometimes the fd_set member is assumed to have this type.
type fd_mask = int64 /* select.h:77:19 */

// Define some inlines helping to catch common problems.

type blksize_t = int64 /* types.h:202:21 */

// Types from the Large File Support interface.
type blkcnt_t = int64    /* types.h:209:20 */ // Type to count number of disk blocks.
type fsblkcnt_t = uint64 /* types.h:213:22 */ // Type to count file system blocks.
type fsfilcnt_t = uint64 /* types.h:217:22 */ // Type to count file system inodes.

type blkcnt64_t = int64    /* types.h:236:22 */ // Type to count number of disk blocks.
type fsblkcnt64_t = uint64 /* types.h:237:24 */ // Type to count file system blocks.
type fsfilcnt64_t = uint64 /* types.h:238:24 */ // Type to count file system inodes.

// Now add the thread types.
// Declaration of common pthread types for all architectures.
//   Copyright (C) 2017-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Copyright (C) 1992-2018 Free Software Foundation, Inc.
//
//This file is part of GCC.
//
//GCC is free software; you can redistribute it and/or modify it under
//the terms of the GNU General Public License as published by the Free
//Software Foundation; either version 3, or (at your option) any later
//version.
//
//GCC is distributed in the hope that it will be useful, but WITHOUT ANY
//WARRANTY; without even the implied warranty of MERCHANTABILITY or
//FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
//for more details.
//
//Under Section 7 of GPL version 3, you are granted additional
//permissions described in the GCC Runtime Library Exception, version
//3.1, as published by the Free Software Foundation.
//
//You should have received a copy of the GNU General Public License and
//a copy of the GCC Runtime Library Exception along with this program;
//see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
//<http://www.gnu.org/licenses/>.

// This administrivia gets added to the beginning of limits.h
//   if the system has its own version of limits.h.

// We use _GCC_LIMITS_H_ because we want this not to match
//   any macros that the system's limits.h uses for its own purposes.

// Use "..." so that we find syslimits.h only in this same directory.
// syslimits.h stands for the system's own limits.h file.
//   If we can use it ok unmodified, then we install this text.
//   If fixincludes fixes it, then the fixed version is installed
//   instead of this text.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.10/5.2.4.2.1 Sizes of integer types	<limits.h>

// Handle feature test macros at the start of a header.
//   Copyright (C) 2016-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// This header is internal to glibc and should not be included outside
//   of glibc headers.  Headers including it must define
//   __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
//   cannot have multiple include guards because ISO C feature test
//   macros depend on the definition of the macro when an affected
//   header is included, not when the first system header is
//   included.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
//   macro.

// ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
//   macro.

// ISO/IEC TS 18661-4:2015 defines the
//   __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.

// ISO/IEC TS 18661-3:2015 defines the
//   __STDC_WANT_IEC_60559_TYPES_EXT__ macro.

// Maximum length of any multibyte character in any locale.
//   We define this value here since the gcc header does not define
//   the correct value.

// If we are not using GNU CC we have to define all the symbols ourself.
//   Otherwise use gcc's definitions (see below).

// We only protect from multiple inclusion here, because all the other
//   #include's protect themselves, and in GCC 2 we may #include_next through
//   multiple copies of this file before we get to GCC's.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// We don't have #include_next.
//   Define ANSI <limits.h> for standard 32-bit words.

// These assume 8-bit `char's, 16-bit `short int's,
//   and 32-bit `int's and `long int's.

// Number of bits in a `char'.

// Minimum and maximum values a `signed char' can hold.

// Maximum value an `unsigned char' can hold.  (Minimum is 0.)

// Minimum and maximum values a `char' can hold.

// Minimum and maximum values a `signed short int' can hold.

// Maximum value an `unsigned short int' can hold.  (Minimum is 0.)

// Minimum and maximum values a `signed int' can hold.

// Maximum value an `unsigned int' can hold.  (Minimum is 0.)

// Minimum and maximum values a `signed long int' can hold.

// Maximum value an `unsigned long int' can hold.  (Minimum is 0.)

// Minimum and maximum values a `signed long long int' can hold.

// Maximum value an `unsigned long long int' can hold.  (Minimum is 0.)

// Get the compiler's limits.h, which defines almost all the ISO constants.
//
//    We put this #include_next outside the double inclusion check because
//    it should be possible to include this file more than once and still get
//    the definitions from gcc's header.

// The <limits.h> files in some gcc versions don't define LLONG_MIN,
//   LLONG_MAX, and ULLONG_MAX.  Instead only the values gcc defined for
//   ages are available.

// The integer width macros are not defined by GCC's <limits.h> before
//   GCC 7, or if _GNU_SOURCE rather than
//   __STDC_WANT_IEC_60559_BFP_EXT__ is used to enable this feature.

// POSIX adds things to <limits.h>.
// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	POSIX Standard: 2.9.2 Minimum Values	Added to <limits.h>
//
//	Never include this file directly; use <limits.h> instead.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// These are the standard-mandated minimum values.

// Minimum number of operations in one list I/O call.

// Minimal number of outstanding asynchronous I/O operations.

// Maximum length of arguments to `execve', including environment.

// Maximum simultaneous processes per real user ID.

// Minimal number of timer expiration overruns.

// Maximum length of a host name (not including the terminating null)
//   as returned from the GETHOSTNAME function.

// Maximum link count of a file.

// Maximum length of login name.

// Number of bytes in a terminal canonical input queue.

// Number of bytes for which space will be
//   available in a terminal input queue.

// Maximum number of message queues open for a process.

// Maximum number of supported message priorities.

// Number of bytes in a filename.

// Number of simultaneous supplementary group IDs per process.

// Number of files one process can have open at once.

// Number of bytes in a pathname.

// Number of bytes than can be written atomically to a pipe.

// The number of repeated occurrences of a BRE permitted by the
//   REGEXEC and REGCOMP functions when using the interval notation.

// Minimal number of realtime signals reserved for the application.

// Number of semaphores a process can have.

// Maximal value of a semaphore.

// Number of pending realtime signals.

// Largest value of a `ssize_t'.

// Number of streams a process can have open at once.

// The number of bytes in a symbolic link.

// The number of symbolic links that can be traversed in the
//   resolution of a pathname in the absence of a loop.

// Number of timer for a process.

// Maximum number of characters in a tty name.

// Maximum length of a timezone name (element of `tzname').

// Maximum clock resolution in nanoseconds.

// Get the implementation-specific values for the above.
// Minimum guaranteed maximum values for system limits.  Linux version.
//   Copyright (C) 1993-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public License as
//   published by the Free Software Foundation; either version 2.1 of the
//   License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; see the file COPYING.LIB.  If
//   not, see <http://www.gnu.org/licenses/>.

// The kernel header pollutes the namespace with the NR_OPEN symbol
//   and defines LINK_MAX although filesystems have different maxima.  A
//   similar thing is true for OPEN_MAX: the limit can be changed at
//   runtime and therefore the macro must not be defined.  Remove this
//   after including the header if necessary.

// The kernel sources contain a file with all the needed information.
// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note

// Have to remove NR_OPEN?
// Have to remove LINK_MAX?
// Have to remove OPEN_MAX?
// Have to remove ARG_MAX?

// The number of data keys per process.
// This is the value this implementation supports.

// Controlling the iterations of destructors for thread-specific data.
// Number of iterations this implementation does.

// The number of threads per process.
// We have no predefined limit on the number of threads.

// Maximum amount by which a process can descrease its asynchronous I/O
//   priority level.

// Minimum size for a thread.  We are free to choose a reasonable value.

// Maximum number of timer expiration overruns.

// Maximum tty name length.

// Maximum login name length.  This is arbitrary.

// Maximum host name length.

// Maximum message queue priority level.

// Maximum value the semaphore can have.

// ssize_t is not formally required to be the signed type
//   corresponding to size_t, but it is for all configurations supported
//   by glibc.

// This value is a guaranteed minimum maximum.
//   The current maximum can be got from `sysconf'.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; include <limits.h> instead.

// The maximum `ibase' and `obase' values allowed by the `bc' utility.

// The maximum number of elements allowed in an array by the `bc' utility.

// The maximum `scale' value allowed by the `bc' utility.

// The maximum length of a string constant accepted by the `bc' utility.

// The maximum number of weights that can be assigned to an entry of
//   the LC_COLLATE `order' keyword in the locale definition file.

// The maximum number of expressions that can be nested
//   within parentheses by the `expr' utility.

// The maximum length, in bytes, of an input line.

// The maximum number of repeated occurrences of a regular expression
//   permitted when using the interval notation `\{M,N\}'.

// The maximum number of bytes in a character class name.  We have no
//   fixed limit, 2048 is a high number.

// These values are implementation-specific,
//   and may vary within the implementation.
//   Their precise values can be obtained from sysconf.

// This value is defined like this in regex.h.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//
//This file is part of GCC.
//
//GCC is free software; you can redistribute it and/or modify it under
//the terms of the GNU General Public License as published by the Free
//Software Foundation; either version 3, or (at your option) any later
//version.
//
//GCC is distributed in the hope that it will be useful, but WITHOUT ANY
//WARRANTY; without even the implied warranty of MERCHANTABILITY or
//FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
//for more details.
//
//Under Section 7 of GPL version 3, you are granted additional
//permissions described in the GCC Runtime Library Exception, version
//3.1, as published by the Free Software Foundation.
//
//You should have received a copy of the GNU General Public License and
//a copy of the GCC Runtime Library Exception along with this program;
//see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
//<http://www.gnu.org/licenses/>.

// Number of bits in a `char'.

// Maximum length of a multibyte character.

// Minimum and maximum values a `signed char' can hold.

// Maximum value an `unsigned char' can hold.  (Minimum is 0).

// Minimum and maximum values a `char' can hold.

// Minimum and maximum values a `signed short int' can hold.

// Maximum value an `unsigned short int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed int' can hold.

// Maximum value an `unsigned int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed long int' can hold.
//   (Same as `int').

// Maximum value an `unsigned long int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed long long int' can hold.

// Maximum value an `unsigned long long int' can hold.  (Minimum is 0).

// This administrivia gets added to the end of limits.h
//   if the system has its own version of limits.h.

// Copyright (C) 1992-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.14 Signal handling <signal.h>

// This file defines some things in system-specific ways.
// Old-style Unix parameters and limits.  Linux version.
//   Copyright (C) 1995-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note
// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note

// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note

// The kernel headers define ARG_MAX.  The value is wrong, though.

// The following are not really correct but it is a value we used for a
//   long time and which seems to be usable.  People should not use NOFILE
//   and NCARGS anyway.

// BSD names for some <limits.h> values.

// Magical constants.

// Unit of `st_blocks'.

// Bit map related macros.

// Macros for counting and rounding.

// Macros for min/max.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	POSIX Standard: 5.1.2 Directory Operations	<dirent.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// This file defines `struct dirent'.
//
//   It defines the macro `_DIRENT_HAVE_D_NAMLEN' iff there is a `d_namlen'
//   member that gives the length of `d_name'.
//
//   It defines the macro `_DIRENT_HAVE_D_RECLEN' iff there is a `d_reclen'
//   member that gives the size of the entire directory entry.
//
//   It defines the macro `_DIRENT_HAVE_D_OFF' iff there is a `d_off'
//   member that gives the file offset of the next directory entry.
//
//   It defines the macro `_DIRENT_HAVE_D_TYPE' iff there is a `d_type'
//   member that gives the type of the file.
//

// Copyright (C) 1996-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

type dirent = struct {
	d_ino    uint64
	d_off    int64
	d_reclen uint16
	d_type   uint8
	d_name   [256]int8
	_        [5]byte
}

//---------------------------------------------------------------------------
// Parameterize for 64-bit filesystem support.
//---------------------------------------------------------------------------

type Tcl_DirEntry = dirent /* tclUnixPort.h:63:24 */

type Tcl_SeekOffset = off_t /* tclUnixPort.h:83:16 */

// Definition of locale_t.
//   Copyright (C) 2017-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Definition of struct __locale_struct and __locale_t.
//   Copyright (C) 1997-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// POSIX.1-2008: the locale_t type, representing a locale context
//   (implementation-namespace version).  This type should be treated
//   as opaque by applications; some details are exposed for the sake of
//   efficiency in e.g. ctype functions.

type __locale_struct = struct {
	__locales       [13]uintptr
	__ctype_b       uintptr
	__ctype_tolower uintptr
	__ctype_toupper uintptr
	__names         [13]uintptr
}

type locale_t = uintptr /* locale_t.h:24:20 */

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	POSIX Standard: 3.2.1 Wait for Process Termination	<sys/wait.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.14 Signal handling <signal.h>

// These macros could also be defined in <stdlib.h>.
// This will define the `W*' macros for the flag
//   bits to `waitpid', `wait3', and `wait4'.
// Definitions of flag bits for `waitpid' et al.
//   Copyright (C) 1992-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Bits in the third argument to `waitpid'.

// Bits in the fourth argument to `waitid'.

// The following values are used by the `waitid' function.

// The Linux kernel defines these bare, rather than an enum,
//   which causes a conflict if the include order is reversed.

type idtype_t = uint32 /* waitflags.h:57:3 */

// Copyright (C) 1997-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99: 7.8 Format conversion of integer types	<inttypes.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Get the type definitions.
// Copyright (C) 1997-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99: 7.18 Integer types <stdint.h>

// Handle feature test macros at the start of a header.
//   Copyright (C) 2016-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// This header is internal to glibc and should not be included outside
//   of glibc headers.  Headers including it must define
//   __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
//   cannot have multiple include guards because ISO C feature test
//   macros depend on the definition of the macro when an affected
//   header is included, not when the first system header is
//   included.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
//   macro.

// ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
//   macro.

// ISO/IEC TS 18661-4:2015 defines the
//   __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.

// ISO/IEC TS 18661-3:2015 defines the
//   __STDC_WANT_IEC_60559_TYPES_EXT__ macro.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// wchar_t type related definitions.
//   Copyright (C) 2000-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// The fallback definitions, for when __WCHAR_MAX__ or __WCHAR_MIN__
//   are not defined, give the right value and type as long as both int
//   and wchar_t are 32-bit types.  Adding L'\0' to a constant value
//   ensures that the type is correct; it is necessary to use (L'\0' +
//   0) rather than just L'\0' so that the type in C++ is the promoted
//   version of wchar_t rather than the distinct wchar_t type itself.
//   Because wchar_t in preprocessor #if expressions is treated as
//   intmax_t or uintmax_t, the expression (L'\0' - 1) would have the
//   wrong value for WCHAR_MAX in such expressions and so cannot be used
//   to define __WCHAR_MAX in the unsigned case.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// Exact integral types.

// Signed.
// Define intN_t types.
//   Copyright (C) 2017-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Unsigned.
// Define uintN_t types.
//   Copyright (C) 2017-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type uint8_t = uint8   /* stdint-uintn.h:24:19 */
type uint16_t = uint16 /* stdint-uintn.h:25:20 */
type uint32_t = uint32 /* stdint-uintn.h:26:20 */
type uint64_t = uint64 /* stdint-uintn.h:27:20 */

// Small types.

// Signed.
type int_least8_t = int8   /* stdint.h:43:24 */
type int_least16_t = int16 /* stdint.h:44:25 */
type int_least32_t = int32 /* stdint.h:45:25 */
type int_least64_t = int64 /* stdint.h:46:25 */

// Unsigned.
type uint_least8_t = uint8   /* stdint.h:49:25 */
type uint_least16_t = uint16 /* stdint.h:50:26 */
type uint_least32_t = uint32 /* stdint.h:51:26 */
type uint_least64_t = uint64 /* stdint.h:52:26 */

// Fast types.

// Signed.
type int_fast8_t = int8   /* stdint.h:58:22 */
type int_fast16_t = int64 /* stdint.h:60:19 */
type int_fast32_t = int64 /* stdint.h:61:19 */
type int_fast64_t = int64 /* stdint.h:62:19 */

// Unsigned.
type uint_fast8_t = uint8   /* stdint.h:71:24 */
type uint_fast16_t = uint64 /* stdint.h:73:27 */
type uint_fast32_t = uint64 /* stdint.h:74:27 */
type uint_fast64_t = uint64 /* stdint.h:75:27 */

// Types for `void *' pointers.
type intptr_t = int64   /* stdint.h:87:19 */
type uintptr_t = uint64 /* stdint.h:90:27 */

// Largest integral types.
type intmax_t = int64   /* stdint.h:101:21 */
type uintmax_t = uint64 /* stdint.h:102:22 */

// Macros for printing format specifiers.

// Decimal notation.

// Octal notation.

// Unsigned integers.

// lowercase hexadecimal notation.

// UPPERCASE hexadecimal notation.

// Macros for printing `intmax_t' and `uintmax_t'.

// Macros for printing `intptr_t' and `uintptr_t'.

// Macros for scanning format specifiers.

// Signed decimal notation.

// Signed decimal notation.

// Unsigned decimal notation.

// Octal notation.

// Hexadecimal notation.

// Macros for scanning `intmax_t' and `uintmax_t'.

// Macros for scaning `intptr_t' and `uintptr_t'.

// We have to define the `uintmax_t' type using `ldiv_t'.
type imaxdiv_t = struct {
	quot int64
	rem  int64
} /* inttypes.h:275:5 */

// Copyright (C) 1992-2018 Free Software Foundation, Inc.
//
//This file is part of GCC.
//
//GCC is free software; you can redistribute it and/or modify it under
//the terms of the GNU General Public License as published by the Free
//Software Foundation; either version 3, or (at your option) any later
//version.
//
//GCC is distributed in the hope that it will be useful, but WITHOUT ANY
//WARRANTY; without even the implied warranty of MERCHANTABILITY or
//FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
//for more details.
//
//Under Section 7 of GPL version 3, you are granted additional
//permissions described in the GCC Runtime Library Exception, version
//3.1, as published by the Free Software Foundation.
//
//You should have received a copy of the GNU General Public License and
//a copy of the GCC Runtime Library Exception along with this program;
//see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
//<http://www.gnu.org/licenses/>.

// This administrivia gets added to the beginning of limits.h
//   if the system has its own version of limits.h.

// We use _GCC_LIMITS_H_ because we want this not to match
//   any macros that the system's limits.h uses for its own purposes.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	POSIX Standard: 2.10 Symbolic Constants		<unistd.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// These may be used to determine what facilities are present at compile time.
//   Their values can be obtained at run time from `sysconf'.

// POSIX Standard approved as ISO/IEC 9945-1 as of September 2008.

// These are not #ifdef __USE_POSIX2 because they are
//   in the theoretically application-owned namespace.

// The utilities on GNU systems also correspond to this version.

// The utilities on GNU systems also correspond to this version.

// This symbol was required until the 2001 edition of POSIX.

// If defined, the implementation supports the
//   C Language Bindings Option.

// If defined, the implementation supports the
//   C Language Development Utilities Option.

// If defined, the implementation supports the
//   Software Development Utilities Option.

// If defined, the implementation supports the
//   creation of locales with the localedef utility.

// X/Open version number to which the library conforms.  It is selectable.

// Commands and utilities from XPG4 are available.

// We are compatible with the old published standards as well.

// The X/Open Unix extensions are available.

// The enhanced internationalization capabilities according to XPG4.2
//   are present.

// The legacy interfaces are also available.

// Get values of POSIX options:
//
//   If these symbols are defined, the corresponding features are
//   always available.  If not, they may be available sometimes.
//   The current values can be obtained with `sysconf'.
//
//   _POSIX_JOB_CONTROL		Job control is supported.
//   _POSIX_SAVED_IDS		Processes have a saved set-user-ID
//				and a saved set-group-ID.
//   _POSIX_REALTIME_SIGNALS	Real-time, queued signals are supported.
//   _POSIX_PRIORITY_SCHEDULING	Priority scheduling is supported.
//   _POSIX_TIMERS		POSIX.4 clocks and timers are supported.
//   _POSIX_ASYNCHRONOUS_IO	Asynchronous I/O is supported.
//   _POSIX_PRIORITIZED_IO	Prioritized asynchronous I/O is supported.
//   _POSIX_SYNCHRONIZED_IO	Synchronizing file data is supported.
//   _POSIX_FSYNC			The fsync function is present.
//   _POSIX_MAPPED_FILES		Mapping of files to memory is supported.
//   _POSIX_MEMLOCK		Locking of all memory is supported.
//   _POSIX_MEMLOCK_RANGE		Locking of ranges of memory is supported.
//   _POSIX_MEMORY_PROTECTION	Setting of memory protections is supported.
//   _POSIX_MESSAGE_PASSING	POSIX.4 message queues are supported.
//   _POSIX_SEMAPHORES		POSIX.4 counting semaphores are supported.
//   _POSIX_SHARED_MEMORY_OBJECTS	POSIX.4 shared memory objects are supported.
//   _POSIX_THREADS		POSIX.1c pthreads are supported.
//   _POSIX_THREAD_ATTR_STACKADDR	Thread stack address attribute option supported.
//   _POSIX_THREAD_ATTR_STACKSIZE	Thread stack size attribute option supported.
//   _POSIX_THREAD_SAFE_FUNCTIONS	Thread-safe functions are supported.
//   _POSIX_THREAD_PRIORITY_SCHEDULING
//				POSIX.1c thread execution scheduling supported.
//   _POSIX_THREAD_PRIO_INHERIT	Thread priority inheritance option supported.
//   _POSIX_THREAD_PRIO_PROTECT	Thread priority protection option supported.
//   _POSIX_THREAD_PROCESS_SHARED	Process-shared synchronization supported.
//   _POSIX_PII			Protocol-independent interfaces are supported.
//   _POSIX_PII_XTI		XTI protocol-indep. interfaces are supported.
//   _POSIX_PII_SOCKET		Socket protocol-indep. interfaces are supported.
//   _POSIX_PII_INTERNET		Internet family of protocols supported.
//   _POSIX_PII_INTERNET_STREAM	Connection-mode Internet protocol supported.
//   _POSIX_PII_INTERNET_DGRAM	Connectionless Internet protocol supported.
//   _POSIX_PII_OSI		ISO/OSI family of protocols supported.
//   _POSIX_PII_OSI_COTS		Connection-mode ISO/OSI service supported.
//   _POSIX_PII_OSI_CLTS		Connectionless ISO/OSI service supported.
//   _POSIX_POLL			Implementation supports `poll' function.
//   _POSIX_SELECT		Implementation supports `select' and `pselect'.
//
//   _XOPEN_REALTIME		X/Open realtime support is available.
//   _XOPEN_REALTIME_THREADS	X/Open realtime thread support is available.
//   _XOPEN_SHM			Shared memory interface according to XPG4.2.
//
//   _XBS5_ILP32_OFF32		Implementation provides environment with 32-bit
//				int, long, pointer, and off_t types.
//   _XBS5_ILP32_OFFBIG		Implementation provides environment with 32-bit
//				int, long, and pointer and off_t with at least
//				64 bits.
//   _XBS5_LP64_OFF64		Implementation provides environment with 32-bit
//				int, and 64-bit long, pointer, and off_t types.
//   _XBS5_LPBIG_OFFBIG		Implementation provides environment with at
//				least 32 bits int and long, pointer, and off_t
//				with at least 64 bits.
//
//   If any of these symbols is defined as -1, the corresponding option is not
//   true for any file.  If any is defined as other than -1, the corresponding
//   option is true for all files.  If a symbol is not defined at all, the value
//   for a specific file can be obtained from `pathconf' and `fpathconf'.
//
//   _POSIX_CHOWN_RESTRICTED	Only the super user can use `chown' to change
//				the owner of a file.  `chown' can only be used
//				to change the group ID of a file to a group of
//				which the calling process is a member.
//   _POSIX_NO_TRUNC		Pathname components longer than
//				NAME_MAX generate an error.
//   _POSIX_VDISABLE		If defined, if the value of an element of the
//				`c_cc' member of `struct termios' is
//				_POSIX_VDISABLE, no character will have the
//				effect associated with that element.
//   _POSIX_SYNC_IO		Synchronous I/O may be performed.
//   _POSIX_ASYNC_IO		Asynchronous I/O may be performed.
//   _POSIX_PRIO_IO		Prioritized Asynchronous I/O may be performed.
//
//   Support for the Large File Support interface is not generally available.
//   If it is available the following constants are defined to one.
//   _LFS64_LARGEFILE		Low-level I/O supports large files.
//   _LFS64_STDIO			Standard I/O supports large files.
//

// Define POSIX options for Linux.
//   Copyright (C) 1996-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public License as
//   published by the Free Software Foundation; either version 2.1 of the
//   License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; see the file COPYING.LIB.  If
//   not, see <http://www.gnu.org/licenses/>.

// Job control is supported.

// Processes have a saved set-user-ID and a saved set-group-ID.

// Priority scheduling is supported.

// Synchronizing file data is supported.

// The fsync function is present.

// Mapping of files to memory is supported.

// Locking of all memory is supported.

// Locking of ranges of memory is supported.

// Setting of memory protections is supported.

// Some filesystems allow all users to change file ownership.

// `c_cc' member of 'struct termios' structure can be disabled by
//   using the value _POSIX_VDISABLE.

// Filenames are not silently truncated.

// X/Open realtime support is available.

// X/Open thread realtime support is available.

// XPG4.2 shared memory is supported.

// Tell we have POSIX threads.

// We have the reentrant functions described in POSIX.

// We provide priority scheduling for threads.

// We support user-defined stack sizes.

// We support user-defined stacks.

// We support priority inheritence.

// We support priority protection, though only for non-robust
//   mutexes.

// We support priority inheritence for robust mutexes.

// We do not support priority protection for robust mutexes.

// We support POSIX.1b semaphores.

// Real-time signals are supported.

// We support asynchronous I/O.
// Alternative name for Unix98.
// Support for prioritization is also available.

// The LFS support in asynchronous I/O is also available.

// The rest of the LFS is also available.

// POSIX shared memory objects are implemented.

// CPU-time clocks support needs to be checked at runtime.

// Clock support in threads must be also checked at runtime.

// GNU libc provides regular expression handling.

// Reader/Writer locks are available.

// We have a POSIX shell.

// We support the Timeouts option.

// We support spinlocks.

// The `spawn' function family is supported.

// We have POSIX timers.

// The barrier functions are available.

// POSIX message queues are available.

// Thread process-shared synchronization is supported.

// The monotonic clock might be available.

// The clock selection interfaces are available.

// Advisory information interfaces are available.

// IPv6 support is available.

// Raw socket support is available.

// We have at least one terminal.

// Neither process nor thread sporadic server interfaces is available.

// trace.h is not available.

// Typed memory objects are not available.

// Get the environment definitions from Unix98.
// Copyright (C) 1999-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// This header should define the following symbols under the described
//   situations.  A value `1' means that the model is always supported,
//   `-1' means it is never supported.  Undefined means it cannot be
//   statically decided.
//
//   _POSIX_V7_ILP32_OFF32   32bit int, long, pointers, and off_t type
//   _POSIX_V7_ILP32_OFFBIG  32bit int, long, and pointers and larger off_t type
//
//   _POSIX_V7_LP64_OFF32	   64bit long and pointers and 32bit off_t type
//   _POSIX_V7_LPBIG_OFFBIG  64bit long and pointers and large off_t type
//
//   The macros _POSIX_V6_ILP32_OFF32, _POSIX_V6_ILP32_OFFBIG,
//   _POSIX_V6_LP64_OFF32, _POSIX_V6_LPBIG_OFFBIG, _XBS5_ILP32_OFF32,
//   _XBS5_ILP32_OFFBIG, _XBS5_LP64_OFF32, and _XBS5_LPBIG_OFFBIG were
//   used in previous versions of the Unix standard and are available
//   only for compatibility.

// Environments with 32-bit wide pointers are optionally provided.
//   Therefore following macros aren't defined:
//   # undef _POSIX_V7_ILP32_OFF32
//   # undef _POSIX_V7_ILP32_OFFBIG
//   # undef _POSIX_V6_ILP32_OFF32
//   # undef _POSIX_V6_ILP32_OFFBIG
//   # undef _XBS5_ILP32_OFF32
//   # undef _XBS5_ILP32_OFFBIG
//   and users need to check at runtime.

// We also have no use (for now) for an environment with bigger pointers
//   and offsets.

// By default we have 64-bit wide `long int', pointers and `off_t'.

// Standard file descriptors.

// All functions that are not declared anywhere else.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
//This file is part of GCC.
//
//GCC is free software; you can redistribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation; either version 3, or (at your option)
//any later version.
//
//GCC is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//Under Section 7 of GPL version 3, you are granted additional
//permissions described in the GCC Runtime Library Exception, version
//3.1, as published by the Free Software Foundation.
//
//You should have received a copy of the GNU General Public License and
//a copy of the GCC Runtime Library Exception along with this program;
//see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
//<http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//   wants us just to define one data type.  So don't define
//   the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//   There's no way to win with the other order!  Sun lossage.

// On 4.3bsd-net2, make sure ansi.h is included, so we have
//   one less case to deal with in the following.
// On FreeBSD 5, machine/ansi.h does not exist anymore...

// In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
//   defined if the corresponding type is *not* defined.
//   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
//   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//   Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//   _TYPE_size_t which will typedef size_t.  fixincludes patched the
//   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//   not defined, and so that defining this macro defines _GCC_SIZE_T.
//   If we find that the macros are still defined at this point, we must
//   invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//   __WCHAR_TYPE__ have reasonable values.  This can happen if the
//   parts of GCC is compiled by an older compiler, that actually
//   include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

// Wide character type.
//   Locale-writers should change this as necessary to
//   be big enough to hold unique values not between 0 and 127,
//   and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//    are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// The Single Unix specification says that some more types are
//   available here.

type useconds_t = uint32 /* unistd.h:255:22 */

type socklen_t = uint32 /* unistd.h:274:21 */

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	POSIX Standard: 5.6.6 Set File Access and Modification Times  <utime.h>

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Structure describing file times.
type utimbuf = struct {
	actime  int64
	modtime int64
}

//---------------------------------------------------------------------------
// Socket support stuff: This likely needs more work to parameterize for each
// system.
//---------------------------------------------------------------------------

// Declarations of socket constants, types, and functions.
//   Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Define struct iovec.
//   Copyright (C) 1996-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
//This file is part of GCC.
//
//GCC is free software; you can redistribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation; either version 3, or (at your option)
//any later version.
//
//GCC is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//Under Section 7 of GPL version 3, you are granted additional
//permissions described in the GCC Runtime Library Exception, version
//3.1, as published by the Free Software Foundation.
//
//You should have received a copy of the GNU General Public License and
//a copy of the GCC Runtime Library Exception along with this program;
//see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
//<http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//   wants us just to define one data type.  So don't define
//   the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//   There's no way to win with the other order!  Sun lossage.

// On 4.3bsd-net2, make sure ansi.h is included, so we have
//   one less case to deal with in the following.
// On FreeBSD 5, machine/ansi.h does not exist anymore...

// In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
//   defined if the corresponding type is *not* defined.
//   FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
//   NetBSD defines _I386_ANSI_H_ and _X86_64_ANSI_H_ instead of _ANSI_H_

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//   Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//   _TYPE_size_t which will typedef size_t.  fixincludes patched the
//   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//   not defined, and so that defining this macro defines _GCC_SIZE_T.
//   If we find that the macros are still defined at this point, we must
//   invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//   __WCHAR_TYPE__ have reasonable values.  This can happen if the
//   parts of GCC is compiled by an older compiler, that actually
//   include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

// Wide character type.
//   Locale-writers should change this as necessary to
//   be big enough to hold unique values not between 0 and 127,
//   and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//    are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// Structure for scatter/gather I/O.
type iovec = struct {
	iov_base uintptr
	iov_len  size_t
}

// Protocol families.

// Address families.

// Socket level values.  Others are defined in the appropriate headers.
//
//   XXX These definitions also should go into the appropriate headers as
//   far as they are available.

// Maximum queue length specifiable by listen.

// Get the definition of the macro to define the common sockaddr members.
// Definition of struct sockaddr_* common members and sizes, generic version.
//   Copyright (C) 1995-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/socket.h> instead.

// POSIX.1g specifies this type name for the `sa_family' member.
type sa_family_t = uint16 /* sockaddr.h:28:28 */

// This macro is used to declare the initial common members
//   of the data types used for socket addresses, `struct sockaddr',
//   `struct sockaddr_in', `struct sockaddr_un', etc.

// Size of struct sockaddr_storage.

// Structure describing a generic socket address.
type sockaddr = struct {
	sa_family sa_family_t
	sa_data   [14]int8
}

// Structure large enough to hold any socket address (with the historical
//   exception of AF_UNIX).

type sockaddr_storage = struct {
	ss_family    sa_family_t
	__ss_padding [118]int8
	__ss_align   uint64
}

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Define uintN_t types.
//   Copyright (C) 2017-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Declarations of socket constants, types, and functions.
//   Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Internet address.
type in_addr_t = uint32_t /* in.h:30:18 */
type in_addr = struct{ s_addr in_addr_t }

// Type to represent a port.
type in_port_t = uint16_t /* in.h:119:18 */

// Definitions of the bits in an Internet address integer.
//
//   On subnets, host and network parts are found according to
//   the subnet mask, not these masks.

// Address to accept any incoming messages.
// Address to send to all hosts.
// Address indicating an error return.

// Network number for local host loopback.
// Address to loopback in software to local host.

// Defines for Multicast INADDR.

// IPv6 address
type in6_addr = struct {
	__in6_u struct{ __u6_addr8 [16]uint8_t }
}

// Extension from POSIX.1:2001.
// Structure to contain information about address of a service provider.
type addrinfo = struct {
	ai_flags     int32
	ai_family    int32
	ai_socktype  int32
	ai_protocol  int32
	ai_addrlen   socklen_t
	ai_addr      uintptr
	ai_canonname uintptr
	ai_next      uintptr
}

// The tag name of this struct is _G_fpos_t to preserve historic
//   C++ mangled names for functions taking fpos_t arguments.
//   That name should not be used in new code.
type _G_fpos_t = struct {
	__pos   int64
	__state struct {
		__count int32
		__value struct{ __wch uint32 }
	}
}

// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// The tag name of this struct is _G_fpos64_t to preserve historic
//   C++ mangled names for functions taking fpos_t and/or fpos64_t
//   arguments.  That name should not be used in new code.
type _G_fpos64_t = struct {
	__pos   int64
	__state struct {
		__count int32
		__value struct{ __wch uint32 }
	}
}

// These macros are used by bits/stdio.h and internal headers.

// Many more flag bits are defined internally.

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
//This file is part of GCC.
//
//GCC is free software; you can redistribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation; either version 3, or (at your option)
//any later version.
//
//GCC is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//Under Section 7 of GPL version 3, you are granted additional
//permissions described in the GCC Runtime Library Exception, version
//3.1, as published by the Free Software Foundation.
//
//You should have received a copy of the GNU General Public License and
//a copy of the GCC Runtime Library Exception along with this program;
//see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
//<http://www.gnu.org/licenses/>.

// ISO C Standard:  7.15  Variable arguments  <stdarg.h>

// Define __gnuc_va_list.

// Define the standard macros for the user,
//   if this invocation was from the user program.

// Define va_list, if desired, from __gnuc_va_list.
// We deliberately do not define va_list when called from
//   stdio.h, because ANSI C says that stdio.h is not supposed to define
//   va_list.  stdio.h needs to have access to that data type,
//   but must not use that name.  It should use the name __gnuc_va_list,
//   which is safe because it is reserved for the implementation.

// The macro _VA_LIST_ is the same thing used by this file in Ultrix.
//   But on BSD NET2 we must not test or define or undef it.
//   (Note that the comments in NET 2's ansi.h
//   are incorrect for _VA_LIST_--see stdio.h!)
// The macro _VA_LIST_DEFINED is used in Windows NT 3.5
// The macro _VA_LIST is used in SCO Unix 3.2.
// The macro _VA_LIST_T_H is used in the Bull dpx2
// The macro __va_list__ is used by BeOS.
type va_list = uintptr /* stdarg.h:99:24 */

// The type of the second argument to `fgetpos' and `fsetpos'.
type fpos_t = _G_fpos_t     /* stdio.h:84:18 */
type fpos64_t = _G_fpos64_t /* stdio.h:89:20 */

// If we are compiling with optimizing read this file.  It contains
//   several optimizing inline functions and macros.

//----------------------------------------------------------------------------
// Support for functions with a variable number of arguments.
//
// The following TCL_VARARGS* macros are to support old extensions
// written for older versions of Tcl where the macros permitted
// support for the varargs.h system as well as stdarg.h .
//
// New code should just directly be written to use stdarg.h conventions.

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
//This file is part of GCC.
//
//GCC is free software; you can redistribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation; either version 3, or (at your option)
//any later version.
//
//GCC is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//Under Section 7 of GPL version 3, you are granted additional
//permissions described in the GCC Runtime Library Exception, version
//3.1, as published by the Free Software Foundation.
//
//You should have received a copy of the GNU General Public License and
//a copy of the GCC Runtime Library Exception along with this program;
//see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
//<http://www.gnu.org/licenses/>.

// ISO C Standard:  7.15  Variable arguments  <stdarg.h>

// Allow a part of Tcl's API to be explicitly marked as deprecated.
//
// Used to make TIP 330/336 generate moans even if people use the
// compatibility macros. Change your code, guys! We won't support you forever.

//----------------------------------------------------------------------------
// Macros used to declare a function to be exported by a DLL. Used by Windows,
// maps to no-op declarations on non-Windows systems. The default build on
// windows is for a DLL, which causes the DLLIMPORT and DLLEXPORT macros to be
// nonempty. To build a static library, the macro STATIC_BUILD should be
// defined.
//
// Note: when building static but linking dynamically to MSVCRT we must still
//       correctly decorate the C library imported function.  Use CRTIMPORT
//       for this purpose.  _DLL is defined by the compiler when linking to
//       MSVCRT.

// These macros are used to control whether functions are being declared for
// import or export. If a function is being declared while it is being built
// to be included in a shared library, then it should have the DLLEXPORT
// storage class. If is being declared for use by a module that is going to
// link against the shared library, then it should have the DLLIMPORT storage
// class. If the symbol is beind declared for a static build or for use from a
// stub library, then the storage class should be empty.
//
// The convention is that a macro called BUILD_xxxx, where xxxx is the name of
// a library we are building, is set on the compile line for sources that are
// to be placed in the library. When this macro is set, the storage class will
// be set to DLLEXPORT. At the end of the header file, the storage class will
// be reset to DLLIMPORT.

// The following _ANSI_ARGS_ macro is to support old extensions
// written for older versions of Tcl where it permitted support
// for compilers written in the pre-prototype era of C.
//
// New code should use prototypes.

// Definitions that allow this header file to be used either with or without
// ANSI C features.

// Make sure EXTERN isn't defined elsewhere.

//----------------------------------------------------------------------------
// The following code is copied from winnt.h. If we don't replicate it here,
// then <windows.h> can't be included after tcl.h, since tcl.h also defines
// VOID. This block is skipped under Cygwin and Mingw.

// Macro to use instead of "void" for arguments that must have type "void *"
// in ANSI C; maps them to type "char *" in non-ANSI systems.

// Miscellaneous declarations.

type ClientData = uintptr /* tcl.h:340:15 */

// Darwin specific configure overrides (to support fat compiles, where
// configure runs only once for multiple architectures):

// Define Tcl_WideInt to be a type that is (at least) 64-bits wide, and define
// Tcl_WideUInt to be the unsigned variant of that type (assuming that where
// we have one, we can have the other.)
//
// Also defines the following macros:
// TCL_WIDE_INT_IS_LONG - if wide ints are really longs (i.e. we're on a
//	LP64 system such as modern Solaris or Linux ... not including Win64)
// Tcl_WideAsLong - forgetful converter from wideInt to long.
// Tcl_LongAsWide - sign-extending converter from long to wideInt.
// Tcl_WideAsDouble - converter from wideInt to double.
// Tcl_DoubleAsWide - converter from double to wideInt.
//
// The following invariant should hold for any long value 'longVal':
//	longVal == Tcl_WideAsLong(Tcl_LongAsWide(longVal))
//
// Note on converting between Tcl_WideInt and strings. This implementation (in
// tclObj.c) depends on the function
// sprintf(...,"%" TCL_LL_MODIFIER "d",...).

type Tcl_WideInt = int64   /* tcl.h:415:28 */
type Tcl_WideUInt = uint64 /* tcl.h:416:36 */

type Tcl_StatBuf = stat /* tcl.h:470:25 */

//----------------------------------------------------------------------------
// Data structures defined opaquely in this module. The definitions below just
// provide dummy types. A few fields are made visible in Tcl_Interp
// structures, namely those used for returning a string result from commands.
// Direct access to the result field is discouraged in Tcl 8.0. The
// interpreter result is either an object or a string, and the two values are
// kept consistent unless some C code sets interp->result directly.
// Programmers should use either the function Tcl_GetObjResult() or
// Tcl_GetStringResult() to read the interpreter's result. See the SetResult
// man page for details.
//
// Note: any change to the Tcl_Interp definition below must be mirrored in the
// "real" definition in tclInt.h.
//
// Note: Tcl_ObjCmdProc functions do not directly set result and freeProc.
// Instead, they set a Tcl_Obj member in the "real" structure that can be
// accessed with Tcl_GetObjResult() and Tcl_SetObjResult().

type Tcl_Interp1 = struct {
	resultDontUse    uintptr
	freeProcDontUse  uintptr
	errorLineDontUse int32
	_                [4]byte
}

//----------------------------------------------------------------------------
// Data structures defined opaquely in this module. The definitions below just
// provide dummy types. A few fields are made visible in Tcl_Interp
// structures, namely those used for returning a string result from commands.
// Direct access to the result field is discouraged in Tcl 8.0. The
// interpreter result is either an object or a string, and the two values are
// kept consistent unless some C code sets interp->result directly.
// Programmers should use either the function Tcl_GetObjResult() or
// Tcl_GetStringResult() to read the interpreter's result. See the SetResult
// man page for details.
//
// Note: any change to the Tcl_Interp definition below must be mirrored in the
// "real" definition in tclInt.h.
//
// Note: Tcl_ObjCmdProc functions do not directly set result and freeProc.
// Instead, they set a Tcl_Obj member in the "real" structure that can be
// accessed with Tcl_GetObjResult() and Tcl_SetObjResult().

type Tcl_Interp = Tcl_Interp1 /* tcl.h:525:1 */

type Tcl_AsyncHandler = uintptr       /* tcl.h:527:34 */
type Tcl_Channel = uintptr            /* tcl.h:528:29 */
type Tcl_ChannelTypeVersion = uintptr /* tcl.h:529:40 */
type Tcl_Command = uintptr            /* tcl.h:530:29 */
type Tcl_Condition = uintptr          /* tcl.h:531:31 */
type Tcl_Dict = uintptr               /* tcl.h:532:26 */
type Tcl_EncodingState = uintptr      /* tcl.h:533:35 */
type Tcl_Encoding = uintptr           /* tcl.h:534:30 */
type Tcl_Event1 = struct {
	proc    uintptr
	nextPtr uintptr
}

type Tcl_Event = Tcl_Event1    /* tcl.h:535:26 */
type Tcl_InterpState = uintptr /* tcl.h:536:33 */
type Tcl_LoadHandle_ = struct {
	clientData        ClientData
	findSymbolProcPtr uintptr
	unloadFileProcPtr uintptr
}

type Tcl_LoadHandle = uintptr    /* tcl.h:537:32 */
type Tcl_Mutex = uintptr         /* tcl.h:538:27 */
type Tcl_Pid = uintptr           /* tcl.h:539:25 */
type Tcl_RegExp = uintptr        /* tcl.h:540:28 */
type Tcl_ThreadDataKey = uintptr /* tcl.h:541:35 */
type Tcl_ThreadId = uintptr      /* tcl.h:542:30 */
type Tcl_TimerToken = uintptr    /* tcl.h:543:32 */
type Tcl_Trace = uintptr         /* tcl.h:544:27 */
type Tcl_Var = uintptr           /* tcl.h:545:25 */
type Tcl_ZlibStream = uintptr    /* tcl.h:546:32 */

// Threading function return types used for abstracting away platform
// differences when writing a Tcl_ThreadCreateProc. See the NewThread function
// in generic/tclThreadTest.c for it's usage.

// Definition of values for default stacksize and the possible flags to be
// given to Tcl_CreateThread.

// Flag values passed to Tcl_StringCaseMatch.

// Flag values passed to Tcl_GetRegExpFromObj.

// Flags values passed to Tcl_RegExpExecObj.

// Structures filled in by Tcl_RegExpInfo. Note that all offset values are
// relative to the start of the match string, not the beginning of the entire
// string.

type Tcl_RegExpIndices1 = struct {
	start int64
	end   int64
}

// Threading function return types used for abstracting away platform
// differences when writing a Tcl_ThreadCreateProc. See the NewThread function
// in generic/tclThreadTest.c for it's usage.

// Definition of values for default stacksize and the possible flags to be
// given to Tcl_CreateThread.

// Flag values passed to Tcl_StringCaseMatch.

// Flag values passed to Tcl_GetRegExpFromObj.

// Flags values passed to Tcl_RegExpExecObj.

// Structures filled in by Tcl_RegExpInfo. Note that all offset values are
// relative to the start of the match string, not the beginning of the entire
// string.

type Tcl_RegExpIndices = Tcl_RegExpIndices1 /* tcl.h:628:3 */

type Tcl_RegExpInfo1 = struct {
	nsubs       int32
	matches     uintptr
	extendStart int64
	reserved    int64
}

type Tcl_RegExpInfo = Tcl_RegExpInfo1 /* tcl.h:637:3 */

// Picky compilers complain if this typdef doesn't appear before the struct's
// reference in tclDecls.h.

type Tcl_Stat_ = uintptr    /* tcl.h:644:21 */
type Tcl_OldStat_ = uintptr /* tcl.h:645:21 */

//----------------------------------------------------------------------------
// When a TCL command returns, the interpreter contains a result from the
// command. Programmers are strongly encouraged to use one of the functions
// Tcl_GetObjResult() or Tcl_GetStringResult() to read the interpreter's
// result. See the SetResult man page for details. Besides this result, the
// command function returns an integer code, which is one of the following:
//
// TCL_OK		Command completed normally; the interpreter's result
//			contains the command's result.
// TCL_ERROR		The command couldn't be completed successfully; the
//			interpreter's result describes what went wrong.
// TCL_RETURN		The command requests that the current function return;
//			the interpreter's result contains the function's
//			return value.
// TCL_BREAK		The command requests that the innermost loop be
//			exited; the interpreter's result is meaningless.
// TCL_CONTINUE		Go on to the next iteration of the current loop; the
//			interpreter's result is meaningless.

//----------------------------------------------------------------------------
// Flags to control what substitutions are performed by Tcl_SubstObj():

// Argument descriptors for math function callbacks in expressions:

type Tcl_ValueType = uint32 /* tcl.h:692:3 */

type Tcl_Value1 = struct {
	__type      Tcl_ValueType
	intValue    int64
	doubleValue float64
	wideValue   Tcl_WideInt
}

type Tcl_Value = Tcl_Value1 /* tcl.h:700:3 */

// Forward declaration of Tcl_Obj to prevent an error when the forward
// reference to Tcl_Obj is encountered in the function types declared below.

type Tcl_Obj1 = struct {
	refCount    int32
	bytes       uintptr
	length      int32
	typePtr     uintptr
	internalRep struct {
		longValue int64
		_         [8]byte
	}
}

//----------------------------------------------------------------------------
// The following structure represents a type of object, which is a particular
// internal representation for an object plus a set of functions that provide
// standard operations on objects of that type.

type Tcl_ObjType1 = struct {
	name             uintptr
	freeIntRepProc   uintptr
	dupIntRepProc    uintptr
	updateStringProc uintptr
	setFromAnyProc   uintptr
}

//----------------------------------------------------------------------------
// The following structure represents a type of object, which is a particular
// internal representation for an object plus a set of functions that provide
// standard operations on objects of that type.

type Tcl_ObjType = Tcl_ObjType1 /* tcl.h:796:3 */

// One of the following structures exists for each object in the Tcl system.
// An object stores a value as either a string, some internal representation,
// or both.

type Tcl_Obj = Tcl_Obj1 /* tcl.h:843:3 */

//----------------------------------------------------------------------------
// The following structure contains the state needed by Tcl_SaveResult. No-one
// outside of Tcl should access any of these fields. This structure is
// typically allocated on the stack.

type Tcl_SavedResult1 = struct {
	result       uintptr
	freeProc     uintptr
	objResultPtr uintptr
	appendResult uintptr
	appendAvl    int32
	appendUsed   int32
	resultSpace  [201]int8
	_            [7]byte
}

//----------------------------------------------------------------------------
// The following structure contains the state needed by Tcl_SaveResult. No-one
// outside of Tcl should access any of these fields. This structure is
// typically allocated on the stack.

type Tcl_SavedResult = Tcl_SavedResult1 /* tcl.h:872:3 */

//----------------------------------------------------------------------------
// The following definitions support Tcl's namespace facility. Note: the first
// five fields must match exactly the fields in a Namespace structure (see
// tclInt.h).

type Tcl_Namespace1 = struct {
	name       uintptr
	fullName   uintptr
	clientData ClientData
	deleteProc uintptr
	parentPtr  uintptr
}

//----------------------------------------------------------------------------
// The following definitions support Tcl's namespace facility. Note: the first
// five fields must match exactly the fields in a Namespace structure (see
// tclInt.h).

type Tcl_Namespace = Tcl_Namespace1 /* tcl.h:897:3 */

//----------------------------------------------------------------------------
// The following structure represents a call frame, or activation record. A
// call frame defines a naming context for a procedure call: its local scope
// (for local variables) and its namespace scope (used for non-local
// variables; often the global :: namespace). A call frame can also define the
// naming context for a namespace eval or namespace inscope command: the
// namespace in which the command's code should execute. The Tcl_CallFrame
// structures exist only while procedures or namespace eval/inscope's are
// being executed, and provide a Tcl call stack.
//
// A call frame is initialized and pushed using Tcl_PushCallFrame and popped
// using Tcl_PopCallFrame. Storage for a Tcl_CallFrame must be provided by the
// Tcl_PushCallFrame caller, and callers typically allocate them on the C call
// stack for efficiency. For this reason, Tcl_CallFrame is defined as a
// structure and not as an opaque token. However, most Tcl_CallFrame fields
// are hidden since applications should not access them directly; others are
// declared as "dummyX".
//
// WARNING!! The structure definition must be kept consistent with the
// CallFrame structure in tclInt.h. If you change one, change the other.

type Tcl_CallFrame1 = struct {
	nsPtr   uintptr
	dummy1  int32
	dummy2  int32
	dummy3  uintptr
	dummy4  uintptr
	dummy5  uintptr
	dummy6  int32
	dummy7  uintptr
	dummy8  uintptr
	dummy9  int32
	dummy10 uintptr
	dummy11 uintptr
	dummy12 uintptr
	dummy13 uintptr
}

//----------------------------------------------------------------------------
// The following structure represents a call frame, or activation record. A
// call frame defines a naming context for a procedure call: its local scope
// (for local variables) and its namespace scope (used for non-local
// variables; often the global :: namespace). A call frame can also define the
// naming context for a namespace eval or namespace inscope command: the
// namespace in which the command's code should execute. The Tcl_CallFrame
// structures exist only while procedures or namespace eval/inscope's are
// being executed, and provide a Tcl call stack.
//
// A call frame is initialized and pushed using Tcl_PushCallFrame and popped
// using Tcl_PopCallFrame. Storage for a Tcl_CallFrame must be provided by the
// Tcl_PushCallFrame caller, and callers typically allocate them on the C call
// stack for efficiency. For this reason, Tcl_CallFrame is defined as a
// structure and not as an opaque token. However, most Tcl_CallFrame fields
// are hidden since applications should not access them directly; others are
// declared as "dummyX".
//
// WARNING!! The structure definition must be kept consistent with the
// CallFrame structure in tclInt.h. If you change one, change the other.

type Tcl_CallFrame = Tcl_CallFrame1 /* tcl.h:937:3 */

//----------------------------------------------------------------------------
// Information about commands that is returned by Tcl_GetCommandInfo and
// passed to Tcl_SetCommandInfo. objProc is an objc/objv object-based command
// function while proc is a traditional Tcl argc/argv string-based function.
// Tcl_CreateObjCommand and Tcl_CreateCommand ensure that both objProc and
// proc are non-NULL and can be called to execute the command. However, it may
// be faster to call one instead of the other. The member isNativeObjectProc
// is set to 1 if an object-based function was registered by
// Tcl_CreateObjCommand, and to 0 if a string-based function was registered by
// Tcl_CreateCommand. The other function is typically set to a compatibility
// wrapper that does string-to-object or object-to-string argument conversions
// then calls the other function.

type Tcl_CmdInfo1 = struct {
	isNativeObjectProc int32
	objProc            uintptr
	objClientData      ClientData
	proc               uintptr
	clientData         ClientData
	deleteProc         uintptr
	deleteData         ClientData
	namespacePtr       uintptr
}

//----------------------------------------------------------------------------
// Information about commands that is returned by Tcl_GetCommandInfo and
// passed to Tcl_SetCommandInfo. objProc is an objc/objv object-based command
// function while proc is a traditional Tcl argc/argv string-based function.
// Tcl_CreateObjCommand and Tcl_CreateCommand ensure that both objProc and
// proc are non-NULL and can be called to execute the command. However, it may
// be faster to call one instead of the other. The member isNativeObjectProc
// is set to 1 if an object-based function was registered by
// Tcl_CreateObjCommand, and to 0 if a string-based function was registered by
// Tcl_CreateCommand. The other function is typically set to a compatibility
// wrapper that does string-to-object or object-to-string argument conversions
// then calls the other function.

type Tcl_CmdInfo = Tcl_CmdInfo1 /* tcl.h:973:3 */

//----------------------------------------------------------------------------
// The structure defined below is used to hold dynamic strings. The only
// fields that clients should use are string and length, accessible via the
// macros Tcl_DStringValue and Tcl_DStringLength.

type Tcl_DString1 = struct {
	string      uintptr
	length      int32
	spaceAvl    int32
	staticSpace [200]int8
}

//----------------------------------------------------------------------------
// The structure defined below is used to hold dynamic strings. The only
// fields that clients should use are string and length, accessible via the
// macros Tcl_DStringValue and Tcl_DStringLength.

type Tcl_DString = Tcl_DString1 /* tcl.h:993:3 */

// Definitions for the maximum number of digits of precision that may be
// specified in the "tcl_precision" variable, and the number of bytes of
// buffer space required by Tcl_PrintDouble.

// Definition for a number of bytes of buffer space sufficient to hold the
// string representation of an integer in base 10 (assuming the existence of
// 64-bit integers).

// Flag values passed to Tcl_ConvertElement.
// TCL_DONT_USE_BRACES forces it not to enclose the element in braces, but to
//	use backslash quoting instead.
// TCL_DONT_QUOTE_HASH disables the default quoting of the '#' character. It
//	is safe to leave the hash unquoted when the element is not the first
//	element of a list, and this flag can be used by the caller to indicate
//	that condition.

// Flag that may be passed to Tcl_GetIndexFromObj to force it to disallow
// abbreviated strings.

//----------------------------------------------------------------------------
// Flag values passed to Tcl_RecordAndEval, Tcl_EvalObj, Tcl_EvalObjv.
// WARNING: these bit choices must not conflict with the bit choices for
// evalFlag bits in tclInt.h!
//
// Meanings:
//	TCL_NO_EVAL:		Just record this command
//	TCL_EVAL_GLOBAL:	Execute script in global namespace
//	TCL_EVAL_DIRECT:	Do not compile this script
//	TCL_EVAL_INVOKE:	Magical Tcl_EvalObjv mode for aliases/ensembles
//				o Run in iPtr->lookupNsPtr or global namespace
//				o Cut out of error traces
//				o Don't reset the flags controlling ensemble
//				  error message rewriting.
//	TCL_CANCEL_UNWIND:	Magical Tcl_CancelEval mode that causes the
//				stack for the script in progress to be
//				completely unwound.
//	TCL_EVAL_NOERR:	Do no exception reporting at all, just return
//				as the caller will report.

// Special freeProc values that may be passed to Tcl_SetResult (see the man
// page for details):

// Flag values passed to variable-related functions.
// WARNING: these bit choices must not conflict with the bit choice for
// TCL_CANCEL_UNWIND, above.

// Required to support old variable/vdelete/vinfo traces.
// Indicate the semantics of the result of a trace.

// Flag values for ensemble commands.

// Flag values passed to command-related functions.

// The TCL_PARSE_PART1 flag is deprecated and has no effect. The part1 is now
// always parsed whenever the part2 is NULL. (This is to avoid a common error
// when converting code to use the new object based APIs and forgetting to
// give the flag)

// Types for linked variables:

//----------------------------------------------------------------------------
// Forward declarations of Tcl_HashTable and related types.

type Tcl_HashKeyType1 = struct {
	version         int32
	flags           int32
	hashKeyProc     uintptr
	compareKeysProc uintptr
	allocEntryProc  uintptr
	freeEntryProc   uintptr
}

// Definitions for the maximum number of digits of precision that may be
// specified in the "tcl_precision" variable, and the number of bytes of
// buffer space required by Tcl_PrintDouble.

// Definition for a number of bytes of buffer space sufficient to hold the
// string representation of an integer in base 10 (assuming the existence of
// 64-bit integers).

// Flag values passed to Tcl_ConvertElement.
// TCL_DONT_USE_BRACES forces it not to enclose the element in braces, but to
//	use backslash quoting instead.
// TCL_DONT_QUOTE_HASH disables the default quoting of the '#' character. It
//	is safe to leave the hash unquoted when the element is not the first
//	element of a list, and this flag can be used by the caller to indicate
//	that condition.

// Flag that may be passed to Tcl_GetIndexFromObj to force it to disallow
// abbreviated strings.

//----------------------------------------------------------------------------
// Flag values passed to Tcl_RecordAndEval, Tcl_EvalObj, Tcl_EvalObjv.
// WARNING: these bit choices must not conflict with the bit choices for
// evalFlag bits in tclInt.h!
//
// Meanings:
//	TCL_NO_EVAL:		Just record this command
//	TCL_EVAL_GLOBAL:	Execute script in global namespace
//	TCL_EVAL_DIRECT:	Do not compile this script
//	TCL_EVAL_INVOKE:	Magical Tcl_EvalObjv mode for aliases/ensembles
//				o Run in iPtr->lookupNsPtr or global namespace
//				o Cut out of error traces
//				o Don't reset the flags controlling ensemble
//				  error message rewriting.
//	TCL_CANCEL_UNWIND:	Magical Tcl_CancelEval mode that causes the
//				stack for the script in progress to be
//				completely unwound.
//	TCL_EVAL_NOERR:	Do no exception reporting at all, just return
//				as the caller will report.

// Special freeProc values that may be passed to Tcl_SetResult (see the man
// page for details):

// Flag values passed to variable-related functions.
// WARNING: these bit choices must not conflict with the bit choice for
// TCL_CANCEL_UNWIND, above.

// Required to support old variable/vdelete/vinfo traces.
// Indicate the semantics of the result of a trace.

// Flag values for ensemble commands.

// Flag values passed to command-related functions.

// The TCL_PARSE_PART1 flag is deprecated and has no effect. The part1 is now
// always parsed whenever the part2 is NULL. (This is to avoid a common error
// when converting code to use the new object based APIs and forgetting to
// give the flag)

// Types for linked variables:

//----------------------------------------------------------------------------
// Forward declarations of Tcl_HashTable and related types.

type Tcl_HashKeyType = Tcl_HashKeyType1 /* tcl.h:1152:32 */
type Tcl_HashTable1 = struct {
	buckets       uintptr
	staticBuckets [4]uintptr
	numBuckets    int32
	numEntries    int32
	rebuildSize   int32
	downShift     int32
	mask          int32
	keyType       int32
	findProc      uintptr
	createProc    uintptr
	typePtr       uintptr
}

type Tcl_HashTable = Tcl_HashTable1 /* tcl.h:1153:30 */
type Tcl_HashEntry1 = struct {
	nextPtr    uintptr
	tablePtr   uintptr
	hash       uintptr
	clientData ClientData
	key        struct{ oneWordValue uintptr }
}

type Tcl_HashEntry = Tcl_HashEntry1 /* tcl.h:1154:30 */

// Structure definition for information used to keep track of searches through
// hash tables:

type Tcl_HashSearch1 = struct {
	tablePtr     uintptr
	nextIndex    int32
	nextEntryPtr uintptr
}

// Structure definition for information used to keep track of searches through
// hash tables:

type Tcl_HashSearch = Tcl_HashSearch1 /* tcl.h:1314:3 */

// Acceptable key types for hash tables:
//
// TCL_STRING_KEYS:		The keys are strings, they are copied into the
//				entry.
// TCL_ONE_WORD_KEYS:		The keys are pointers, the pointer is stored
//				in the entry.
// TCL_CUSTOM_TYPE_KEYS:	The keys are arbitrary types which are copied
//				into the entry.
// TCL_CUSTOM_PTR_KEYS:		The keys are pointers to arbitrary types, the
//				pointer is stored in the entry.
//
// While maintaining binary compatibility the above have to be distinct values
// as they are used to differentiate between old versions of the hash table
// which don't have a typePtr and new ones which do. Once binary compatibility
// is discarded in favour of making more wide spread changes TCL_STRING_KEYS
// can be the same as TCL_CUSTOM_TYPE_KEYS, and TCL_ONE_WORD_KEYS can be the
// same as TCL_CUSTOM_PTR_KEYS because they simply determine how the key is
// accessed from the entry and not the behaviour.

// Structure definition for information used to keep track of searches through
// dictionaries. These fields should not be accessed by code outside
// tclDictObj.c

type Tcl_DictSearch = struct {
	next          uintptr
	epoch         int32
	dictionaryPtr Tcl_Dict
} /* tcl.h:1354:3 */

// Positions to pass to Tcl_QueueEvent:

type Tcl_QueuePosition = uint32 /* tcl.h:1389:3 */

// Values to pass to Tcl_SetServiceMode to specify the behavior of notifier
// event routines.

// The following structure keeps is used to hold a time value, either as an
// absolute time (the number of seconds from the epoch) or as an elapsed time.
// On Unix systems the epoch is Midnight Jan 1, 1970 GMT.

type Tcl_Time1 = struct {
	sec  int64
	usec int64
}

// Values to pass to Tcl_SetServiceMode to specify the behavior of notifier
// event routines.

// The following structure keeps is used to hold a time value, either as an
// absolute time (the number of seconds from the epoch) or as an elapsed time.
// On Unix systems the epoch is Midnight Jan 1, 1970 GMT.

type Tcl_Time = Tcl_Time1 /* tcl.h:1408:3 */

// struct Tcl_ChannelType:
//
// One such structure exists for each type (kind) of channel. It collects
// together in one place all the functions that are part of the specific
// channel type.
//
// It is recommend that the Tcl_Channel* functions are used to access elements
// of this structure, instead of direct accessing.

type Tcl_ChannelType1 = struct {
	typeName         uintptr
	version          Tcl_ChannelTypeVersion
	closeProc        uintptr
	inputProc        uintptr
	outputProc       uintptr
	seekProc         uintptr
	setOptionProc    uintptr
	getOptionProc    uintptr
	watchProc        uintptr
	getHandleProc    uintptr
	close2Proc       uintptr
	blockModeProc    uintptr
	flushProc        uintptr
	handlerProc      uintptr
	wideSeekProc     uintptr
	threadActionProc uintptr
	truncateProc     uintptr
}

// struct Tcl_ChannelType:
//
// One such structure exists for each type (kind) of channel. It collects
// together in one place all the functions that are part of the specific
// channel type.
//
// It is recommend that the Tcl_Channel* functions are used to access elements
// of this structure, instead of direct accessing.

type Tcl_ChannelType = Tcl_ChannelType1 /* tcl.h:1592:3 */

// The following flags determine whether the blockModeProc above should set
// the channel into blocking or nonblocking mode. They are passed as arguments
// to the blockModeProc function in the above structure.

//----------------------------------------------------------------------------
// Enum for different types of file paths.

type Tcl_PathType = uint32 /* tcl.h:1613:3 */

// The following structure is used to pass glob type data amongst the various
// glob routines and Tcl_FSMatchInDirectory.

type Tcl_GlobTypeData1 = struct {
	__type     int32
	perm       int32
	macType    uintptr
	macCreator uintptr
}

// The following structure is used to pass glob type data amongst the various
// glob routines and Tcl_FSMatchInDirectory.

type Tcl_GlobTypeData = Tcl_GlobTypeData1 /* tcl.h:1625:3 */

type Tcl_FSVersion = uintptr /* tcl.h:1700:31 */

//----------------------------------------------------------------------------
// Data structures related to hooking into the filesystem

// Filesystem version tag.  This was introduced in 8.4.

// struct Tcl_Filesystem:
//
// One such structure exists for each type (kind) of filesystem. It collects
// together in one place all the functions that are part of the specific
// filesystem. Tcl always accesses the filesystem through one of these
// structures.
//
// Not all entries need be non-NULL; any which are NULL are simply ignored.
// However, a complete filesystem should provide all of these functions. The
// explanations in the structure show the importance of each function.

type Tcl_Filesystem1 = struct {
	typeName                 uintptr
	structureLength          int32
	version                  Tcl_FSVersion
	pathInFilesystemProc     uintptr
	dupInternalRepProc       uintptr
	freeInternalRepProc      uintptr
	internalToNormalizedProc uintptr
	createInternalRepProc    uintptr
	normalizePathProc        uintptr
	filesystemPathTypeProc   uintptr
	filesystemSeparatorProc  uintptr
	statProc                 uintptr
	accessProc               uintptr
	openFileChannelProc      uintptr
	matchInDirectoryProc     uintptr
	utimeProc                uintptr
	linkProc                 uintptr
	listVolumesProc          uintptr
	fileAttrStringsProc      uintptr
	fileAttrsGetProc         uintptr
	fileAttrsSetProc         uintptr
	createDirectoryProc      uintptr
	removeDirectoryProc      uintptr
	deleteFileProc           uintptr
	copyFileProc             uintptr
	renameFileProc           uintptr
	copyDirectoryProc        uintptr
	lstatProc                uintptr
	loadFileProc             uintptr
	getCwdProc               uintptr
	chdirProc                uintptr
}

//----------------------------------------------------------------------------
// Data structures related to hooking into the filesystem

// Filesystem version tag.  This was introduced in 8.4.

// struct Tcl_Filesystem:
//
// One such structure exists for each type (kind) of filesystem. It collects
// together in one place all the functions that are part of the specific
// filesystem. Tcl always accesses the filesystem through one of these
// structures.
//
// Not all entries need be non-NULL; any which are NULL are simply ignored.
// However, a complete filesystem should provide all of these functions. The
// explanations in the structure show the importance of each function.

type Tcl_Filesystem = Tcl_Filesystem1 /* tcl.h:1873:3 */

// The following definitions are used as values for the 'linkAction' flag to
// Tcl_FSLink, or the linkProc of any filesystem. Any combination of flags can
// be given. For link creation, the linkProc should create a link which
// matches any of the types given.
//
// TCL_CREATE_SYMBOLIC_LINK -	Create a symbolic or soft link.
// TCL_CREATE_HARD_LINK -	Create a hard link.

//----------------------------------------------------------------------------
// The following structure represents the Notifier functions that you can
// override with the Tcl_SetNotifier call.

type Tcl_NotifierProcs1 = struct {
	setTimerProc          uintptr
	waitForEventProc      uintptr
	createFileHandlerProc uintptr
	deleteFileHandlerProc uintptr
	initNotifierProc      uintptr
	finalizeNotifierProc  uintptr
	alertNotifierProc     uintptr
	serviceModeHookProc   uintptr
}

// The following definitions are used as values for the 'linkAction' flag to
// Tcl_FSLink, or the linkProc of any filesystem. Any combination of flags can
// be given. For link creation, the linkProc should create a link which
// matches any of the types given.
//
// TCL_CREATE_SYMBOLIC_LINK -	Create a symbolic or soft link.
// TCL_CREATE_HARD_LINK -	Create a hard link.

//----------------------------------------------------------------------------
// The following structure represents the Notifier functions that you can
// override with the Tcl_SetNotifier call.

type Tcl_NotifierProcs = Tcl_NotifierProcs1 /* tcl.h:1903:3 */

//----------------------------------------------------------------------------
// The following data structures and declarations are for the new Tcl parser.
//
// For each word of a command, and for each piece of a word such as a variable
// reference, one of the following structures is created to describe the
// token.

type Tcl_Token1 = struct {
	__type        int32
	start         uintptr
	size          int32
	numComponents int32
}

//----------------------------------------------------------------------------
// The following data structures and declarations are for the new Tcl parser.
//
// For each word of a command, and for each piece of a word such as a variable
// reference, one of the following structures is created to describe the
// token.

type Tcl_Token = Tcl_Token1 /* tcl.h:1924:3 */

// Type values defined for Tcl_Token structures. These values are defined as
// mask bits so that it's easy to check for collections of types.
//
// TCL_TOKEN_WORD -		The token describes one word of a command,
//				from the first non-blank character of the word
//				(which may be " or {) up to but not including
//				the space, semicolon, or bracket that
//				terminates the word. NumComponents counts the
//				total number of sub-tokens that make up the
//				word. This includes, for example, sub-tokens
//				of TCL_TOKEN_VARIABLE tokens.
// TCL_TOKEN_SIMPLE_WORD -	This token is just like TCL_TOKEN_WORD except
//				that the word is guaranteed to consist of a
//				single TCL_TOKEN_TEXT sub-token.
// TCL_TOKEN_TEXT -		The token describes a range of literal text
//				that is part of a word. NumComponents is
//				always 0.
// TCL_TOKEN_BS -		The token describes a backslash sequence that
//				must be collapsed. NumComponents is always 0.
// TCL_TOKEN_COMMAND -		The token describes a command whose result
//				must be substituted into the word. The token
//				includes the enclosing brackets. NumComponents
//				is always 0.
// TCL_TOKEN_VARIABLE -		The token describes a variable substitution,
//				including the dollar sign, variable name, and
//				array index (if there is one) up through the
//				right parentheses. NumComponents tells how
//				many additional tokens follow to represent the
//				variable name. The first token will be a
//				TCL_TOKEN_TEXT token that describes the
//				variable name. If the variable is an array
//				reference then there will be one or more
//				additional tokens, of type TCL_TOKEN_TEXT,
//				TCL_TOKEN_BS, TCL_TOKEN_COMMAND, and
//				TCL_TOKEN_VARIABLE, that describe the array
//				index; numComponents counts the total number
//				of nested tokens that make up the variable
//				reference, including sub-tokens of
//				TCL_TOKEN_VARIABLE tokens.
// TCL_TOKEN_SUB_EXPR -		The token describes one subexpression of an
//				expression, from the first non-blank character
//				of the subexpression up to but not including
//				the space, brace, or bracket that terminates
//				the subexpression. NumComponents counts the
//				total number of following subtokens that make
//				up the subexpression; this includes all
//				subtokens for any nested TCL_TOKEN_SUB_EXPR
//				tokens. For example, a numeric value used as a
//				primitive operand is described by a
//				TCL_TOKEN_SUB_EXPR token followed by a
//				TCL_TOKEN_TEXT token. A binary subexpression
//				is described by a TCL_TOKEN_SUB_EXPR token
//				followed by the TCL_TOKEN_OPERATOR token for
//				the operator, then TCL_TOKEN_SUB_EXPR tokens
//				for the left then the right operands.
// TCL_TOKEN_OPERATOR -		The token describes one expression operator.
//				An operator might be the name of a math
//				function such as "abs". A TCL_TOKEN_OPERATOR
//				token is always preceded by one
//				TCL_TOKEN_SUB_EXPR token for the operator's
//				subexpression, and is followed by zero or more
//				TCL_TOKEN_SUB_EXPR tokens for the operator's
//				operands. NumComponents is always 0.
// TCL_TOKEN_EXPAND_WORD -	This token is just like TCL_TOKEN_WORD except
//				that it marks a word that began with the
//				literal character prefix "{*}". This word is
//				marked to be expanded - that is, broken into
//				words after substitution is complete.

// Parsing error types. On any parsing error, one of these values will be
// stored in the error field of the Tcl_Parse structure defined below.

// A structure of the following type is filled in by Tcl_ParseCommand. It
// describes a single command parsed from an input string.

type Tcl_Parse1 = struct {
	commentStart    uintptr
	commentSize     int32
	commandStart    uintptr
	commandSize     int32
	numWords        int32
	tokenPtr        uintptr
	numTokens       int32
	tokensAvailable int32
	errorType       int32
	string          uintptr
	end             uintptr
	interp          uintptr
	term            uintptr
	incomplete      int32
	staticTokens    [20]Tcl_Token
}

// Type values defined for Tcl_Token structures. These values are defined as
// mask bits so that it's easy to check for collections of types.
//
// TCL_TOKEN_WORD -		The token describes one word of a command,
//				from the first non-blank character of the word
//				(which may be " or {) up to but not including
//				the space, semicolon, or bracket that
//				terminates the word. NumComponents counts the
//				total number of sub-tokens that make up the
//				word. This includes, for example, sub-tokens
//				of TCL_TOKEN_VARIABLE tokens.
// TCL_TOKEN_SIMPLE_WORD -	This token is just like TCL_TOKEN_WORD except
//				that the word is guaranteed to consist of a
//				single TCL_TOKEN_TEXT sub-token.
// TCL_TOKEN_TEXT -		The token describes a range of literal text
//				that is part of a word. NumComponents is
//				always 0.
// TCL_TOKEN_BS -		The token describes a backslash sequence that
//				must be collapsed. NumComponents is always 0.
// TCL_TOKEN_COMMAND -		The token describes a command whose result
//				must be substituted into the word. The token
//				includes the enclosing brackets. NumComponents
//				is always 0.
// TCL_TOKEN_VARIABLE -		The token describes a variable substitution,
//				including the dollar sign, variable name, and
//				array index (if there is one) up through the
//				right parentheses. NumComponents tells how
//				many additional tokens follow to represent the
//				variable name. The first token will be a
//				TCL_TOKEN_TEXT token that describes the
//				variable name. If the variable is an array
//				reference then there will be one or more
//				additional tokens, of type TCL_TOKEN_TEXT,
//				TCL_TOKEN_BS, TCL_TOKEN_COMMAND, and
//				TCL_TOKEN_VARIABLE, that describe the array
//				index; numComponents counts the total number
//				of nested tokens that make up the variable
//				reference, including sub-tokens of
//				TCL_TOKEN_VARIABLE tokens.
// TCL_TOKEN_SUB_EXPR -		The token describes one subexpression of an
//				expression, from the first non-blank character
//				of the subexpression up to but not including
//				the space, brace, or bracket that terminates
//				the subexpression. NumComponents counts the
//				total number of following subtokens that make
//				up the subexpression; this includes all
//				subtokens for any nested TCL_TOKEN_SUB_EXPR
//				tokens. For example, a numeric value used as a
//				primitive operand is described by a
//				TCL_TOKEN_SUB_EXPR token followed by a
//				TCL_TOKEN_TEXT token. A binary subexpression
//				is described by a TCL_TOKEN_SUB_EXPR token
//				followed by the TCL_TOKEN_OPERATOR token for
//				the operator, then TCL_TOKEN_SUB_EXPR tokens
//				for the left then the right operands.
// TCL_TOKEN_OPERATOR -		The token describes one expression operator.
//				An operator might be the name of a math
//				function such as "abs". A TCL_TOKEN_OPERATOR
//				token is always preceded by one
//				TCL_TOKEN_SUB_EXPR token for the operator's
//				subexpression, and is followed by zero or more
//				TCL_TOKEN_SUB_EXPR tokens for the operator's
//				operands. NumComponents is always 0.
// TCL_TOKEN_EXPAND_WORD -	This token is just like TCL_TOKEN_WORD except
//				that it marks a word that began with the
//				literal character prefix "{*}". This word is
//				marked to be expanded - that is, broken into
//				words after substitution is complete.

// Parsing error types. On any parsing error, one of these values will be
// stored in the error field of the Tcl_Parse structure defined below.

// A structure of the following type is filled in by Tcl_ParseCommand. It
// describes a single command parsed from an input string.

type Tcl_Parse = Tcl_Parse1 /* tcl.h:2083:3 */

//----------------------------------------------------------------------------
// The following structure represents a user-defined encoding. It collects
// together all the functions that are used by the specific encoding.

type Tcl_EncodingType1 = struct {
	encodingName uintptr
	toUtfProc    uintptr
	fromUtfProc  uintptr
	freeProc     uintptr
	clientData   ClientData
	nullSize     int32
	_            [4]byte
}

//----------------------------------------------------------------------------
// The following structure represents a user-defined encoding. It collects
// together all the functions that are used by the specific encoding.

type Tcl_EncodingType = Tcl_EncodingType1 /* tcl.h:2111:3 */

// The following definitions are used as values for the conversion control
// flags argument when converting text from one character set to another:
//
// TCL_ENCODING_START -		Signifies that the source buffer is the first
//				block in a (potentially multi-block) input
//				stream. Tells the conversion function to reset
//				to an initial state and perform any
//				initialization that needs to occur before the
//				first byte is converted. If the source buffer
//				contains the entire input stream to be
//				converted, this flag should be set.
// TCL_ENCODING_END -		Signifies that the source buffer is the last
//				block in a (potentially multi-block) input
//				stream. Tells the conversion routine to
//				perform any finalization that needs to occur
//				after the last byte is converted and then to
//				reset to an initial state. If the source
//				buffer contains the entire input stream to be
//				converted, this flag should be set.
// TCL_ENCODING_STOPONERROR -	If set, then the converter will return
//				immediately upon encountering an invalid byte
//				sequence or a source character that has no
//				mapping in the target encoding. If clear, then
//				the converter will skip the problem,
//				substituting one or more "close" characters in
//				the destination buffer and then continue to
//				convert the source.
// TCL_ENCODING_NO_TERMINATE - 	If set, Tcl_ExternalToUtf will not append a
//				terminating NUL byte.  Knowing that it will
//				not need space to do so, it will fill all
//				dstLen bytes with encoded UTF-8 content, as
//				other circumstances permit.  If clear, the
//				default behavior is to reserve a byte in
//				the dst space for NUL termination, and to
//				append the NUL byte.
// TCL_ENCODING_CHAR_LIMIT -	If set and dstCharsPtr is not NULL, then
//				Tcl_ExternalToUtf takes the initial value
//				of *dstCharsPtr is taken as a limit of the
//				maximum number of chars to produce in the
//				encoded UTF-8 content.  Otherwise, the
//				number of chars produced is controlled only
//				by other limiting factors.

// The following definitions are the error codes returned by the conversion
// routines:
//
// TCL_OK -			All characters were converted.
// TCL_CONVERT_NOSPACE -	The output buffer would not have been large
//				enough for all of the converted data; as many
//				characters as could fit were converted though.
// TCL_CONVERT_MULTIBYTE -	The last few bytes in the source string were
//				the beginning of a multibyte sequence, but
//				more bytes were needed to complete this
//				sequence. A subsequent call to the conversion
//				routine should pass the beginning of this
//				unconverted sequence plus additional bytes
//				from the source stream to properly convert the
//				formerly split-up multibyte sequence.
// TCL_CONVERT_SYNTAX -		The source stream contained an invalid
//				character sequence. This may occur if the
//				input stream has been damaged or if the input
//				encoding method was misidentified. This error
//				is reported only if TCL_ENCODING_STOPONERROR
//				was specified.
// TCL_CONVERT_UNKNOWN -	The source string contained a character that
//				could not be represented in the target
//				encoding. This error is reported only if
//				TCL_ENCODING_STOPONERROR was specified.

// The maximum number of bytes that are necessary to represent a single
// Unicode character in UTF-8. The valid values should be 3, 4 or 6
// (or perhaps 1 if we want to support a non-unicode enabled core). If 3 or
// 4, then Tcl_UniChar must be 2-bytes in size (UCS-2) (the default). If 6,
// then Tcl_UniChar must be 4-bytes in size (UCS-4). At this time UCS-2 mode
// is the default and recommended mode. UCS-4 is experimental and not
// recommended. It works for the core, but most extensions expect UCS-2.

// This represents a Unicode character. Any changes to this should also be
// reflected in regcustom.h.

type Tcl_UniChar = uint16 /* tcl.h:2228:24 */

//----------------------------------------------------------------------------
// TIP #59: The following structure is used in calls 'Tcl_RegisterConfig' to
// provide the system with the embedded configuration data.

type Tcl_Config1 = struct {
	key   uintptr
	value uintptr
}

//----------------------------------------------------------------------------
// TIP #59: The following structure is used in calls 'Tcl_RegisterConfig' to
// provide the system with the embedded configuration data.

type Tcl_Config = Tcl_Config1 /* tcl.h:2242:3 */

//----------------------------------------------------------------------------
// Override definitions for libtommath.

type mp_int1 = struct {
	used  int32
	alloc int32
	sign  mp_sign
	dp    uintptr
}

//----------------------------------------------------------------------------
// Override definitions for libtommath.

type mp_int = mp_int1  /* tcl.h:2266:23 */
type mp_digit = uint32 /* tcl.h:2268:22 */

//----------------------------------------------------------------------------
// Definitions needed for Tcl_ParseArgvObj routines.
// Based on tkArgv.c.
// Modifications from the original are copyright (c) Sam Bromley 2006

type Tcl_ArgvInfo = struct {
	__type     int32
	keyStr     uintptr
	srcPtr     uintptr
	dstPtr     uintptr
	helpStr    uintptr
	clientData ClientData
} /* tcl.h:2289:3 */

type TclPlatStubs1 = struct {
	magic int32
	hooks uintptr
}

type TclIntStubs1 = struct {
	magic                        int32
	hooks                        uintptr
	reserved0                    uintptr
	reserved1                    uintptr
	reserved2                    uintptr
	tclAllocateFreeObjects       uintptr
	reserved4                    uintptr
	tclCleanupChildren           uintptr
	tclCleanupCommand            uintptr
	tclCopyAndCollapse           uintptr
	tclCopyChannelOld            uintptr
	tclCreatePipeline            uintptr
	tclCreateProc                uintptr
	tclDeleteCompiledLocalVars   uintptr
	tclDeleteVars                uintptr
	reserved13                   uintptr
	tclDumpMemoryInfo            uintptr
	reserved15                   uintptr
	tclExprFloatError            uintptr
	reserved17                   uintptr
	reserved18                   uintptr
	reserved19                   uintptr
	reserved20                   uintptr
	reserved21                   uintptr
	tclFindElement               uintptr
	tclFindProc                  uintptr
	tclFormatInt                 uintptr
	tclFreePackageInfo           uintptr
	reserved26                   uintptr
	reserved27                   uintptr
	tclpGetDefaultStdChannel     uintptr
	reserved29                   uintptr
	reserved30                   uintptr
	tclGetExtension              uintptr
	tclGetFrame                  uintptr
	reserved33                   uintptr
	tclGetIntForIndex            uintptr
	reserved35                   uintptr
	reserved36                   uintptr
	tclGetLoadedPackages         uintptr
	tclGetNamespaceForQualName   uintptr
	tclGetObjInterpProc          uintptr
	tclGetOpenMode               uintptr
	tclGetOriginalCommand        uintptr
	tclpGetUserHome              uintptr
	reserved43                   uintptr
	tclGuessPackageName          uintptr
	tclHideUnsafeCommands        uintptr
	tclInExit                    uintptr
	reserved47                   uintptr
	reserved48                   uintptr
	reserved49                   uintptr
	tclInitCompiledLocals        uintptr
	tclInterpInit                uintptr
	reserved52                   uintptr
	tclInvokeObjectCommand       uintptr
	tclInvokeStringCommand       uintptr
	tclIsProc                    uintptr
	reserved56                   uintptr
	reserved57                   uintptr
	tclLookupVar                 uintptr
	reserved59                   uintptr
	tclNeedSpace                 uintptr
	tclNewProcBodyObj            uintptr
	tclObjCommandComplete        uintptr
	tclObjInterpProc             uintptr
	tclObjInvoke                 uintptr
	reserved65                   uintptr
	reserved66                   uintptr
	reserved67                   uintptr
	reserved68                   uintptr
	tclpAlloc                    uintptr
	reserved70                   uintptr
	reserved71                   uintptr
	reserved72                   uintptr
	reserved73                   uintptr
	tclpFree                     uintptr
	tclpGetClicks                uintptr
	tclpGetSeconds               uintptr
	tclpGetTime                  uintptr
	reserved78                   uintptr
	reserved79                   uintptr
	reserved80                   uintptr
	tclpRealloc                  uintptr
	reserved82                   uintptr
	reserved83                   uintptr
	reserved84                   uintptr
	reserved85                   uintptr
	reserved86                   uintptr
	reserved87                   uintptr
	tclPrecTraceProc             uintptr
	tclPreventAliasLoop          uintptr
	reserved90                   uintptr
	tclProcCleanupProc           uintptr
	tclProcCompileProc           uintptr
	tclProcDeleteProc            uintptr
	reserved94                   uintptr
	reserved95                   uintptr
	tclRenameCommand             uintptr
	tclResetShadowedCmdRefs      uintptr
	tclServiceIdle               uintptr
	reserved99                   uintptr
	reserved100                  uintptr
	tclSetPreInitScript          uintptr
	tclSetupEnv                  uintptr
	tclSockGetPort               uintptr
	tclSockMinimumBuffersOld     uintptr
	reserved105                  uintptr
	reserved106                  uintptr
	reserved107                  uintptr
	tclTeardownNamespace         uintptr
	tclUpdateReturnInfo          uintptr
	tclSockMinimumBuffers        uintptr
	tcl_AddInterpResolvers       uintptr
	tcl_AppendExportList         uintptr
	tcl_CreateNamespace          uintptr
	tcl_DeleteNamespace          uintptr
	tcl_Export                   uintptr
	tcl_FindCommand              uintptr
	tcl_FindNamespace            uintptr
	tcl_GetInterpResolvers       uintptr
	tcl_GetNamespaceResolvers    uintptr
	tcl_FindNamespaceVar         uintptr
	tcl_ForgetImport             uintptr
	tcl_GetCommandFromObj        uintptr
	tcl_GetCommandFullName       uintptr
	tcl_GetCurrentNamespace      uintptr
	tcl_GetGlobalNamespace       uintptr
	tcl_GetVariableFullName      uintptr
	tcl_Import                   uintptr
	tcl_PopCallFrame             uintptr
	tcl_PushCallFrame            uintptr
	tcl_RemoveInterpResolvers    uintptr
	tcl_SetNamespaceResolvers    uintptr
	tclpHasSockets               uintptr
	tclpGetDate                  uintptr
	reserved134                  uintptr
	reserved135                  uintptr
	reserved136                  uintptr
	reserved137                  uintptr
	tclGetEnv                    uintptr
	reserved139                  uintptr
	reserved140                  uintptr
	tclpGetCwd                   uintptr
	tclSetByteCodeFromAny        uintptr
	tclAddLiteralObj             uintptr
	tclHideLiteral               uintptr
	tclGetAuxDataType            uintptr
	tclHandleCreate              uintptr
	tclHandleFree                uintptr
	tclHandlePreserve            uintptr
	tclHandleRelease             uintptr
	tclRegAbout                  uintptr
	tclRegExpRangeUniChar        uintptr
	tclSetLibraryPath            uintptr
	tclGetLibraryPath            uintptr
	reserved154                  uintptr
	reserved155                  uintptr
	tclRegError                  uintptr
	tclVarTraceExists            uintptr
	tclSetStartupScriptFileName  uintptr
	tclGetStartupScriptFileName  uintptr
	reserved160                  uintptr
	tclChannelTransform          uintptr
	tclChannelEventScriptInvoker uintptr
	tclGetInstructionTable       uintptr
	tclExpandCodeArray           uintptr
	tclpSetInitialEncodings      uintptr
	tclListObjSetElement         uintptr
	tclSetStartupScriptPath      uintptr
	tclGetStartupScriptPath      uintptr
	tclpUtfNcmp2                 uintptr
	tclCheckInterpTraces         uintptr
	tclCheckExecutionTraces      uintptr
	tclInThreadExit              uintptr
	tclUniCharMatch              uintptr
	reserved174                  uintptr
	tclCallVarTraces             uintptr
	tclCleanupVar                uintptr
	tclVarErrMsg                 uintptr
	tcl_SetStartupScript         uintptr
	tcl_GetStartupScript         uintptr
	reserved180                  uintptr
	reserved181                  uintptr
	tclpLocaltime                uintptr
	tclpGmtime                   uintptr
	reserved184                  uintptr
	reserved185                  uintptr
	reserved186                  uintptr
	reserved187                  uintptr
	reserved188                  uintptr
	reserved189                  uintptr
	reserved190                  uintptr
	reserved191                  uintptr
	reserved192                  uintptr
	reserved193                  uintptr
	reserved194                  uintptr
	reserved195                  uintptr
	reserved196                  uintptr
	reserved197                  uintptr
	tclObjGetFrame               uintptr
	reserved199                  uintptr
	tclpObjRemoveDirectory       uintptr
	tclpObjCopyDirectory         uintptr
	tclpObjCreateDirectory       uintptr
	tclpObjDeleteFile            uintptr
	tclpObjCopyFile              uintptr
	tclpObjRenameFile            uintptr
	tclpObjStat                  uintptr
	tclpObjAccess                uintptr
	tclpOpenFileChannel          uintptr
	reserved209                  uintptr
	reserved210                  uintptr
	reserved211                  uintptr
	tclpFindExecutable           uintptr
	tclGetObjNameOfExecutable    uintptr
	tclSetObjNameOfExecutable    uintptr
	tclStackAlloc                uintptr
	tclStackFree                 uintptr
	tclPushStackFrame            uintptr
	tclPopStackFrame             uintptr
	reserved219                  uintptr
	reserved220                  uintptr
	reserved221                  uintptr
	reserved222                  uintptr
	reserved223                  uintptr
	tclGetPlatform               uintptr
	tclTraceDictPath             uintptr
	tclObjBeingDeleted           uintptr
	tclSetNsPath                 uintptr
	reserved228                  uintptr
	tclPtrMakeUpvar              uintptr
	tclObjLookupVar              uintptr
	tclGetNamespaceFromObj       uintptr
	tclEvalObjEx                 uintptr
	tclGetSrcInfoForPc           uintptr
	tclVarHashCreateVar          uintptr
	tclInitVarHashTable          uintptr
	tclBackgroundException       uintptr
	tclResetCancellation         uintptr
	tclNRInterpProc              uintptr
	tclNRInterpProcCore          uintptr
	tclNRRunCallbacks            uintptr
	tclNREvalObjEx               uintptr
	tclNREvalObjv                uintptr
	tclDbDumpActiveObjects       uintptr
	tclGetNamespaceChildTable    uintptr
	tclGetNamespaceCommandTable  uintptr
	tclInitRewriteEnsemble       uintptr
	tclResetRewriteEnsemble      uintptr
	tclCopyChannel               uintptr
	tclDoubleDigits              uintptr
	tclSetSlaveCancelFlags       uintptr
	tclRegisterLiteral           uintptr
	tclPtrGetVar                 uintptr
	tclPtrSetVar                 uintptr
	tclPtrIncrObjVar             uintptr
	tclPtrObjMakeUpvar           uintptr
	tclPtrUnsetVar               uintptr
	reserved257                  uintptr
	tclUnusedStubEntry           uintptr
}

type TclIntPlatStubs1 = struct {
	magic                    int32
	hooks                    uintptr
	tclGetAndDetachPids      uintptr
	tclpCloseFile            uintptr
	tclpCreateCommandChannel uintptr
	tclpCreatePipe           uintptr
	tclpCreateProcess        uintptr
	reserved5                uintptr
	tclpMakeFile             uintptr
	tclpOpenFile             uintptr
	tclUnixWaitForFile       uintptr
	tclpCreateTempFile       uintptr
	tclpReaddir              uintptr
	tclpLocaltime_unix       uintptr
	tclpGmtime_unix          uintptr
	tclpInetNtoa             uintptr
	tclUnixCopyFile          uintptr
	reserved15               uintptr
	reserved16               uintptr
	reserved17               uintptr
	reserved18               uintptr
	reserved19               uintptr
	reserved20               uintptr
	reserved21               uintptr
	reserved22               uintptr
	reserved23               uintptr
	reserved24               uintptr
	reserved25               uintptr
	reserved26               uintptr
	reserved27               uintptr
	reserved28               uintptr
	tclWinCPUID              uintptr
	tclUnixOpenTemporaryFile uintptr
}

type TclStubHooks = struct {
	tclPlatStubs    uintptr
	tclIntStubs     uintptr
	tclIntPlatStubs uintptr
} /* tclDecls.h:1843:3 */

type TclStubs1 = struct {
	magic                                  int32
	hooks                                  uintptr
	tcl_PkgProvideEx                       uintptr
	tcl_PkgRequireEx                       uintptr
	tcl_Panic                              uintptr
	tcl_Alloc                              uintptr
	tcl_Free                               uintptr
	tcl_Realloc                            uintptr
	tcl_DbCkalloc                          uintptr
	tcl_DbCkfree                           uintptr
	tcl_DbCkrealloc                        uintptr
	tcl_CreateFileHandler                  uintptr
	tcl_DeleteFileHandler                  uintptr
	tcl_SetTimer                           uintptr
	tcl_Sleep                              uintptr
	tcl_WaitForEvent                       uintptr
	tcl_AppendAllObjTypes                  uintptr
	tcl_AppendStringsToObj                 uintptr
	tcl_AppendToObj                        uintptr
	tcl_ConcatObj                          uintptr
	tcl_ConvertToType                      uintptr
	tcl_DbDecrRefCount                     uintptr
	tcl_DbIncrRefCount                     uintptr
	tcl_DbIsShared                         uintptr
	tcl_DbNewBooleanObj                    uintptr
	tcl_DbNewByteArrayObj                  uintptr
	tcl_DbNewDoubleObj                     uintptr
	tcl_DbNewListObj                       uintptr
	tcl_DbNewLongObj                       uintptr
	tcl_DbNewObj                           uintptr
	tcl_DbNewStringObj                     uintptr
	tcl_DuplicateObj                       uintptr
	tclFreeObj                             uintptr
	tcl_GetBoolean                         uintptr
	tcl_GetBooleanFromObj                  uintptr
	tcl_GetByteArrayFromObj                uintptr
	tcl_GetDouble                          uintptr
	tcl_GetDoubleFromObj                   uintptr
	tcl_GetIndexFromObj                    uintptr
	tcl_GetInt                             uintptr
	tcl_GetIntFromObj                      uintptr
	tcl_GetLongFromObj                     uintptr
	tcl_GetObjType                         uintptr
	tcl_GetStringFromObj                   uintptr
	tcl_InvalidateStringRep                uintptr
	tcl_ListObjAppendList                  uintptr
	tcl_ListObjAppendElement               uintptr
	tcl_ListObjGetElements                 uintptr
	tcl_ListObjIndex                       uintptr
	tcl_ListObjLength                      uintptr
	tcl_ListObjReplace                     uintptr
	tcl_NewBooleanObj                      uintptr
	tcl_NewByteArrayObj                    uintptr
	tcl_NewDoubleObj                       uintptr
	tcl_NewIntObj                          uintptr
	tcl_NewListObj                         uintptr
	tcl_NewLongObj                         uintptr
	tcl_NewObj                             uintptr
	tcl_NewStringObj                       uintptr
	tcl_SetBooleanObj                      uintptr
	tcl_SetByteArrayLength                 uintptr
	tcl_SetByteArrayObj                    uintptr
	tcl_SetDoubleObj                       uintptr
	tcl_SetIntObj                          uintptr
	tcl_SetListObj                         uintptr
	tcl_SetLongObj                         uintptr
	tcl_SetObjLength                       uintptr
	tcl_SetStringObj                       uintptr
	tcl_AddErrorInfo                       uintptr
	tcl_AddObjErrorInfo                    uintptr
	tcl_AllowExceptions                    uintptr
	tcl_AppendElement                      uintptr
	tcl_AppendResult                       uintptr
	tcl_AsyncCreate                        uintptr
	tcl_AsyncDelete                        uintptr
	tcl_AsyncInvoke                        uintptr
	tcl_AsyncMark                          uintptr
	tcl_AsyncReady                         uintptr
	tcl_BackgroundError                    uintptr
	tcl_Backslash                          uintptr
	tcl_BadChannelOption                   uintptr
	tcl_CallWhenDeleted                    uintptr
	tcl_CancelIdleCall                     uintptr
	tcl_Close                              uintptr
	tcl_CommandComplete                    uintptr
	tcl_Concat                             uintptr
	tcl_ConvertElement                     uintptr
	tcl_ConvertCountedElement              uintptr
	tcl_CreateAlias                        uintptr
	tcl_CreateAliasObj                     uintptr
	tcl_CreateChannel                      uintptr
	tcl_CreateChannelHandler               uintptr
	tcl_CreateCloseHandler                 uintptr
	tcl_CreateCommand                      uintptr
	tcl_CreateEventSource                  uintptr
	tcl_CreateExitHandler                  uintptr
	tcl_CreateInterp                       uintptr
	tcl_CreateMathFunc                     uintptr
	tcl_CreateObjCommand                   uintptr
	tcl_CreateSlave                        uintptr
	tcl_CreateTimerHandler                 uintptr
	tcl_CreateTrace                        uintptr
	tcl_DeleteAssocData                    uintptr
	tcl_DeleteChannelHandler               uintptr
	tcl_DeleteCloseHandler                 uintptr
	tcl_DeleteCommand                      uintptr
	tcl_DeleteCommandFromToken             uintptr
	tcl_DeleteEvents                       uintptr
	tcl_DeleteEventSource                  uintptr
	tcl_DeleteExitHandler                  uintptr
	tcl_DeleteHashEntry                    uintptr
	tcl_DeleteHashTable                    uintptr
	tcl_DeleteInterp                       uintptr
	tcl_DetachPids                         uintptr
	tcl_DeleteTimerHandler                 uintptr
	tcl_DeleteTrace                        uintptr
	tcl_DontCallWhenDeleted                uintptr
	tcl_DoOneEvent                         uintptr
	tcl_DoWhenIdle                         uintptr
	tcl_DStringAppend                      uintptr
	tcl_DStringAppendElement               uintptr
	tcl_DStringEndSublist                  uintptr
	tcl_DStringFree                        uintptr
	tcl_DStringGetResult                   uintptr
	tcl_DStringInit                        uintptr
	tcl_DStringResult                      uintptr
	tcl_DStringSetLength                   uintptr
	tcl_DStringStartSublist                uintptr
	tcl_Eof                                uintptr
	tcl_ErrnoId                            uintptr
	tcl_ErrnoMsg                           uintptr
	tcl_Eval                               uintptr
	tcl_EvalFile                           uintptr
	tcl_EvalObj                            uintptr
	tcl_EventuallyFree                     uintptr
	tcl_Exit                               uintptr
	tcl_ExposeCommand                      uintptr
	tcl_ExprBoolean                        uintptr
	tcl_ExprBooleanObj                     uintptr
	tcl_ExprDouble                         uintptr
	tcl_ExprDoubleObj                      uintptr
	tcl_ExprLong                           uintptr
	tcl_ExprLongObj                        uintptr
	tcl_ExprObj                            uintptr
	tcl_ExprString                         uintptr
	tcl_Finalize                           uintptr
	tcl_FindExecutable                     uintptr
	tcl_FirstHashEntry                     uintptr
	tcl_Flush                              uintptr
	tcl_FreeResult                         uintptr
	tcl_GetAlias                           uintptr
	tcl_GetAliasObj                        uintptr
	tcl_GetAssocData                       uintptr
	tcl_GetChannel                         uintptr
	tcl_GetChannelBufferSize               uintptr
	tcl_GetChannelHandle                   uintptr
	tcl_GetChannelInstanceData             uintptr
	tcl_GetChannelMode                     uintptr
	tcl_GetChannelName                     uintptr
	tcl_GetChannelOption                   uintptr
	tcl_GetChannelType                     uintptr
	tcl_GetCommandInfo                     uintptr
	tcl_GetCommandName                     uintptr
	tcl_GetErrno                           uintptr
	tcl_GetHostName                        uintptr
	tcl_GetInterpPath                      uintptr
	tcl_GetMaster                          uintptr
	tcl_GetNameOfExecutable                uintptr
	tcl_GetObjResult                       uintptr
	tcl_GetOpenFile                        uintptr
	tcl_GetPathType                        uintptr
	tcl_Gets                               uintptr
	tcl_GetsObj                            uintptr
	tcl_GetServiceMode                     uintptr
	tcl_GetSlave                           uintptr
	tcl_GetStdChannel                      uintptr
	tcl_GetStringResult                    uintptr
	tcl_GetVar                             uintptr
	tcl_GetVar2                            uintptr
	tcl_GlobalEval                         uintptr
	tcl_GlobalEvalObj                      uintptr
	tcl_HideCommand                        uintptr
	tcl_Init                               uintptr
	tcl_InitHashTable                      uintptr
	tcl_InputBlocked                       uintptr
	tcl_InputBuffered                      uintptr
	tcl_InterpDeleted                      uintptr
	tcl_IsSafe                             uintptr
	tcl_JoinPath                           uintptr
	tcl_LinkVar                            uintptr
	reserved188                            uintptr
	tcl_MakeFileChannel                    uintptr
	tcl_MakeSafe                           uintptr
	tcl_MakeTcpClientChannel               uintptr
	tcl_Merge                              uintptr
	tcl_NextHashEntry                      uintptr
	tcl_NotifyChannel                      uintptr
	tcl_ObjGetVar2                         uintptr
	tcl_ObjSetVar2                         uintptr
	tcl_OpenCommandChannel                 uintptr
	tcl_OpenFileChannel                    uintptr
	tcl_OpenTcpClient                      uintptr
	tcl_OpenTcpServer                      uintptr
	tcl_Preserve                           uintptr
	tcl_PrintDouble                        uintptr
	tcl_PutEnv                             uintptr
	tcl_PosixError                         uintptr
	tcl_QueueEvent                         uintptr
	tcl_Read                               uintptr
	tcl_ReapDetachedProcs                  uintptr
	tcl_RecordAndEval                      uintptr
	tcl_RecordAndEvalObj                   uintptr
	tcl_RegisterChannel                    uintptr
	tcl_RegisterObjType                    uintptr
	tcl_RegExpCompile                      uintptr
	tcl_RegExpExec                         uintptr
	tcl_RegExpMatch                        uintptr
	tcl_RegExpRange                        uintptr
	tcl_Release                            uintptr
	tcl_ResetResult                        uintptr
	tcl_ScanElement                        uintptr
	tcl_ScanCountedElement                 uintptr
	tcl_SeekOld                            uintptr
	tcl_ServiceAll                         uintptr
	tcl_ServiceEvent                       uintptr
	tcl_SetAssocData                       uintptr
	tcl_SetChannelBufferSize               uintptr
	tcl_SetChannelOption                   uintptr
	tcl_SetCommandInfo                     uintptr
	tcl_SetErrno                           uintptr
	tcl_SetErrorCode                       uintptr
	tcl_SetMaxBlockTime                    uintptr
	tcl_SetPanicProc                       uintptr
	tcl_SetRecursionLimit                  uintptr
	tcl_SetResult                          uintptr
	tcl_SetServiceMode                     uintptr
	tcl_SetObjErrorCode                    uintptr
	tcl_SetObjResult                       uintptr
	tcl_SetStdChannel                      uintptr
	tcl_SetVar                             uintptr
	tcl_SetVar2                            uintptr
	tcl_SignalId                           uintptr
	tcl_SignalMsg                          uintptr
	tcl_SourceRCFile                       uintptr
	tcl_SplitList                          uintptr
	tcl_SplitPath                          uintptr
	tcl_StaticPackage                      uintptr
	tcl_StringMatch                        uintptr
	tcl_TellOld                            uintptr
	tcl_TraceVar                           uintptr
	tcl_TraceVar2                          uintptr
	tcl_TranslateFileName                  uintptr
	tcl_Ungets                             uintptr
	tcl_UnlinkVar                          uintptr
	tcl_UnregisterChannel                  uintptr
	tcl_UnsetVar                           uintptr
	tcl_UnsetVar2                          uintptr
	tcl_UntraceVar                         uintptr
	tcl_UntraceVar2                        uintptr
	tcl_UpdateLinkedVar                    uintptr
	tcl_UpVar                              uintptr
	tcl_UpVar2                             uintptr
	tcl_VarEval                            uintptr
	tcl_VarTraceInfo                       uintptr
	tcl_VarTraceInfo2                      uintptr
	tcl_Write                              uintptr
	tcl_WrongNumArgs                       uintptr
	tcl_DumpActiveMemory                   uintptr
	tcl_ValidateAllMemory                  uintptr
	tcl_AppendResultVA                     uintptr
	tcl_AppendStringsToObjVA               uintptr
	tcl_HashStats                          uintptr
	tcl_ParseVar                           uintptr
	tcl_PkgPresent                         uintptr
	tcl_PkgPresentEx                       uintptr
	tcl_PkgProvide                         uintptr
	tcl_PkgRequire                         uintptr
	tcl_SetErrorCodeVA                     uintptr
	tcl_VarEvalVA                          uintptr
	tcl_WaitPid                            uintptr
	tcl_PanicVA                            uintptr
	tcl_GetVersion                         uintptr
	tcl_InitMemory                         uintptr
	tcl_StackChannel                       uintptr
	tcl_UnstackChannel                     uintptr
	tcl_GetStackedChannel                  uintptr
	tcl_SetMainLoop                        uintptr
	reserved285                            uintptr
	tcl_AppendObjToObj                     uintptr
	tcl_CreateEncoding                     uintptr
	tcl_CreateThreadExitHandler            uintptr
	tcl_DeleteThreadExitHandler            uintptr
	tcl_DiscardResult                      uintptr
	tcl_EvalEx                             uintptr
	tcl_EvalObjv                           uintptr
	tcl_EvalObjEx                          uintptr
	tcl_ExitThread                         uintptr
	tcl_ExternalToUtf                      uintptr
	tcl_ExternalToUtfDString               uintptr
	tcl_FinalizeThread                     uintptr
	tcl_FinalizeNotifier                   uintptr
	tcl_FreeEncoding                       uintptr
	tcl_GetCurrentThread                   uintptr
	tcl_GetEncoding                        uintptr
	tcl_GetEncodingName                    uintptr
	tcl_GetEncodingNames                   uintptr
	tcl_GetIndexFromObjStruct              uintptr
	tcl_GetThreadData                      uintptr
	tcl_GetVar2Ex                          uintptr
	tcl_InitNotifier                       uintptr
	tcl_MutexLock                          uintptr
	tcl_MutexUnlock                        uintptr
	tcl_ConditionNotify                    uintptr
	tcl_ConditionWait                      uintptr
	tcl_NumUtfChars                        uintptr
	tcl_ReadChars                          uintptr
	tcl_RestoreResult                      uintptr
	tcl_SaveResult                         uintptr
	tcl_SetSystemEncoding                  uintptr
	tcl_SetVar2Ex                          uintptr
	tcl_ThreadAlert                        uintptr
	tcl_ThreadQueueEvent                   uintptr
	tcl_UniCharAtIndex                     uintptr
	tcl_UniCharToLower                     uintptr
	tcl_UniCharToTitle                     uintptr
	tcl_UniCharToUpper                     uintptr
	tcl_UniCharToUtf                       uintptr
	tcl_UtfAtIndex                         uintptr
	tcl_UtfCharComplete                    uintptr
	tcl_UtfBackslash                       uintptr
	tcl_UtfFindFirst                       uintptr
	tcl_UtfFindLast                        uintptr
	tcl_UtfNext                            uintptr
	tcl_UtfPrev                            uintptr
	tcl_UtfToExternal                      uintptr
	tcl_UtfToExternalDString               uintptr
	tcl_UtfToLower                         uintptr
	tcl_UtfToTitle                         uintptr
	tcl_UtfToUniChar                       uintptr
	tcl_UtfToUpper                         uintptr
	tcl_WriteChars                         uintptr
	tcl_WriteObj                           uintptr
	tcl_GetString                          uintptr
	tcl_GetDefaultEncodingDir              uintptr
	tcl_SetDefaultEncodingDir              uintptr
	tcl_AlertNotifier                      uintptr
	tcl_ServiceModeHook                    uintptr
	tcl_UniCharIsAlnum                     uintptr
	tcl_UniCharIsAlpha                     uintptr
	tcl_UniCharIsDigit                     uintptr
	tcl_UniCharIsLower                     uintptr
	tcl_UniCharIsSpace                     uintptr
	tcl_UniCharIsUpper                     uintptr
	tcl_UniCharIsWordChar                  uintptr
	tcl_UniCharLen                         uintptr
	tcl_UniCharNcmp                        uintptr
	tcl_UniCharToUtfDString                uintptr
	tcl_UtfToUniCharDString                uintptr
	tcl_GetRegExpFromObj                   uintptr
	tcl_EvalTokens                         uintptr
	tcl_FreeParse                          uintptr
	tcl_LogCommandInfo                     uintptr
	tcl_ParseBraces                        uintptr
	tcl_ParseCommand                       uintptr
	tcl_ParseExpr                          uintptr
	tcl_ParseQuotedString                  uintptr
	tcl_ParseVarName                       uintptr
	tcl_GetCwd                             uintptr
	tcl_Chdir                              uintptr
	tcl_Access                             uintptr
	tcl_Stat                               uintptr
	tcl_UtfNcmp                            uintptr
	tcl_UtfNcasecmp                        uintptr
	tcl_StringCaseMatch                    uintptr
	tcl_UniCharIsControl                   uintptr
	tcl_UniCharIsGraph                     uintptr
	tcl_UniCharIsPrint                     uintptr
	tcl_UniCharIsPunct                     uintptr
	tcl_RegExpExecObj                      uintptr
	tcl_RegExpGetInfo                      uintptr
	tcl_NewUnicodeObj                      uintptr
	tcl_SetUnicodeObj                      uintptr
	tcl_GetCharLength                      uintptr
	tcl_GetUniChar                         uintptr
	tcl_GetUnicode                         uintptr
	tcl_GetRange                           uintptr
	tcl_AppendUnicodeToObj                 uintptr
	tcl_RegExpMatchObj                     uintptr
	tcl_SetNotifier                        uintptr
	tcl_GetAllocMutex                      uintptr
	tcl_GetChannelNames                    uintptr
	tcl_GetChannelNamesEx                  uintptr
	tcl_ProcObjCmd                         uintptr
	tcl_ConditionFinalize                  uintptr
	tcl_MutexFinalize                      uintptr
	tcl_CreateThread                       uintptr
	tcl_ReadRaw                            uintptr
	tcl_WriteRaw                           uintptr
	tcl_GetTopChannel                      uintptr
	tcl_ChannelBuffered                    uintptr
	tcl_ChannelName                        uintptr
	tcl_ChannelVersion                     uintptr
	tcl_ChannelBlockModeProc               uintptr
	tcl_ChannelCloseProc                   uintptr
	tcl_ChannelClose2Proc                  uintptr
	tcl_ChannelInputProc                   uintptr
	tcl_ChannelOutputProc                  uintptr
	tcl_ChannelSeekProc                    uintptr
	tcl_ChannelSetOptionProc               uintptr
	tcl_ChannelGetOptionProc               uintptr
	tcl_ChannelWatchProc                   uintptr
	tcl_ChannelGetHandleProc               uintptr
	tcl_ChannelFlushProc                   uintptr
	tcl_ChannelHandlerProc                 uintptr
	tcl_JoinThread                         uintptr
	tcl_IsChannelShared                    uintptr
	tcl_IsChannelRegistered                uintptr
	tcl_CutChannel                         uintptr
	tcl_SpliceChannel                      uintptr
	tcl_ClearChannelHandlers               uintptr
	tcl_IsChannelExisting                  uintptr
	tcl_UniCharNcasecmp                    uintptr
	tcl_UniCharCaseMatch                   uintptr
	tcl_FindHashEntry                      uintptr
	tcl_CreateHashEntry                    uintptr
	tcl_InitCustomHashTable                uintptr
	tcl_InitObjHashTable                   uintptr
	tcl_CommandTraceInfo                   uintptr
	tcl_TraceCommand                       uintptr
	tcl_UntraceCommand                     uintptr
	tcl_AttemptAlloc                       uintptr
	tcl_AttemptDbCkalloc                   uintptr
	tcl_AttemptRealloc                     uintptr
	tcl_AttemptDbCkrealloc                 uintptr
	tcl_AttemptSetObjLength                uintptr
	tcl_GetChannelThread                   uintptr
	tcl_GetUnicodeFromObj                  uintptr
	tcl_GetMathFuncInfo                    uintptr
	tcl_ListMathFuncs                      uintptr
	tcl_SubstObj                           uintptr
	tcl_DetachChannel                      uintptr
	tcl_IsStandardChannel                  uintptr
	tcl_FSCopyFile                         uintptr
	tcl_FSCopyDirectory                    uintptr
	tcl_FSCreateDirectory                  uintptr
	tcl_FSDeleteFile                       uintptr
	tcl_FSLoadFile                         uintptr
	tcl_FSMatchInDirectory                 uintptr
	tcl_FSLink                             uintptr
	tcl_FSRemoveDirectory                  uintptr
	tcl_FSRenameFile                       uintptr
	tcl_FSLstat                            uintptr
	tcl_FSUtime                            uintptr
	tcl_FSFileAttrsGet                     uintptr
	tcl_FSFileAttrsSet                     uintptr
	tcl_FSFileAttrStrings                  uintptr
	tcl_FSStat                             uintptr
	tcl_FSAccess                           uintptr
	tcl_FSOpenFileChannel                  uintptr
	tcl_FSGetCwd                           uintptr
	tcl_FSChdir                            uintptr
	tcl_FSConvertToPathType                uintptr
	tcl_FSJoinPath                         uintptr
	tcl_FSSplitPath                        uintptr
	tcl_FSEqualPaths                       uintptr
	tcl_FSGetNormalizedPath                uintptr
	tcl_FSJoinToPath                       uintptr
	tcl_FSGetInternalRep                   uintptr
	tcl_FSGetTranslatedPath                uintptr
	tcl_FSEvalFile                         uintptr
	tcl_FSNewNativePath                    uintptr
	tcl_FSGetNativePath                    uintptr
	tcl_FSFileSystemInfo                   uintptr
	tcl_FSPathSeparator                    uintptr
	tcl_FSListVolumes                      uintptr
	tcl_FSRegister                         uintptr
	tcl_FSUnregister                       uintptr
	tcl_FSData                             uintptr
	tcl_FSGetTranslatedStringPath          uintptr
	tcl_FSGetFileSystemForPath             uintptr
	tcl_FSGetPathType                      uintptr
	tcl_OutputBuffered                     uintptr
	tcl_FSMountsChanged                    uintptr
	tcl_EvalTokensStandard                 uintptr
	tcl_GetTime                            uintptr
	tcl_CreateObjTrace                     uintptr
	tcl_GetCommandInfoFromToken            uintptr
	tcl_SetCommandInfoFromToken            uintptr
	tcl_DbNewWideIntObj                    uintptr
	tcl_GetWideIntFromObj                  uintptr
	tcl_NewWideIntObj                      uintptr
	tcl_SetWideIntObj                      uintptr
	tcl_AllocStatBuf                       uintptr
	tcl_Seek                               uintptr
	tcl_Tell                               uintptr
	tcl_ChannelWideSeekProc                uintptr
	tcl_DictObjPut                         uintptr
	tcl_DictObjGet                         uintptr
	tcl_DictObjRemove                      uintptr
	tcl_DictObjSize                        uintptr
	tcl_DictObjFirst                       uintptr
	tcl_DictObjNext                        uintptr
	tcl_DictObjDone                        uintptr
	tcl_DictObjPutKeyList                  uintptr
	tcl_DictObjRemoveKeyList               uintptr
	tcl_NewDictObj                         uintptr
	tcl_DbNewDictObj                       uintptr
	tcl_RegisterConfig                     uintptr
	tcl_CreateNamespace                    uintptr
	tcl_DeleteNamespace                    uintptr
	tcl_AppendExportList                   uintptr
	tcl_Export                             uintptr
	tcl_Import                             uintptr
	tcl_ForgetImport                       uintptr
	tcl_GetCurrentNamespace                uintptr
	tcl_GetGlobalNamespace                 uintptr
	tcl_FindNamespace                      uintptr
	tcl_FindCommand                        uintptr
	tcl_GetCommandFromObj                  uintptr
	tcl_GetCommandFullName                 uintptr
	tcl_FSEvalFileEx                       uintptr
	tcl_SetExitProc                        uintptr
	tcl_LimitAddHandler                    uintptr
	tcl_LimitRemoveHandler                 uintptr
	tcl_LimitReady                         uintptr
	tcl_LimitCheck                         uintptr
	tcl_LimitExceeded                      uintptr
	tcl_LimitSetCommands                   uintptr
	tcl_LimitSetTime                       uintptr
	tcl_LimitSetGranularity                uintptr
	tcl_LimitTypeEnabled                   uintptr
	tcl_LimitTypeExceeded                  uintptr
	tcl_LimitTypeSet                       uintptr
	tcl_LimitTypeReset                     uintptr
	tcl_LimitGetCommands                   uintptr
	tcl_LimitGetTime                       uintptr
	tcl_LimitGetGranularity                uintptr
	tcl_SaveInterpState                    uintptr
	tcl_RestoreInterpState                 uintptr
	tcl_DiscardInterpState                 uintptr
	tcl_SetReturnOptions                   uintptr
	tcl_GetReturnOptions                   uintptr
	tcl_IsEnsemble                         uintptr
	tcl_CreateEnsemble                     uintptr
	tcl_FindEnsemble                       uintptr
	tcl_SetEnsembleSubcommandList          uintptr
	tcl_SetEnsembleMappingDict             uintptr
	tcl_SetEnsembleUnknownHandler          uintptr
	tcl_SetEnsembleFlags                   uintptr
	tcl_GetEnsembleSubcommandList          uintptr
	tcl_GetEnsembleMappingDict             uintptr
	tcl_GetEnsembleUnknownHandler          uintptr
	tcl_GetEnsembleFlags                   uintptr
	tcl_GetEnsembleNamespace               uintptr
	tcl_SetTimeProc                        uintptr
	tcl_QueryTimeProc                      uintptr
	tcl_ChannelThreadActionProc            uintptr
	tcl_NewBignumObj                       uintptr
	tcl_DbNewBignumObj                     uintptr
	tcl_SetBignumObj                       uintptr
	tcl_GetBignumFromObj                   uintptr
	tcl_TakeBignumFromObj                  uintptr
	tcl_TruncateChannel                    uintptr
	tcl_ChannelTruncateProc                uintptr
	tcl_SetChannelErrorInterp              uintptr
	tcl_GetChannelErrorInterp              uintptr
	tcl_SetChannelError                    uintptr
	tcl_GetChannelError                    uintptr
	tcl_InitBignumFromDouble               uintptr
	tcl_GetNamespaceUnknownHandler         uintptr
	tcl_SetNamespaceUnknownHandler         uintptr
	tcl_GetEncodingFromObj                 uintptr
	tcl_GetEncodingSearchPath              uintptr
	tcl_SetEncodingSearchPath              uintptr
	tcl_GetEncodingNameFromEnvironment     uintptr
	tcl_PkgRequireProc                     uintptr
	tcl_AppendObjToErrorInfo               uintptr
	tcl_AppendLimitedToObj                 uintptr
	tcl_Format                             uintptr
	tcl_AppendFormatToObj                  uintptr
	tcl_ObjPrintf                          uintptr
	tcl_AppendPrintfToObj                  uintptr
	tcl_CancelEval                         uintptr
	tcl_Canceled                           uintptr
	tcl_CreatePipe                         uintptr
	tcl_NRCreateCommand                    uintptr
	tcl_NREvalObj                          uintptr
	tcl_NREvalObjv                         uintptr
	tcl_NRCmdSwap                          uintptr
	tcl_NRAddCallback                      uintptr
	tcl_NRCallObjProc                      uintptr
	tcl_GetFSDeviceFromStat                uintptr
	tcl_GetFSInodeFromStat                 uintptr
	tcl_GetModeFromStat                    uintptr
	tcl_GetLinkCountFromStat               uintptr
	tcl_GetUserIdFromStat                  uintptr
	tcl_GetGroupIdFromStat                 uintptr
	tcl_GetDeviceTypeFromStat              uintptr
	tcl_GetAccessTimeFromStat              uintptr
	tcl_GetModificationTimeFromStat        uintptr
	tcl_GetChangeTimeFromStat              uintptr
	tcl_GetSizeFromStat                    uintptr
	tcl_GetBlocksFromStat                  uintptr
	tcl_GetBlockSizeFromStat               uintptr
	tcl_SetEnsembleParameterList           uintptr
	tcl_GetEnsembleParameterList           uintptr
	tcl_ParseArgsObjv                      uintptr
	tcl_GetErrorLine                       uintptr
	tcl_SetErrorLine                       uintptr
	tcl_TransferResult                     uintptr
	tcl_InterpActive                       uintptr
	tcl_BackgroundException                uintptr
	tcl_ZlibDeflate                        uintptr
	tcl_ZlibInflate                        uintptr
	tcl_ZlibCRC32                          uintptr
	tcl_ZlibAdler32                        uintptr
	tcl_ZlibStreamInit                     uintptr
	tcl_ZlibStreamGetCommandName           uintptr
	tcl_ZlibStreamEof                      uintptr
	tcl_ZlibStreamChecksum                 uintptr
	tcl_ZlibStreamPut                      uintptr
	tcl_ZlibStreamGet                      uintptr
	tcl_ZlibStreamClose                    uintptr
	tcl_ZlibStreamReset                    uintptr
	tcl_SetStartupScript                   uintptr
	tcl_GetStartupScript                   uintptr
	tcl_CloseEx                            uintptr
	tcl_NRExprObj                          uintptr
	tcl_NRSubstObj                         uintptr
	tcl_LoadFile                           uintptr
	tcl_FindSymbol                         uintptr
	tcl_FSUnloadFile                       uintptr
	tcl_ZlibStreamSetCompressionDictionary uintptr
	reserved631                            uintptr
	reserved632                            uintptr
	reserved633                            uintptr
	reserved634                            uintptr
	reserved635                            uintptr
	reserved636                            uintptr
	reserved637                            uintptr
	reserved638                            uintptr
	reserved639                            uintptr
	reserved640                            uintptr
	reserved641                            uintptr
	reserved642                            uintptr
	reserved643                            uintptr
	reserved644                            uintptr
	reserved645                            uintptr
	reserved646                            uintptr
	reserved647                            uintptr
	tclUnusedStubEntry                     uintptr
}

type TclStubs = TclStubs1 /* tclDecls.h:2522:3 */

// !END!: Do not edit above this line.

// Deprecated Tcl procedures:

// Include platform specific public function declarations that are accessible
// via the stubs table. Make all TclOO symbols MODULE_SCOPE (which only
// has effect on building it as a shared library). See ticket [3010352].

// tclPlatDecls.h --
//
//	Declarations of platform specific Tcl APIs.
//
// Copyright (c) 1998-1999 by Scriptics Corporation.
// All rights reserved.

// WARNING: This file is automatically generated by the tools/genStubs.tcl
// script.  Any modifications to the function declarations below should be made
// in the generic/tcl.decls script.

// TCHAR is needed here for win32, so if it is not defined yet do it here.
// This way, we don't need to include <tchar.h> just for one define.

// !BEGIN!: Do not edit below this line.

// Exported function declarations:

type TclPlatStubs = TclPlatStubs1 /* tclPlatDecls.h:86:3 */

// Returned by `div'.
type div_t = struct {
	quot int32
	rem  int32
} /* stdlib.h:62:5 */

// Returned by `ldiv'.
type ldiv_t = struct {
	quot int64
	rem  int64
} /* stdlib.h:70:5 */

// Returned by `lldiv'.
type lldiv_t = struct {
	quot int64
	rem  int64
} /* stdlib.h:80:5 */

// If this symbol has done its job, get rid of it.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

// Wide character type.
//   Locale-writers should change this as necessary to
//   be big enough to hold unique values not between 0 and 127,
//   and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//   or if we want this type in particular.

//  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.
//    are already defined.
//  BSD/OS 3.1 and FreeBSD [23].x require the MACHINE_ANSI_H check here.
//  NetBSD 5 requires the I386_ANSI_H and X86_64_ANSI_H checks here.

// A null pointer constant.

// Offset of member MEMBER in a struct of type TYPE.

// Type whose alignment is supported in every context and is at least
//   as great as that of any standard type not using alignment
//   specifiers.
type max_align_t = struct {
	__max_align_ll int64
	__max_align_ld float64
} /* stddef.h:437:3 */

// Ensure WORDS_BIGENDIAN is defined correctly:
// Needs to happen here in addition to configure to work with fat compiles on
// Darwin (where configure runs only once for multiple architectures).

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>

// Compatibility header for old-style Unix parameters and limits.
//   Copyright (C) 1995-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Used to tag functions that are only to be visible within the module being
// built and not outside it (where this is supported by the linker).

// Macros used to cast between pointers and integers (e.g. when storing an int
// in ClientData), on 64-bit architectures they avoid gcc warning about "cast
// to/from pointer from/to integer of different size".

// The following procedures allow namespaces to be customized to support
// special name resolution rules for commands/variables.

type Tcl_ResolvedVarInfo1 = struct {
	fetchProc  uintptr
	deleteProc uintptr
}

// The following structure encapsulates the routines needed to resolve a
// variable reference at runtime. Any variable specific state will typically
// be appended to this structure.

type Tcl_ResolvedVarInfo = Tcl_ResolvedVarInfo1 /* tclInt.h:147:3 */

type Tcl_ResolverInfo1 = struct {
	cmdResProc         uintptr
	varResProc         uintptr
	compiledVarResProc uintptr
}

type Tcl_ResolverInfo = Tcl_ResolverInfo1 /* tclInt.h:170:3 */
type NamespacePathEntry1 = struct {
	nsPtr        uintptr
	creatorNsPtr uintptr
	prevPtr      uintptr
	nextPtr      uintptr
}

type NamespacePathEntry = NamespacePathEntry1 /* tclInt.h:194:35 */

// Special hashtable for variables: this is just a Tcl_HashTable with an nsPtr
// field added at the end: in this way variables can find their namespace
// without having to copy a pointer in their struct: they can access it via
// their hPtr->tablePtr.

type TclVarHashTable1 = struct {
	table Tcl_HashTable
	nsPtr uintptr
}

// Special hashtable for variables: this is just a Tcl_HashTable with an nsPtr
// field added at the end: in this way variables can find their namespace
// without having to copy a pointer in their struct: they can access it via
// their hPtr->tablePtr.

type Namespace1 = struct {
	name                  uintptr
	fullName              uintptr
	clientData            ClientData
	deleteProc            uintptr
	parentPtr             uintptr
	childTable            Tcl_HashTable
	nsId                  int64
	interp                uintptr
	flags                 int32
	activationCount       int32
	refCount              int32
	cmdTable              Tcl_HashTable
	varTable              TclVarHashTable
	exportArrayPtr        uintptr
	numExportPatterns     int32
	maxExportPatterns     int32
	cmdRefEpoch           int32
	resolverEpoch         int32
	cmdResProc            uintptr
	varResProc            uintptr
	compiledVarResProc    uintptr
	exportLookupEpoch     int32
	ensembles             uintptr
	unknownHandlerPtr     uintptr
	commandPathLength     int32
	commandPathArray      uintptr
	commandPathSourceList uintptr
	earlyDeleteProc       uintptr
}

// Special hashtable for variables: this is just a Tcl_HashTable with an nsPtr
// field added at the end: in this way variables can find their namespace
// without having to copy a pointer in their struct: they can access it via
// their hPtr->tablePtr.

type TclVarHashTable = TclVarHashTable1 /* tclInt.h:206:3 */

// This is for itcl - it likes to search our varTables directly :(

// Define this to reduce the amount of space that the average namespace
// consumes by only allocating the table of child namespaces when necessary.
// Defining it breaks compatibility for Tcl extensions (e.g., itcl) which
// reach directly into the Namespace structure.

// The structure below defines a namespace.
// Note: the first five fields must match exactly the fields in a
// Tcl_Namespace structure (see tcl.h). If you change one, be sure to change
// the other.

type Namespace = Namespace1 /* tclInt.h:345:3 */

// Flags used to represent the status of a namespace:
//
// NS_DYING -	1 means Tcl_DeleteNamespace has been called to delete the
//		namespace but there are still active call frames on the Tcl
//		stack that refer to the namespace. When the last call frame
//		referring to it has been popped, it's variables and command
//		will be destroyed and it will be marked "dead" (NS_DEAD). The
//		namespace can no longer be looked up by name.
// NS_DEAD -	1 means Tcl_DeleteNamespace has been called to delete the
//		namespace and no call frames still refer to it. Its variables
//		and command have already been destroyed. This bit allows the
//		namespace resolution code to recognize that the namespace is
//		"deleted". When the last namespaceName object in any byte code
//		unit that refers to the namespace has been freed (i.e., when
//		the namespace's refCount is 0), the namespace's storage will
//		be freed.
// NS_KILLED -	1 means that TclTeardownNamespace has already been called on
//		this namespace and it should not be called again [Bug 1355942]
// NS_SUPPRESS_COMPILATION -
//		Marks the commands in this namespace for not being compiled,
//		forcing them to be looked up every time.

// Flags passed to TclGetNamespaceForQualName:
//
// TCL_GLOBAL_ONLY		- (see tcl.h) Look only in the global ns.
// TCL_NAMESPACE_ONLY		- (see tcl.h) Look only in the context ns.
// TCL_CREATE_NS_IF_UNKNOWN	- Create unknown namespaces.
// TCL_FIND_ONLY_NS		- The name sought is a namespace name.

// The client data for an ensemble command. This consists of the table of
// commands that are actually exported by the namespace, and an epoch counter
// that, combined with the exportLookupEpoch field of the namespace structure,
// defines whether the table contains valid data or will need to be recomputed
// next time the ensemble command is called.

type EnsembleConfig1 = struct {
	nsPtr              uintptr
	token              Tcl_Command
	epoch              int32
	subcommandArrayPtr uintptr
	subcommandTable    Tcl_HashTable
	next               uintptr
	flags              int32
	subcommandDict     uintptr
	subcmdList         uintptr
	unknownHandler     uintptr
	parameterList      uintptr
	numParameters      int32
	_                  [4]byte
}

// Flags used to represent the status of a namespace:
//
// NS_DYING -	1 means Tcl_DeleteNamespace has been called to delete the
//		namespace but there are still active call frames on the Tcl
//		stack that refer to the namespace. When the last call frame
//		referring to it has been popped, it's variables and command
//		will be destroyed and it will be marked "dead" (NS_DEAD). The
//		namespace can no longer be looked up by name.
// NS_DEAD -	1 means Tcl_DeleteNamespace has been called to delete the
//		namespace and no call frames still refer to it. Its variables
//		and command have already been destroyed. This bit allows the
//		namespace resolution code to recognize that the namespace is
//		"deleted". When the last namespaceName object in any byte code
//		unit that refers to the namespace has been freed (i.e., when
//		the namespace's refCount is 0), the namespace's storage will
//		be freed.
// NS_KILLED -	1 means that TclTeardownNamespace has already been called on
//		this namespace and it should not be called again [Bug 1355942]
// NS_SUPPRESS_COMPILATION -
//		Marks the commands in this namespace for not being compiled,
//		forcing them to be looked up every time.

// Flags passed to TclGetNamespaceForQualName:
//
// TCL_GLOBAL_ONLY		- (see tcl.h) Look only in the global ns.
// TCL_NAMESPACE_ONLY		- (see tcl.h) Look only in the context ns.
// TCL_CREATE_NS_IF_UNKNOWN	- Create unknown namespaces.
// TCL_FIND_ONLY_NS		- The name sought is a namespace name.

// The client data for an ensemble command. This consists of the table of
// commands that are actually exported by the namespace, and an epoch counter
// that, combined with the exportLookupEpoch field of the namespace structure,
// defines whether the table contains valid data or will need to be recomputed
// next time the ensemble command is called.

type EnsembleConfig = EnsembleConfig1 /* tclInt.h:483:3 */

// Various bits for the EnsembleConfig.flags field.

//----------------------------------------------------------------
// Data structures related to variables. These are used primarily in tclVar.c
//----------------------------------------------------------------

// The following structure defines a variable trace, which is used to invoke a
// specific C procedure whenever certain operations are performed on a
// variable.

type VarTrace1 = struct {
	traceProc  uintptr
	clientData ClientData
	flags      int32
	nextPtr    uintptr
}

// Various bits for the EnsembleConfig.flags field.

//----------------------------------------------------------------
// Data structures related to variables. These are used primarily in tclVar.c
//----------------------------------------------------------------

// The following structure defines a variable trace, which is used to invoke a
// specific C procedure whenever certain operations are performed on a
// variable.

type VarTrace = VarTrace1 /* tclInt.h:516:3 */

// The following structure defines a command trace, which is used to invoke a
// specific C procedure whenever certain operations are performed on a
// command.

type CommandTrace1 = struct {
	traceProc  uintptr
	clientData ClientData
	flags      int32
	nextPtr    uintptr
	refCount   int32
	_          [4]byte
}

// The following structure defines a command trace, which is used to invoke a
// specific C procedure whenever certain operations are performed on a
// command.

type CommandTrace = CommandTrace1 /* tclInt.h:539:3 */

// When a command trace is active (i.e. its associated procedure is executing)
// one of the following structures is linked into a list associated with the
// command's interpreter. The information in the structure is needed in order
// for Tcl to behave reasonably if traces are deleted while traces are active.

type ActiveCommandTrace1 = struct {
	cmdPtr       uintptr
	nextPtr      uintptr
	nextTracePtr uintptr
	reverseScan  int32
	_            [4]byte
}

// When a command trace is active (i.e. its associated procedure is executing)
// one of the following structures is linked into a list associated with the
// command's interpreter. The information in the structure is needed in order
// for Tcl to behave reasonably if traces are deleted while traces are active.

type Command1 = struct {
	hPtr          uintptr
	nsPtr         uintptr
	refCount      int32
	cmdEpoch      int32
	compileProc   uintptr
	objProc       uintptr
	objClientData ClientData
	proc          uintptr
	clientData    ClientData
	deleteProc    uintptr
	deleteData    ClientData
	flags         int32
	importRefPtr  uintptr
	tracePtr      uintptr
	nreProc       uintptr
}

// When a command trace is active (i.e. its associated procedure is executing)
// one of the following structures is linked into a list associated with the
// command's interpreter. The information in the structure is needed in order
// for Tcl to behave reasonably if traces are deleted while traces are active.

type ActiveCommandTrace = ActiveCommandTrace1 /* tclInt.h:559:3 */

// When a variable trace is active (i.e. its associated procedure is
// executing) one of the following structures is linked into a list associated
// with the variable's interpreter. The information in the structure is needed
// in order for Tcl to behave reasonably if traces are deleted while traces
// are active.

type ActiveVarTrace1 = struct {
	varPtr       uintptr
	nextPtr      uintptr
	nextTracePtr uintptr
}

// When a variable trace is active (i.e. its associated procedure is
// executing) one of the following structures is linked into a list associated
// with the variable's interpreter. The information in the structure is needed
// in order for Tcl to behave reasonably if traces are deleted while traces
// are active.

type Var1 = struct {
	flags int32
	value struct{ objPtr uintptr }
}

// When a variable trace is active (i.e. its associated procedure is
// executing) one of the following structures is linked into a list associated
// with the variable's interpreter. The information in the structure is needed
// in order for Tcl to behave reasonably if traces are deleted while traces
// are active.

type ActiveVarTrace = ActiveVarTrace1 /* tclInt.h:578:3 */

// The structure below defines a variable, which associates a string name with
// a Tcl_Obj value. These structures are kept in procedure call frames (for
// local variables recognized by the compiler) or in the heap (for global
// variables and any variable not known to the compiler). For each Var
// structure in the heap, a hash table entry holds the variable name and a
// pointer to the Var structure.

type Var = Var1 /* tclInt.h:604:3 */

type VarInHash1 = struct {
	__var    Var
	refCount int32
	entry    Tcl_HashEntry
}

type VarInHash = VarInHash1 /* tclInt.h:621:3 */

// The variable-length structure below describes a local variable of a
// procedure that was recognized by the compiler. These variables have a name,
// an element in the array of compiler-assigned local variables in the
// procedure's call frame, and various other items of information. If the
// local variable is a formal argument, it may also have a default value. The
// compiler can't recognize local variables whose names are expressions (these
// names are only known at runtime when the expressions are evaluated) or
// local variables that are created as a result of an "upvar" or "uplevel"
// command. These other local variables are kept separately in a hash table in
// the call frame.

type CompiledLocal1 = struct {
	nextPtr     uintptr
	nameLength  int32
	frameIndex  int32
	flags       int32
	defValuePtr uintptr
	resolveInfo uintptr
	name        [1]int8
	_           [7]byte
}

// The variable-length structure below describes a local variable of a
// procedure that was recognized by the compiler. These variables have a name,
// an element in the array of compiler-assigned local variables in the
// procedure's call frame, and various other items of information. If the
// local variable is a formal argument, it may also have a default value. The
// compiler can't recognize local variables whose names are expressions (these
// names are only known at runtime when the expressions are evaluated) or
// local variables that are created as a result of an "upvar" or "uplevel"
// command. These other local variables are kept separately in a hash table in
// the call frame.

type CompiledLocal = CompiledLocal1 /* tclInt.h:928:3 */

// The structure below defines a command procedure, which consists of a
// collection of Tcl commands plus information about arguments and other local
// variables recognized at compile time.

type Proc1 = struct {
	iPtr              uintptr
	refCount          int32
	cmdPtr            uintptr
	bodyPtr           uintptr
	numArgs           int32
	numCompiledLocals int32
	firstLocalPtr     uintptr
	lastLocalPtr      uintptr
}

// The structure below defines a command procedure, which consists of a
// collection of Tcl commands plus information about arguments and other local
// variables recognized at compile time.

type Interp1 = struct {
	result            uintptr
	freeProc          uintptr
	errorLine         int32
	stubTable         uintptr
	handle            TclHandle
	globalNsPtr       uintptr
	hiddenCmdTablePtr uintptr
	interpInfo        ClientData
	extra             struct {
		optimizer uintptr
		_         [80]byte
	}
	numLevels              int32
	maxNestingDepth        int32
	framePtr               uintptr
	varFramePtr            uintptr
	activeVarTracePtr      uintptr
	returnCode             int32
	rootFramePtr           uintptr
	lookupNsPtr            uintptr
	appendResult           uintptr
	appendAvl              int32
	appendUsed             int32
	packageTable           Tcl_HashTable
	packageUnknown         uintptr
	cmdCount               int32
	evalFlags              int32
	unused1                int32
	literalTable           LiteralTable
	compileEpoch           int32
	compiledProcPtr        uintptr
	resolverPtr            uintptr
	scriptFile             uintptr
	flags                  int32
	randSeed               int64
	tracePtr               uintptr
	assocData              uintptr
	execEnvPtr             uintptr
	emptyObjPtr            uintptr
	resultSpace            [201]int8
	objResultPtr           uintptr
	threadId               Tcl_ThreadId
	activeCmdTracePtr      uintptr
	activeInterpTracePtr   uintptr
	tracesForbiddingInline int32
	returnOpts             uintptr
	errorInfo              uintptr
	eiVar                  uintptr
	errorCode              uintptr
	ecVar                  uintptr
	returnLevel            int32
	limit                  struct {
		active            int32
		granularityTicker int32
		exceeded          int32
		cmdCount          int32
		cmdHandlers       uintptr
		cmdGranularity    int32
		time              Tcl_Time
		timeHandlers      uintptr
		timeGranularity   int32
		timeEvent         Tcl_TimerToken
		callbacks         Tcl_HashTable
	}
	ensembleRewrite struct {
		sourceObjs      uintptr
		numRemovedObjs  int32
		numInsertedObjs int32
	}
	chanMsg           uintptr
	cmdFramePtr       uintptr
	invokeCmdFramePtr uintptr
	invokeWord        int32
	linePBodyPtr      uintptr
	lineBCPtr         uintptr
	lineLABCPtr       uintptr
	lineLAPtr         uintptr
	scriptCLLocPtr    uintptr
	packagePrefer     int32
	varTraces         Tcl_HashTable
	varSearches       Tcl_HashTable
	allocCache        uintptr
	pendingObjDataPtr uintptr
	asyncReadyPtr     uintptr
	objectFoundation  uintptr
	deferredCallbacks uintptr
	asyncCancel       Tcl_AsyncHandler
	asyncCancelMsg    uintptr
	errorStack        uintptr
	upLiteral         uintptr
	callLiteral       uintptr
	innerLiteral      uintptr
	innerContext      uintptr
	resetErrorStack   int32
	_                 [4]byte
}

// The structure below defines a command procedure, which consists of a
// collection of Tcl commands plus information about arguments and other local
// variables recognized at compile time.

type Proc = Proc1 /* tclInt.h:963:3 */

// The structure below defines a command trace. This is used to allow Tcl
// clients to find out whenever a command is about to be executed.

type Trace1 = struct {
	level      int32
	proc       uintptr
	clientData ClientData
	nextPtr    uintptr
	flags      int32
	delProc    uintptr
}

// The structure below defines a command trace. This is used to allow Tcl
// clients to find out whenever a command is about to be executed.

type Trace = Trace1 /* tclInt.h:987:3 */

// When an interpreter trace is active (i.e. its associated procedure is
// executing), one of the following structures is linked into a list
// associated with the interpreter. The information in the structure is needed
// in order for Tcl to behave reasonably if traces are deleted while traces
// are active.

type ActiveInterpTrace1 = struct {
	nextPtr      uintptr
	nextTracePtr uintptr
	reverseScan  int32
	_            [4]byte
}

// When an interpreter trace is active (i.e. its associated procedure is
// executing), one of the following structures is linked into a list
// associated with the interpreter. The information in the structure is needed
// in order for Tcl to behave reasonably if traces are deleted while traces
// are active.

type ActiveInterpTrace = ActiveInterpTrace1 /* tclInt.h:1007:3 */

// Flag values designating types of execution traces. See tclTrace.c for
// related flag values.
//
// TCL_TRACE_ENTER_EXEC		- triggers enter/enterstep traces.
// 				- passed to Tcl_CreateObjTrace to set up
//				  "enterstep" traces.
// TCL_TRACE_LEAVE_EXEC		- triggers leave/leavestep traces.
// 				- passed to Tcl_CreateObjTrace to set up
//				  "leavestep" traces.

// The structure below defines an entry in the assocData hash table which is
// associated with an interpreter. The entry contains a pointer to a function
// to call when the interpreter is deleted, and a pointer to a user-defined
// piece of data.

type AssocData1 = struct {
	proc       uintptr
	clientData ClientData
}

// Flag values designating types of execution traces. See tclTrace.c for
// related flag values.
//
// TCL_TRACE_ENTER_EXEC		- triggers enter/enterstep traces.
// 				- passed to Tcl_CreateObjTrace to set up
//				  "enterstep" traces.
// TCL_TRACE_LEAVE_EXEC		- triggers leave/leavestep traces.
// 				- passed to Tcl_CreateObjTrace to set up
//				  "leavestep" traces.

// The structure below defines an entry in the assocData hash table which is
// associated with an interpreter. The entry contains a pointer to a function
// to call when the interpreter is deleted, and a pointer to a user-defined
// piece of data.

type AssocData = AssocData1 /* tclInt.h:1034:3 */

// The structure below defines a call frame. A call frame defines a naming
// context for a procedure call: its local naming scope (for local variables)
// and its global naming scope (a namespace, perhaps the global :: namespace).
// A call frame can also define the naming context for a namespace eval or
// namespace inscope command: the namespace in which the command's code should
// execute. The Tcl_CallFrame structures exist only while procedures or
// namespace eval/inscope's are being executed, and provide a kind of Tcl call
// stack.
//
// WARNING!! The structure definition must be kept consistent with the
// Tcl_CallFrame structure in tcl.h. If you change one, change the other.

// Will be grown to contain: pointers to the varnames (allocated at the end),
// plus the init values for each variable (suitable to be memcopied on init)

type LocalCache1 = struct {
	refCount int32
	numVars  int32
	varName0 uintptr
}

// The structure below defines a call frame. A call frame defines a naming
// context for a procedure call: its local naming scope (for local variables)
// and its global naming scope (a namespace, perhaps the global :: namespace).
// A call frame can also define the naming context for a namespace eval or
// namespace inscope command: the namespace in which the command's code should
// execute. The Tcl_CallFrame structures exist only while procedures or
// namespace eval/inscope's are being executed, and provide a kind of Tcl call
// stack.
//
// WARNING!! The structure definition must be kept consistent with the
// Tcl_CallFrame structure in tcl.h. If you change one, change the other.

// Will be grown to contain: pointers to the varnames (allocated at the end),
// plus the init values for each variable (suitable to be memcopied on init)

type LocalCache = LocalCache1 /* tclInt.h:1059:3 */

type CallFrame1 = struct {
	nsPtr             uintptr
	isProcCallFrame   int32
	objc              int32
	objv              uintptr
	callerPtr         uintptr
	callerVarPtr      uintptr
	level             int32
	procPtr           uintptr
	varTablePtr       uintptr
	numCompiledLocals int32
	compiledLocals    uintptr
	clientData        ClientData
	localCachePtr     uintptr
	tailcallPtr       uintptr
}

type CallFrame = CallFrame1 /* tclInt.h:1123:3 */

// TIP #280
// The structure below defines a command frame. A command frame provides
// location information for all commands executing a tcl script (source, eval,
// uplevel, procedure bodies, ...). The runtime structure essentially contains
// the stack trace as it would be if the currently executing command were to
// throw an error.
//
// For commands where it makes sense it refers to the associated CallFrame as
// well.
//
// The structures are chained in a single list, with the top of the stack
// anchored in the Interp structure.
//
// Instances can be allocated on the C stack, or the heap, the former making
// cleanup a bit simpler.

type CmdFrame1 = struct {
	__type   int32
	level    int32
	line     uintptr
	nline    int32
	framePtr uintptr
	nextPtr  uintptr
	data     struct {
		eval struct{ path uintptr }
		_    [8]byte
	}
	cmdObj uintptr
	cmd    uintptr
	len    int32
	litarg uintptr
}

// TIP #280
// The structure below defines a command frame. A command frame provides
// location information for all commands executing a tcl script (source, eval,
// uplevel, procedure bodies, ...). The runtime structure essentially contains
// the stack trace as it would be if the currently executing command were to
// throw an error.
//
// For commands where it makes sense it refers to the associated CallFrame as
// well.
//
// The structures are chained in a single list, with the top of the stack
// anchored in the Interp structure.
//
// Instances can be allocated on the C stack, or the heap, the former making
// cleanup a bit simpler.

type CFWordBC1 = struct {
	framePtr uintptr
	pc       int32
	word     int32
	prevPtr  uintptr
	nextPtr  uintptr
	obj      uintptr
}

// TIP #280
// The structure below defines a command frame. A command frame provides
// location information for all commands executing a tcl script (source, eval,
// uplevel, procedure bodies, ...). The runtime structure essentially contains
// the stack trace as it would be if the currently executing command were to
// throw an error.
//
// For commands where it makes sense it refers to the associated CallFrame as
// well.
//
// The structures are chained in a single list, with the top of the stack
// anchored in the Interp structure.
//
// Instances can be allocated on the C stack, or the heap, the former making
// cleanup a bit simpler.

type CmdFrame = CmdFrame1 /* tclInt.h:1213:3 */

type CFWord1 = struct {
	framePtr uintptr
	word     int32
	refCount int32
}

type CFWord = CFWord1 /* tclInt.h:1220:3 */

type CFWordBC = CFWordBC1 /* tclInt.h:1232:3 */

// Structure to record the locations of invisible continuation lines in
// literal scripts, as character offset from the beginning of the script. Both
// compiler and direct evaluator use this information to adjust their line
// counters when tracking through the script, because when it is invoked the
// continuation line marker as a whole has been removed already, meaning that
// the \n which was part of it is gone as well, breaking regular line
// tracking.
//
// These structures are allocated and filled by both the function
// TclSubstTokens() in the file "tclParse.c" and its caller TclEvalEx() in the
// file "tclBasic.c", and stored in the thread-global hashtable "lineCLPtr" in
// file "tclObj.c". They are used by the functions TclSetByteCodeFromAny() and
// TclCompileScript(), both found in the file "tclCompile.c". Their memory is
// released by the function TclFreeObj(), in the file "tclObj.c", and also by
// the function TclThreadFinalizeObjects(), in the same file.

type ContLineLoc1 = struct {
	num int32
	loc [1]int32
}

// Structure to record the locations of invisible continuation lines in
// literal scripts, as character offset from the beginning of the script. Both
// compiler and direct evaluator use this information to adjust their line
// counters when tracking through the script, because when it is invoked the
// continuation line marker as a whole has been removed already, meaning that
// the \n which was part of it is gone as well, breaking regular line
// tracking.
//
// These structures are allocated and filled by both the function
// TclSubstTokens() in the file "tclParse.c" and its caller TclEvalEx() in the
// file "tclBasic.c", and stored in the thread-global hashtable "lineCLPtr" in
// file "tclObj.c". They are used by the functions TclSetByteCodeFromAny() and
// TclCompileScript(), both found in the file "tclCompile.c". Their memory is
// released by the function TclFreeObj(), in the file "tclObj.c", and also by
// the function TclThreadFinalizeObjects(), in the same file.

type ContLineLoc = ContLineLoc1 /* tclInt.h:1263:3 */
type ExtraFrameInfoField = struct {
	name       uintptr
	proc       uintptr
	clientData ClientData
} /* tclInt.h:1303:3 */
type ExtraFrameInfo = struct {
	length int32
	fields [2]ExtraFrameInfoField
} /* tclInt.h:1309:3 */

//----------------------------------------------------------------
// Data structures and procedures related to TclHandles, which are a very
// lightweight method of preserving enough information to determine if an
// arbitrary malloc'd block has been deleted.
//----------------------------------------------------------------

type TclHandle = uintptr /* tclInt.h:1319:14 */

// The data structure for a (linked list of) execution stacks.

type ExecStack1 = struct {
	prevPtr    uintptr
	nextPtr    uintptr
	markerPtr  uintptr
	endPtr     uintptr
	tosPtr     uintptr
	stackWords [1]uintptr
}

// The data structure for a (linked list of) execution stacks.

type ExecStack = ExecStack1 /* tclInt.h:1407:3 */

// The data structure defining the execution environment for ByteCode's.
// There is one ExecEnv structure per Tcl interpreter. It holds the evaluation
// stack that holds command operands and results. The stack grows towards
// increasing addresses. The member stackPtr points to the stackItems of the
// currently active execution stack.

type CorContext1 = struct {
	framePtr    uintptr
	varFramePtr uintptr
	cmdFramePtr uintptr
	lineLABCPtr uintptr
}

// The data structure defining the execution environment for ByteCode's.
// There is one ExecEnv structure per Tcl interpreter. It holds the evaluation
// stack that holds command operands and results. The stack grows towards
// increasing addresses. The member stackPtr points to the stackItems of the
// currently active execution stack.

type CorContext = CorContext1 /* tclInt.h:1422:3 */

type CoroutineData1 = struct {
	cmdPtr       uintptr
	eePtr        uintptr
	callerEEPtr  uintptr
	caller       CorContext
	running      CorContext
	lineLABCPtr  uintptr
	stackLevel   uintptr
	auxNumLevels int32
	nargs        int32
}

type ExecEnv1 = struct {
	execStackPtr uintptr
	constants    [2]uintptr
	interp       uintptr
	callbackPtr  uintptr
	corPtr       uintptr
	rewind       int32
	_            [4]byte
}

type CoroutineData = CoroutineData1 /* tclInt.h:1443:3 */

type NRE_callback1 = struct {
	procPtr uintptr
	data    [4]ClientData
	nextPtr uintptr
}

type ExecEnv = ExecEnv1 /* tclInt.h:1454:3 */

// The definitions for the LiteralTable and LiteralEntry structures. Each
// interpreter contains a LiteralTable. It is used to reduce the storage
// needed for all the Tcl objects that hold the literals of scripts compiled
// by the interpreter. A literal's object is shared by all the ByteCodes that
// refer to the literal. Each distinct literal has one LiteralEntry entry in
// the LiteralTable. A literal table is a specialized hash table that is
// indexed by the literal's string representation, which may contain null
// characters.
//
// Note that we reduce the space needed for literals by sharing literal
// objects both within a ByteCode (each ByteCode contains a local
// LiteralTable) and across all an interpreter's ByteCodes (with the
// interpreter's global LiteralTable).

type LiteralEntry1 = struct {
	nextPtr  uintptr
	objPtr   uintptr
	refCount int32
	nsPtr    uintptr
}

// The definitions for the LiteralTable and LiteralEntry structures. Each
// interpreter contains a LiteralTable. It is used to reduce the storage
// needed for all the Tcl objects that hold the literals of scripts compiled
// by the interpreter. A literal's object is shared by all the ByteCodes that
// refer to the literal. Each distinct literal has one LiteralEntry entry in
// the LiteralTable. A literal table is a specialized hash table that is
// indexed by the literal's string representation, which may contain null
// characters.
//
// Note that we reduce the space needed for literals by sharing literal
// objects both within a ByteCode (each ByteCode contains a local
// LiteralTable) and across all an interpreter's ByteCodes (with the
// interpreter's global LiteralTable).

type LiteralEntry = LiteralEntry1 /* tclInt.h:1490:3 */

type LiteralTable1 = struct {
	buckets       uintptr
	staticBuckets [4]uintptr
	numBuckets    int32
	numEntries    int32
	rebuildSize   int32
	mask          int32
}

type LiteralTable = LiteralTable1 /* tclInt.h:1506:3 */

// The following structure defines for each Tcl interpreter various
// statistics-related information about the bytecode compiler and
// interpreter's operation in that interpreter.

// Structure used in implementation of those core ensembles which are
// partially compiled. Used as an array of these, with a terminating field
// whose 'name' is NULL.

type EnsembleImplMap = struct {
	name        uintptr
	proc        uintptr
	compileProc uintptr
	nreProc     uintptr
	clientData  ClientData
	unsafe      int32
	_           [4]byte
} /* tclInt.h:1560:3 */

//----------------------------------------------------------------
// Data structures related to commands.
//----------------------------------------------------------------

// An imported command is created in an namespace when it imports a "real"
// command from another namespace. An imported command has a Command structure
// that points (via its ClientData value) to the "real" Command structure in
// the source namespace's command table. The real command records all the
// imported commands that refer to it in a list of ImportRef structures so
// that they can be deleted when the real command is deleted.

type ImportRef1 = struct {
	importedCmdPtr uintptr
	nextPtr        uintptr
}

//----------------------------------------------------------------
// Data structures related to commands.
//----------------------------------------------------------------

// An imported command is created in an namespace when it imports a "real"
// command from another namespace. An imported command has a Command structure
// that points (via its ClientData value) to the "real" Command structure in
// the source namespace's command table. The real command records all the
// imported commands that refer to it in a list of ImportRef structures so
// that they can be deleted when the real command is deleted.

type ImportRef = ImportRef1 /* tclInt.h:1588:3 */

// Data structure used as the ClientData of imported commands: commands
// created in an namespace when it imports a "real" command from another
// namespace.

type ImportedCmdData1 = struct {
	realCmdPtr uintptr
	selfPtr    uintptr
}

// Data structure used as the ClientData of imported commands: commands
// created in an namespace when it imports a "real" command from another
// namespace.

type ImportedCmdData = ImportedCmdData1 /* tclInt.h:1603:3 */

// A Command structure exists for each command in a namespace. The Tcl_Command
// opaque type actually refers to these structures.

type Command = Command1 /* tclInt.h:1653:3 */

// Flag bits for commands.
//
// CMD_IS_DELETED -		Means that the command is in the process of
//				being deleted (its deleteProc is currently
//				executing). Other attempts to delete the
//				command should be ignored.
// CMD_TRACE_ACTIVE -		1 means that trace processing is currently
//				underway for a rename/delete change. See the
//				two flags below for which is currently being
//				processed.
// CMD_HAS_EXEC_TRACES -	1 means that this command has at least one
//				execution trace (as opposed to simple
//				delete/rename traces) in its tracePtr list.
// CMD_COMPILES_EXPANDED -	1 means that this command has a compiler that
//				can handle expansion (provided it is not the
//				first word).
// TCL_TRACE_RENAME -		A rename trace is in progress. Further
//				recursive renames will not be traced.
// TCL_TRACE_DELETE -		A delete trace is in progress. Further
//				recursive deletes will not be traced.
// (these last two flags are defined in tcl.h)

//----------------------------------------------------------------
// Data structures related to name resolution procedures.
//----------------------------------------------------------------

// The interpreter keeps a linked list of name resolution schemes. The scheme
// for a namespace is consulted first, followed by the list of schemes in an
// interpreter, followed by the default name resolution in Tcl. Schemes are
// added/removed from the interpreter's list by calling Tcl_AddInterpResolver
// and Tcl_RemoveInterpResolver.

type ResolverScheme1 = struct {
	name               uintptr
	cmdResProc         uintptr
	varResProc         uintptr
	compiledVarResProc uintptr
	nextPtr            uintptr
}

// Flag bits for commands.
//
// CMD_IS_DELETED -		Means that the command is in the process of
//				being deleted (its deleteProc is currently
//				executing). Other attempts to delete the
//				command should be ignored.
// CMD_TRACE_ACTIVE -		1 means that trace processing is currently
//				underway for a rename/delete change. See the
//				two flags below for which is currently being
//				processed.
// CMD_HAS_EXEC_TRACES -	1 means that this command has at least one
//				execution trace (as opposed to simple
//				delete/rename traces) in its tracePtr list.
// CMD_COMPILES_EXPANDED -	1 means that this command has a compiler that
//				can handle expansion (provided it is not the
//				first word).
// TCL_TRACE_RENAME -		A rename trace is in progress. Further
//				recursive renames will not be traced.
// TCL_TRACE_DELETE -		A delete trace is in progress. Further
//				recursive deletes will not be traced.
// (these last two flags are defined in tcl.h)

//----------------------------------------------------------------
// Data structures related to name resolution procedures.
//----------------------------------------------------------------

// The interpreter keeps a linked list of name resolution schemes. The scheme
// for a namespace is consulted first, followed by the list of schemes in an
// interpreter, followed by the default name resolution in Tcl. Schemes are
// added/removed from the interpreter's list by calling Tcl_AddInterpResolver
// and Tcl_RemoveInterpResolver.

type ResolverScheme = ResolverScheme1 /* tclInt.h:1716:3 */

//----------------------------------------------------------------
// This structure shadows the first few fields of the memory cache for the
// allocator defined in tclThreadAlloc.c; it has to be kept in sync with the
// definition there.
// Some macros require knowledge of some fields in the struct in order to
// avoid hitting the TSD unnecessarily. In order to facilitate this, a pointer
// to the relevant fields is kept in the allocCache field in struct Interp.
//----------------------------------------------------------------

type AllocCache1 = struct {
	nextPtr     uintptr
	owner       Tcl_ThreadId
	firstObjPtr uintptr
	numObjects  int32
	_           [4]byte
}

//----------------------------------------------------------------
// This structure shadows the first few fields of the memory cache for the
// allocator defined in tclThreadAlloc.c; it has to be kept in sync with the
// definition there.
// Some macros require knowledge of some fields in the struct in order to
// avoid hitting the TSD unnecessarily. In order to facilitate this, a pointer
// to the relevant fields is kept in the allocCache field in struct Interp.
//----------------------------------------------------------------

type AllocCache = AllocCache1 /* tclInt.h:1749:3 */

//----------------------------------------------------------------
// This structure defines an interpreter, which is a collection of commands
// plus other state information related to interpreting commands, such as
// variable storage. Primary responsibility for this data structure is in
// tclBasic.c, but almost every Tcl source file uses something in here.
//----------------------------------------------------------------

type Interp = Interp1 /* tclInt.h:2145:3 */

// Macros that use the TSD-ekeko.

// Macros for script cancellation support (TIP #285).

// Macros for splicing into and out of doubly linked lists. They assume
// existence of struct items 'prevPtr' and 'nextPtr'.
//
// a = element to add or remove.
// b = list head.
//
// TclSpliceIn adds to the head of the list.

// EvalFlag bits for Interp structures:
//
// TCL_ALLOW_EXCEPTIONS	1 means it's OK for the script to terminate with a
//			code other than TCL_OK or TCL_ERROR; 0 means codes
//			other than these should be turned into errors.

// Flag bits for Interp structures:
//
// DELETED:		Non-zero means the interpreter has been deleted:
//			don't process any more commands for it, and destroy
//			the structure as soon as all nested invocations of
//			Tcl_Eval are done.
// ERR_ALREADY_LOGGED:	Non-zero means information has already been logged in
//			iPtr->errorInfo for the current Tcl_Eval instance, so
//			Tcl_Eval needn't log it (used to implement the "error
//			message log" command).
// DONT_COMPILE_CMDS_INLINE: Non-zero means that the bytecode compiler should
//			not compile any commands into an inline sequence of
//			instructions. This is set 1, for example, when command
//			traces are requested.
// RAND_SEED_INITIALIZED: Non-zero means that the randSeed value of the interp
//			has not be initialized. This is set 1 when we first
//			use the rand() or srand() functions.
// SAFE_INTERP:		Non zero means that the current interp is a safe
//			interp (i.e. it has only the safe commands installed,
//			less privilege than a regular interp).
// INTERP_DEBUG_FRAME:	Used for switching on various extra interpreter
//			debug/info mechanisms (e.g. info frame eval/uplevel
//			tracing) which are performance intensive.
// INTERP_TRACE_IN_PROGRESS: Non-zero means that an interp trace is currently
//			active; so no further trace callbacks should be
//			invoked.
// INTERP_ALTERNATE_WRONG_ARGS: Used for listing second and subsequent forms
//			of the wrong-num-args string in Tcl_WrongNumArgs.
//			Makes it append instead of replacing and uses
//			different intermediate text.
// CANCELED:		Non-zero means that the script in progress should be
//			canceled as soon as possible. This can be checked by
//			extensions (and the core itself) by calling
//			Tcl_Canceled and checking if TCL_ERROR is returned.
//			This is a one-shot flag that is reset immediately upon
//			being detected; however, if the TCL_CANCEL_UNWIND flag
//			is set Tcl_Canceled will continue to report that the
//			script in progress has been canceled thereby allowing
//			the evaluation stack for the interp to be fully
//			unwound.
//
// WARNING: For the sake of some extensions that have made use of former
// internal values, do not re-use the flag values 2 (formerly ERR_IN_PROGRESS)
// or 8 (formerly ERROR_CODE_SET).

// Maximum number of levels of nesting permitted in Tcl commands (used to
// catch infinite recursion).

// The macro below is used to modify a "char" value (e.g. by casting it to an
// unsigned character) so that it can be used safely with macros such as
// isspace.

// This macro is used to properly align the memory allocated by Tcl, giving
// the same alignment as the native malloc.

// This macro is used to determine the offset needed to safely allocate any
// data structure in memory. Given a starting offset or size, it "rounds up"
// or "aligns" the offset to the next 8-byte boundary so that any data
// structure can be placed at the resulting offset without fear of an
// alignment error.
//
// WARNING!! DO NOT USE THIS MACRO TO ALIGN POINTERS: it will produce the
// wrong result on platforms that allocate addresses that are divisible by 4
// or 2. Only use it for offsets or sizes.
//
// This macro is only used by tclCompile.c in the core (Bug 926445). It
// however not be made file static, as extensions that touch bytecodes
// (notably tbcload) require it.

// The following enum values are used to specify the runtime platform setting
// of the tclPlatform variable.

type TclPlatformType = uint32 /* tclInt.h:2321:3 */

// The following enum values are used to indicate the translation of a Tcl
// channel. Declared here so that each platform can define
// TCL_PLATFORM_TRANSLATION to the native translation on that platform.

type TclEolTranslation = uint32 /* tclInt.h:2334:3 */

// Flags for TclInvoke:
//
// TCL_INVOKE_HIDDEN		Invoke a hidden command; if not set, invokes
//				an exposed command.
// TCL_INVOKE_NO_UNKNOWN	If set, "unknown" is not invoked if the
//				command to be invoked is not found. Only has
//				an effect if invoking an exposed command,
//				i.e. if TCL_INVOKE_HIDDEN is not also set.
// TCL_INVOKE_NO_TRACEBACK	Does not record traceback information if the
//				invoked command returns an error. Used if the
//				caller plans on recording its own traceback
//				information.

// The structure used as the internal representation of Tcl list objects. This
// struct is grown (reallocated and copied) as necessary to hold all the
// list's element pointers. The struct might contain more slots than currently
// used to hold all element pointers. This is done to make append operations
// faster.

type List1 = struct {
	refCount      int32
	maxElemCount  int32
	elemCount     int32
	canonicalFlag int32
	elements      uintptr
}

// Flags for TclInvoke:
//
// TCL_INVOKE_HIDDEN		Invoke a hidden command; if not set, invokes
//				an exposed command.
// TCL_INVOKE_NO_UNKNOWN	If set, "unknown" is not invoked if the
//				command to be invoked is not found. Only has
//				an effect if invoking an exposed command,
//				i.e. if TCL_INVOKE_HIDDEN is not also set.
// TCL_INVOKE_NO_TRACEBACK	Does not record traceback information if the
//				invoked command returns an error. Used if the
//				caller plans on recording its own traceback
//				information.

// The structure used as the internal representation of Tcl list objects. This
// struct is grown (reallocated and copied) as necessary to hold all the
// list's element pointers. The struct might contain more slots than currently
// used to hold all element pointers. This is done to make append operations
// faster.

type List = List1 /* tclInt.h:2373:3 */

type TclFileAttrProcs1 = struct {
	getProc uintptr
	setProc uintptr
}

type TclFileAttrProcs = TclFileAttrProcs1 /* tclInt.h:2545:3 */

// Opaque handle used in pipeline routines to encapsulate platform-dependent
// state.

type TclFile = uintptr /* tclInt.h:2552:25 */

// The "globParameters" argument of the function TclGlob is an or'ed
// combination of the following values:

type Tcl_PathPart = uint32 /* tclInt.h:2569:3 */

//----------------------------------------------------------------
// Data structures related to procedures
//----------------------------------------------------------------

type TclCmdProcType = uintptr    /* tclInt.h:2588:21 */
type TclObjCmdProcType = uintptr /* tclInt.h:2589:24 */

// A ProcessGlobalValue struct exists for each internal value in Tcl that is
// to be shared among several threads. Each thread sees a (Tcl_Obj) copy of
// the value, and the master is kept as a counted string, with epoch and mutex
// control. Each ProcessGlobalValue struct should be a static variable in some
// file.

type ProcessGlobalValue1 = struct {
	epoch    int32
	numBytes int32
	value    uintptr
	encoding Tcl_Encoding
	proc     uintptr
	mutex    Tcl_Mutex
	key      Tcl_ThreadDataKey
}

// A ProcessGlobalValue struct exists for each internal value in Tcl that is
// to be shared among several threads. Each thread sees a (Tcl_Obj) copy of
// the value, and the master is kept as a counted string, with epoch and mutex
// control. Each ProcessGlobalValue struct should be a static variable in some
// file.

type ProcessGlobalValue = ProcessGlobalValue1 /* tclInt.h:2623:3 */

// This structure holds the data for the various iteration callbacks used to
// NRE the 'for' and 'while' commands. We need a separate structure because we
// have more than the 4 client data entries we can provide directly thorugh
// the callback API. It is the 'word' information which puts us over the
// limit. It is needed because the loop body is argument 4 of 'for' and
// argument 2 of 'while'. Not providing the correct index confuses the #280
// code. We TclSmallAlloc/Free this.

type ForIterData1 = struct {
	cond uintptr
	body uintptr
	next uintptr
	msg  uintptr
	word int32
	_    [4]byte
}

// This structure holds the data for the various iteration callbacks used to
// NRE the 'for' and 'while' commands. We need a separate structure because we
// have more than the 4 client data entries we can provide directly thorugh
// the callback API. It is the 'word' information which puts us over the
// limit. It is needed because the loop body is argument 4 of 'for' and
// argument 2 of 'while'. Not providing the correct index confuses the #280
// code. We TclSmallAlloc/Free this.

type ForIterData = ForIterData1 /* tclInt.h:2799:3 */

type memCmpFn_t = uintptr /* tclInt.h:3162:13 */

//----------------------------------------------------------------
// Macro used by the Tcl core to check whether a pattern has any characters
// special to [string match]. The ANSI C "prototype" for this macro is:
//
// MODULE_SCOPE int	TclMatchIsTrivial(const char *pattern);
//----------------------------------------------------------------

//----------------------------------------------------------------
// Macros used by the Tcl core to set a Tcl_Obj's numeric representation
// avoiding the corresponding function calls in time critical parts of the
// core. They should only be called on unshared objects. The ANSI C
// "prototypes" for these macros are:
//
// MODULE_SCOPE void	TclSetIntObj(Tcl_Obj *objPtr, int intValue);
// MODULE_SCOPE void	TclSetLongObj(Tcl_Obj *objPtr, long longValue);
// MODULE_SCOPE void	TclSetBooleanObj(Tcl_Obj *objPtr, long boolValue);
// MODULE_SCOPE void	TclSetWideIntObj(Tcl_Obj *objPtr, Tcl_WideInt w);
// MODULE_SCOPE void	TclSetDoubleObj(Tcl_Obj *objPtr, double d);
//----------------------------------------------------------------

// NOTE: There is to be no such thing as a "pure" boolean. Boolean values set
// programmatically go straight to being "int" Tcl_Obj's, with value 0 or 1.
// The only "boolean" Tcl_Obj's shall be those holding the cached boolean
// value of strings like: "yes", "no", "true", "false", "on", "off".

//----------------------------------------------------------------
// Macros used by the Tcl core to create and initialise objects of standard
// types, avoiding the corresponding function calls in time critical parts of
// the core. The ANSI C "prototypes" for these macros are:
//
// MODULE_SCOPE void	TclNewIntObj(Tcl_Obj *objPtr, int i);
// MODULE_SCOPE void	TclNewLongObj(Tcl_Obj *objPtr, long l);
// MODULE_SCOPE void	TclNewBooleanObj(Tcl_Obj *objPtr, int b);
// MODULE_SCOPE void	TclNewWideObj(Tcl_Obj *objPtr, Tcl_WideInt w);
// MODULE_SCOPE void	TclNewDoubleObj(Tcl_Obj *objPtr, double d);
// MODULE_SCOPE void	TclNewStringObj(Tcl_Obj *objPtr, char *s, int len);
// MODULE_SCOPE void	TclNewLiteralStringObj(Tcl_Obj*objPtr, char*sLiteral);
//
//----------------------------------------------------------------

// NOTE: There is to be no such thing as a "pure" boolean.
// See comment above TclSetBooleanObj macro above.

// The sLiteral argument *must* be a string literal; the incantation with
// sizeof(sLiteral "") will fail to compile otherwise.

//----------------------------------------------------------------
// Convenience macros for DStrings.
// The ANSI C "prototypes" for these macros are:
//
// MODULE_SCOPE char * TclDStringAppendLiteral(Tcl_DString *dsPtr,
//			const char *sLiteral);
// MODULE_SCOPE void   TclDStringClear(Tcl_DString *dsPtr);

//----------------------------------------------------------------
// Macros used by the Tcl core to test for some special double values.
// The ANSI C "prototypes" for these macros are:
//
// MODULE_SCOPE int	TclIsInfinite(double d);
// MODULE_SCOPE int	TclIsNaN(double d);

// ----------------------------------------------------------------------
// Macro to use to find the offset of a field in a structure. Computes number
// of bytes from beginning of structure to a given field.

//----------------------------------------------------------------
// Inline version of Tcl_GetCurrentNamespace and Tcl_GetGlobalNamespace.

//----------------------------------------------------------------
// Inline version of TclCleanupCommand; still need the function as it is in
// the internal stubs, but the core can use the macro instead.

//----------------------------------------------------------------
// Inline versions of Tcl_LimitReady() and Tcl_LimitExceeded to limit number
// of calls out of the critical path. Note that this code isn't particularly
// readable; the non-inline version (in tclInterp.c) is much easier to
// understand. Note also that these macros takes different args (iPtr->limit)
// to the non-inline version.

// Compile-time assertions: these produce a compile time error if the
// expression is not known to be true at compile time. If the assertion is
// known to be false, the compiler (or optimizer?) will error out with
// "division by zero". If the assertion cannot be evaluated at compile time,
// the compiler will error out with "non-static initializer".
//
// Adapted with permission from
// http://www.pixelbeat.org/programming/gcc/static_assert.html

//----------------------------------------------------------------
// Allocator for small structs (<=sizeof(Tcl_Obj)) using the Tcl_Obj pool.
// Only checked at compile time.
//
// ONLY USE FOR CONSTANT nBytes.
//
// DO NOT LET THEM CROSS THREAD BOUNDARIES
//----------------------------------------------------------------

// Support for Clang Static Analyzer <http://clang-analyzer.llvm.org>

//----------------------------------------------------------------
// Parameters, structs and macros for the non-recursive engine (NRE)
//----------------------------------------------------------------

// This is the main data struct for representing NR commands. It is designed
// to fit in sizeof(Tcl_Obj) in order to exploit the fastest memory allocator
// available.

type NRE_callback = NRE_callback1 /* tclInt.h:4891:3 */

type TclIntStubs = TclIntStubs1 /* tclIntDecls.h:908:3 */

type TclIntPlatStubs = TclIntPlatStubs1 /* tclIntPlatDecls.h:355:3 */

// !END!: Do not edit above this line.

//----------------------------------------------------------------------
//
// tclTomMathDecls.h --
//
//	This file contains the declarations for the 'libtommath'
//	functions that are exported by the Tcl library.
//
// Copyright (c) 2005 by Kevin B. Kenny.  All rights reserved.
//
// See the file "license.terms" for information on usage and redistribution
// of this file, and for a DISCLAIMER OF ALL WARRANTIES.

// tcl.h --
//
//	This header file describes the externally-visible facilities of the
//	Tcl interpreter.
//
// Copyright (c) 1987-1994 The Regents of the University of California.
// Copyright (c) 1993-1996 Lucent Technologies.
// Copyright (c) 1994-1998 Sun Microsystems, Inc.
// Copyright (c) 1998-2000 by Scriptics Corporation.
// Copyright (c) 2002 by Kevin B. Kenny.  All rights reserved.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// MS Visual C++ doesn't have a 128bit type for words, so fall back to 32bit MPI's (where words are 64bit)

// detect 64-bit mode if possible

// some default configurations.
//
// A "mp_digit" must be able to hold MP_DIGIT_BIT + 1 bits
// A "mp_word" must be able to hold 2*MP_DIGIT_BIT + 1 bits
//
// At the very least a mp_digit must be able to hold 7 bits
// [any size beyond that is ok provided it doesn't overflow the data type]

// this is the default case, 28-bit digits

// this is to make porting into LibTomCrypt easier :-)
type private_mp_word = uint64 /* tclTomMath.h:94:30 */

// default case is 28-bit digits, defines MP_28BIT as a handy macro to test

// otherwise the bits per digit is calculated automatically from the size of a mp_digit

// Primality generation flags

type mp_sign = int32   /* tclTomMath.h:163:13 */
type mp_ord = int32    /* tclTomMath.h:166:13 */
type mp_bool = int32   /* tclTomMath.h:170:13 */
type mp_err = int32    /* tclTomMath.h:173:13 */
type mp_order = int32  /* tclTomMath.h:181:13 */
type mp_endian = int32 /* tclTomMath.h:184:13 */

type TclTomMathStubs1 = struct {
	magic                       int32
	hooks                       uintptr
	tclBN_epoch                 uintptr
	tclBN_revision              uintptr
	tclBN_mp_add                uintptr
	tclBN_mp_add_d              uintptr
	tclBN_mp_and                uintptr
	tclBN_mp_clamp              uintptr
	tclBN_mp_clear              uintptr
	tclBN_mp_clear_multi        uintptr
	tclBN_mp_cmp                uintptr
	tclBN_mp_cmp_d              uintptr
	tclBN_mp_cmp_mag            uintptr
	tclBN_mp_copy               uintptr
	tclBN_mp_count_bits         uintptr
	tclBN_mp_div                uintptr
	tclBN_mp_div_d              uintptr
	tclBN_mp_div_2              uintptr
	tclBN_mp_div_2d             uintptr
	tclBN_mp_div_3              uintptr
	tclBN_mp_exch               uintptr
	tclBN_mp_expt_d             uintptr
	tclBN_mp_grow               uintptr
	tclBN_mp_init               uintptr
	tclBN_mp_init_copy          uintptr
	tclBN_mp_init_multi         uintptr
	tclBN_mp_init_set           uintptr
	tclBN_mp_init_size          uintptr
	tclBN_mp_lshd               uintptr
	tclBN_mp_mod                uintptr
	tclBN_mp_mod_2d             uintptr
	tclBN_mp_mul                uintptr
	tclBN_mp_mul_d              uintptr
	tclBN_mp_mul_2              uintptr
	tclBN_mp_mul_2d             uintptr
	tclBN_mp_neg                uintptr
	tclBN_mp_or                 uintptr
	tclBN_mp_radix_size         uintptr
	tclBN_mp_read_radix         uintptr
	tclBN_mp_rshd               uintptr
	tclBN_mp_shrink             uintptr
	tclBN_mp_set                uintptr
	tclBN_mp_sqr                uintptr
	tclBN_mp_sqrt               uintptr
	tclBN_mp_sub                uintptr
	tclBN_mp_sub_d              uintptr
	tclBN_mp_to_unsigned_bin    uintptr
	tclBN_mp_to_unsigned_bin_n  uintptr
	tclBN_mp_toradix_n          uintptr
	tclBN_mp_unsigned_bin_size  uintptr
	tclBN_mp_xor                uintptr
	tclBN_mp_zero               uintptr
	tclBN_reverse               uintptr
	tclBN_fast_s_mp_mul_digs    uintptr
	tclBN_fast_s_mp_sqr         uintptr
	tclBN_mp_karatsuba_mul      uintptr
	tclBN_mp_karatsuba_sqr      uintptr
	tclBN_mp_toom_mul           uintptr
	tclBN_mp_toom_sqr           uintptr
	tclBN_s_mp_add              uintptr
	tclBN_s_mp_mul_digs         uintptr
	tclBN_s_mp_sqr              uintptr
	tclBN_s_mp_sub              uintptr
	tclBN_mp_init_set_int       uintptr
	tclBN_mp_set_int            uintptr
	tclBN_mp_cnt_lsb            uintptr
	tclBNInitBignumFromLong     uintptr
	tclBNInitBignumFromWideInt  uintptr
	tclBNInitBignumFromWideUInt uintptr
	tclBN_mp_expt_d_ex          uintptr
	tclBN_mp_set_ull            uintptr
	reserved69                  uintptr
	reserved70                  uintptr
	reserved71                  uintptr
	reserved72                  uintptr
	tclBN_mp_tc_and             uintptr
	tclBN_mp_tc_or              uintptr
	tclBN_mp_tc_xor             uintptr
	tclBN_mp_signed_rsh         uintptr
	reserved77                  uintptr
	tclBN_mp_to_ubin            uintptr
	reserved79                  uintptr
	tclBN_mp_to_radix           uintptr
}

type TclTomMathStubs = TclTomMathStubs1 /* tclTomMathDecls.h:436:3 */

// These are opaque types.

type Tcl_Class = uintptr         /* tclOO.h:52:27 */
type Tcl_Method = uintptr        /* tclOO.h:53:28 */
type Tcl_Object = uintptr        /* tclOO.h:54:28 */
type Tcl_ObjectContext = uintptr /* tclOO.h:55:35 */

// The type of a method implementation. This describes how to call the method
// implementation, how to delete it (when the object or class is deleted) and
// how to create a clone of it (when the object or class is copied).

type Tcl_MethodType = struct {
	version    int32
	name       uintptr
	callProc   uintptr
	deleteProc uintptr
	cloneProc  uintptr
} /* tclOO.h:93:3 */

// The correct value for the version field of the Tcl_MethodType structure.
// This allows new versions of the structure to be introduced without breaking
// binary compatability.

// The type of some object (or class) metadata. This describes how to delete
// the metadata (when the object or class is deleted) and how to create a
// clone of it (when the object or class is copied).

type Tcl_ObjectMetadataType = struct {
	version    int32
	name       uintptr
	deleteProc uintptr
	cloneProc  uintptr
} /* tclOO.h:120:3 */

type TclOOIntStubs1 = struct {
	magic                         int32
	hooks                         uintptr
	tclOOGetDefineCmdContext      uintptr
	tclOOMakeProcInstanceMethod   uintptr
	tclOOMakeProcMethod           uintptr
	tclOONewProcInstanceMethod    uintptr
	tclOONewProcMethod            uintptr
	tclOOObjectCmdCore            uintptr
	tclOOIsReachable              uintptr
	tclOONewForwardMethod         uintptr
	tclOONewForwardInstanceMethod uintptr
	tclOONewProcInstanceMethodEx  uintptr
	tclOONewProcMethodEx          uintptr
	tclOOInvokeObject             uintptr
	tclOOObjectSetFilters         uintptr
	tclOOClassSetFilters          uintptr
	tclOOObjectSetMixins          uintptr
	tclOOClassSetMixins           uintptr
}

type TclOOStubHooks = struct{ tclOOIntStubs uintptr } /* tclOODecls.h:122:3 */

type TclOOStubs1 = struct {
	magic                         int32
	hooks                         uintptr
	tcl_CopyObjectInstance        uintptr
	tcl_GetClassAsObject          uintptr
	tcl_GetObjectAsClass          uintptr
	tcl_GetObjectCommand          uintptr
	tcl_GetObjectFromObj          uintptr
	tcl_GetObjectNamespace        uintptr
	tcl_MethodDeclarerClass       uintptr
	tcl_MethodDeclarerObject      uintptr
	tcl_MethodIsPublic            uintptr
	tcl_MethodIsType              uintptr
	tcl_MethodName                uintptr
	tcl_NewInstanceMethod         uintptr
	tcl_NewMethod                 uintptr
	tcl_NewObjectInstance         uintptr
	tcl_ObjectDeleted             uintptr
	tcl_ObjectContextIsFiltering  uintptr
	tcl_ObjectContextMethod       uintptr
	tcl_ObjectContextObject       uintptr
	tcl_ObjectContextSkippedArgs  uintptr
	tcl_ClassGetMetadata          uintptr
	tcl_ClassSetMetadata          uintptr
	tcl_ObjectGetMetadata         uintptr
	tcl_ObjectSetMetadata         uintptr
	tcl_ObjectContextInvokeNext   uintptr
	tcl_ObjectGetMethodNameMapper uintptr
	tcl_ObjectSetMethodNameMapper uintptr
	tcl_ClassSetConstructor       uintptr
	tcl_ClassSetDestructor        uintptr
	tcl_GetObjectName             uintptr
}

type TclOOStubs = TclOOStubs1 /* tclOODecls.h:157:3 */

// !END!: Do not edit above this line.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Hack to make things work with Objective C. Note that ObjC isn't really
// supported, but we don't want to to be actively hostile to it. [Bug 2163447]

// Forward declarations.

type CallChain1 = struct {
	objectCreationEpoch int32
	objectEpoch         int32
	epoch               int32
	flags               int32
	refCount            int32
	numChain            int32
	chain               uintptr
	staticChain         [4]struct {
		mPtr           uintptr
		isFilter       int32
		filterDeclarer uintptr
	}
}

type Class1 = struct {
	thisPtr      uintptr
	flags        int32
	superclasses struct {
		num  int32
		list uintptr
	}
	subclasses struct {
		num  int32
		size int32
		list uintptr
	}
	instances struct {
		num  int32
		size int32
		list uintptr
	}
	filters struct {
		num  int32
		list uintptr
	}
	mixins struct {
		num  int32
		list uintptr
	}
	mixinSubs struct {
		num  int32
		size int32
		list uintptr
	}
	classMethods        Tcl_HashTable
	constructorPtr      uintptr
	destructorPtr       uintptr
	metadataPtr         uintptr
	constructorChainPtr uintptr
	destructorChainPtr  uintptr
	classChainCache     uintptr
	variables           struct {
		num  int32
		list uintptr
	}
}

type Foundation1 = struct {
	interp               uintptr
	objectCls            uintptr
	classCls             uintptr
	ooNs                 uintptr
	defineNs             uintptr
	objdefNs             uintptr
	helpersNs            uintptr
	epoch                int32
	tsdPtr               uintptr
	unknownMethodNameObj uintptr
	constructorName      uintptr
	destructorName       uintptr
	clonedName           uintptr
	defineName           uintptr
}

type Object1 = struct {
	fPtr         uintptr
	namespacePtr uintptr
	command      Tcl_Command
	myCommand    Tcl_Command
	selfCls      uintptr
	methodsPtr   uintptr
	mixins       struct {
		num  int32
		list uintptr
	}
	filters struct {
		num  int32
		list uintptr
	}
	classPtr          uintptr
	refCount          int32
	flags             int32
	creationEpoch     int32
	epoch             int32
	metadataPtr       uintptr
	cachedNameObj     uintptr
	chainCache        uintptr
	mapMethodNameProc uintptr
	variables         struct {
		num  int32
		list uintptr
	}
}

// The data that needs to be stored per method. This record is used to collect
// information about all sorts of methods, including forwards, constructors
// and destructors.

type Method1 = struct {
	typePtr            uintptr
	refCount           int32
	clientData         ClientData
	namePtr            uintptr
	declaringObjectPtr uintptr
	declaringClassPtr  uintptr
	flags              int32
	_                  [4]byte
}

// The data that needs to be stored per method. This record is used to collect
// information about all sorts of methods, including forwards, constructors
// and destructors.

type Method = Method1 /* tclOOInt.h:61:3 */

// Procedure-like methods have the following extra information.

type ProcedureMethod1 = struct {
	version              int32
	procPtr              uintptr
	flags                int32
	refCount             int32
	clientData           ClientData
	deleteClientdataProc uintptr
	cloneClientdataProc  uintptr
	errProc              uintptr
	preCallProc          uintptr
	postCallProc         uintptr
	gfivProc             uintptr
}

// Procedure-like methods have the following extra information.

type ProcedureMethod = ProcedureMethod1 /* tclOOInt.h:100:3 */

// Flags for use in a ProcedureMethod.
//
// When the USE_DECLARER_NS flag is set, the method will use the namespace of
// the object or class that declared it (or the clone of it, if it was from
// such that the implementation of the method came to the particular use)
// instead of the namespace of the object on which the method was invoked.
// This flag must be distinct from all others that are associated with
// methods.

// Forwarded methods have the following extra information.

type ForwardMethod1 = struct{ prefixObj uintptr }

// Flags for use in a ProcedureMethod.
//
// When the USE_DECLARER_NS flag is set, the method will use the namespace of
// the object or class that declared it (or the clone of it, if it was from
// such that the implementation of the method came to the particular use)
// instead of the namespace of the object on which the method was invoked.
// This flag must be distinct from all others that are associated with
// methods.

// Forwarded methods have the following extra information.

type ForwardMethod = ForwardMethod1 /* tclOOInt.h:125:3 */

// Helper definitions that declare a "list" array. The two varieties are
// either optimized for simplicity (in the case that the whole array is
// typically assigned at once) or efficiency (in the case that the array is
// expected to be expanded over time). These lists are designed to be iterated
// over with the help of the FOREACH macro (see later in this file).
//
// The "num" field always counts the number of listType_t elements used in the
// "list" field. When a "size" field exists, it describes how many elements
// are present in the list; when absent, exactly "num" elements are present.

// Now, the definition of what an object actually is.

type Object = Object1 /* tclOOInt.h:190:3 */

// And the definition of a class. Note that every class also has an associated
// object, through which it is manipulated.

type Class = Class1 /* tclOOInt.h:270:3 */

// The foundation of the object system within an interpreter contains
// references to the key classes and namespaces, together with a few other
// useful bits and pieces. Probably ought to eventually go in the Interp
// structure itself.

type ThreadLocalData1 = struct{ nsCount int32 }

// The foundation of the object system within an interpreter contains
// references to the key classes and namespaces, together with a few other
// useful bits and pieces. Probably ought to eventually go in the Interp
// structure itself.

type ThreadLocalData = ThreadLocalData1 /* tclOOInt.h:286:3 */

type Foundation = Foundation1 /* tclOOInt.h:318:3 */

// A call context structure is built when a method is called. It contains the
// chain of method implementations that are to be invoked by a particular
// call, and the process of calling walks the chain, with the [next] command
// proceeding to the next entry in the chain.

type MInvoke = struct {
	mPtr           uintptr
	isFilter       int32
	filterDeclarer uintptr
}

type CallChain = CallChain1 /* tclOOInt.h:352:3 */

type CallContext1 = struct {
	oPtr    uintptr
	index   int32
	skip    int32
	callPtr uintptr
}

type CallContext = CallContext1 /* tclOOInt.h:363:3 */

// Bits for the 'flags' field of the call chain.

// Structure containing definition information about basic class methods.

type DeclaredClassMethod = struct {
	name       uintptr
	isPublic   int32
	definition Tcl_MethodType
} /* tclOOInt.h:384:3 */

type TclOOIntStubs = TclOOIntStubs1 /* tclOOIntDecls.h:115:3 */

var tclOOStubsPtr uintptr = (uintptr(0))    /* tclOOStubLib.c:10:18 */
var tclOOIntStubsPtr uintptr = (uintptr(0)) /* tclOOStubLib.c:11:21 */

//----------------------------------------------------------------------
//
// TclOOInitializeStubs --
//	Load the tclOO package, initialize stub table pointer. Do not call
//	this function directly, use Tcl_OOInitStubs() macro instead.
//
// Results:
//	The actual version of the package that satisfies the request, or NULL
//	to indicate that an error occurred.
//
// Side effects:
//	Sets the stub table pointers.
//
//----------------------------------------------------------------------

func TclOOInitializeStubs(tls *crt.TLS, interp uintptr, version uintptr) uintptr { /* tclOOStubLib.c:32:25: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var exact int32 = 0
	var packageName uintptr = ts /* "TclOO" */
	var errMsg uintptr = (uintptr(0))
	*(*uintptr)(unsafe.Pointer(bp + 72 /* stubsPtr */)) = (uintptr(0))
	var actualVersion uintptr = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 24 /* &.tcl_PkgRequireEx */))))(tls, interp,
		packageName, version, exact, bp+72 /* &stubsPtr */)

	if actualVersion == (uintptr(0)) {
		return (uintptr(0))
	}
	if *(*uintptr)(unsafe.Pointer(bp + 72 /* stubsPtr */)) == (uintptr(0)) {
		errMsg = ts + 6 /* "missing stub tab..." */
	} else {
		tclOOStubsPtr = *(*uintptr)(unsafe.Pointer(bp + 72 /* stubsPtr */))
		if (*TclOOStubs)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 72 /* stubsPtr */)))).hooks != 0 {
			tclOOIntStubsPtr = (*TclOOStubHooks)(unsafe.Pointer((*TclOOStubs)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 72 /* stubsPtr */)))).hooks)).tclOOIntStubs
		} else {
			tclOOIntStubsPtr = (uintptr(0))
		}
		return actualVersion
	}
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 1752 /* &.tcl_ResetResult */))))(tls, interp)
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+33 /* "Error loading " */, packageName,
		ts+48 /* " (requested vers..." */, version, ts+69, /* ", actual version..." */
		actualVersion, ts+87 /* "): " */, errMsg, (uintptr(0))))
	return (uintptr(0))
}

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

var tclStubsPtr uintptr = (uintptr(0))        /* tclStubLib.c:21:16 */
var tclPlatStubsPtr uintptr = (uintptr(0))    /* tclStubLib.c:22:20 */
var tclIntStubsPtr uintptr = (uintptr(0))     /* tclStubLib.c:23:19 */
var tclIntPlatStubsPtr uintptr = (uintptr(0)) /* tclStubLib.c:24:23 */

// Use our own isDigit to avoid linking to libc on windows

func isDigit(tls *crt.TLS, c int32) int32 { /* tclStubLib.c:30:12: */
	return (crt.Bool32((c >= '0') && (c <= '9')))
}

//----------------------------------------------------------------------
//
// Tcl_InitStubs --
//
//	Tries to initialise the stub table pointers and ensures that the
//	correct version of Tcl is loaded.
//
// Results:
//	The actual version of Tcl that satisfies the request, or NULL to
//	indicate that an error occurred.
//
// Side effects:
//	Sets the stub table pointers.
//
//----------------------------------------------------------------------
func Tcl_InitStubs(tls *crt.TLS, interp uintptr, version uintptr, exact int32) uintptr { /* tclStubLib.c:53:25: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var iPtr uintptr = interp
	var actualVersion uintptr = (uintptr(0))
	*(*ClientData)(unsafe.Pointer(bp /* pkgData */)) = (uintptr(0))
	var stubsPtr uintptr = (*Interp)(unsafe.Pointer(iPtr)).stubTable

	// We can't optimize this check by caching tclStubsPtr because that
	// prevents apps from being able to load/unload Tcl dynamically multiple
	// times. [Bug 615304]

	if !(stubsPtr != 0) || ((*TclStubs)(unsafe.Pointer(stubsPtr)).magic != (crt.Int32FromUint32(0xFCA3BACF))) {
		(*Interp)(unsafe.Pointer(iPtr)).result = ts + 91 /* "interpreter uses..." */
		(*Interp)(unsafe.Pointer(iPtr)).freeProc = (uintptr(0))
		return (uintptr(0))
	}

	actualVersion = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) uintptr)(unsafe.Pointer((stubsPtr + 24 /* &.tcl_PkgRequireEx */))))(tls, interp, ts+140 /* "Tcl" */, version, 0, bp /* &pkgData */)
	if actualVersion == (uintptr(0)) {
		return (uintptr(0))
	}
	if exact != 0 {
		var p uintptr = version
		var count int32 = 0

		for *(*int8)(unsafe.Pointer(p)) != 0 {
			count = count + (crt.BoolInt32(!(isDigit(tls, int32(*(*int8)(unsafe.Pointer(crt.PostIncUintptr(&p, 1))))) != 0)))
		}
		if count == 1 {
			var q uintptr = actualVersion

			p = version
			for (*(*int8)(unsafe.Pointer(p)) != 0) && (int32(*(*int8)(unsafe.Pointer(p))) == int32(*(*int8)(unsafe.Pointer(q)))) {
				p++
				q++
			}
			if (*(*int8)(unsafe.Pointer(p)) != 0) || (isDigit(tls, int32(*(*int8)(unsafe.Pointer(q)))) != 0) {
				// Construct error message
				(*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) uintptr)(unsafe.Pointer((stubsPtr + 24 /* &.tcl_PkgRequireEx */))))(tls, interp, ts+140 /* "Tcl" */, version, 1, (uintptr(0)))
				return (uintptr(0))
			}
		} else {
			actualVersion = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) uintptr)(unsafe.Pointer((stubsPtr + 24 /* &.tcl_PkgRequireEx */))))(tls, interp, ts+140 /* "Tcl" */, version, 1, (uintptr(0)))
			if actualVersion == (uintptr(0)) {
				return (uintptr(0))
			}
		}
	}
	tclStubsPtr = *(*ClientData)(unsafe.Pointer(bp /* pkgData */))

	if (*TclStubs)(unsafe.Pointer(tclStubsPtr)).hooks != 0 {
		tclPlatStubsPtr = (*TclStubHooks)(unsafe.Pointer((*TclStubs)(unsafe.Pointer(tclStubsPtr)).hooks)).tclPlatStubs
		tclIntStubsPtr = (*TclStubHooks)(unsafe.Pointer((*TclStubs)(unsafe.Pointer(tclStubsPtr)).hooks)).tclIntStubs
		tclIntPlatStubsPtr = (*TclStubHooks)(unsafe.Pointer((*TclStubs)(unsafe.Pointer(tclStubsPtr)).hooks)).tclIntPlatStubs
	} else {
		tclPlatStubsPtr = (uintptr(0))
		tclIntStubsPtr = (uintptr(0))
		tclIntPlatStubsPtr = (uintptr(0))
	}

	return actualVersion
}

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

var tclTomMathStubsPtr uintptr = (uintptr(0)) /* tclTomMathStubLib.c:18:23 */

//----------------------------------------------------------------------
//
// TclTomMathInitStubs --
//
//	Initializes the Stubs table for Tcl's subset of libtommath
//
// Results:
//	Returns a standard Tcl result.
//
// This procedure should not be called directly, but rather through
// the TclTomMath_InitStubs macro, to insure that the Stubs table
// matches the header files used in compilation.
//
//----------------------------------------------------------------------

func TclTomMathInitializeStubs(tls *crt.TLS, interp uintptr, version uintptr, epoch int32, revision int32) uintptr { /* tclTomMathStubLib.c:38:25: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var exact int32 = 0
	var packageName uintptr = ts + 144 /* "tcl::tommath" */
	var errMsg uintptr = (uintptr(0))
	*(*uintptr)(unsafe.Pointer(bp + 72 /* stubsPtr */)) = (uintptr(0))
	var actualVersion uintptr = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 24 /* &.tcl_PkgRequireEx */))))(tls, interp,
		packageName, version, exact, bp+72 /* &stubsPtr */)

	if actualVersion == (uintptr(0)) {
		return (uintptr(0))
	}
	if *(*uintptr)(unsafe.Pointer(bp + 72 /* stubsPtr */)) == (uintptr(0)) {
		errMsg = ts + 6 /* "missing stub tab..." */
	} else if (*(*func(*crt.TLS) int32)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(bp + 72 /* stubsPtr */)) + 16 /* &.tclBN_epoch */))))(tls) != epoch {
		errMsg = ts + 157 /* "epoch number mis..." */
	} else if (*(*func(*crt.TLS) int32)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(bp + 72 /* stubsPtr */)) + 24 /* &.tclBN_revision */))))(tls) != revision {
		errMsg = ts + 179 /* "requires a later..." */
	} else {
		tclTomMathStubsPtr = *(*uintptr)(unsafe.Pointer(bp + 72 /* stubsPtr */))
		return actualVersion
	}
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 1752 /* &.tcl_ResetResult */))))(tls, interp)
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+33 /* "Error loading " */, packageName,
		ts+48 /* " (requested vers..." */, version, ts+69, /* ", actual version..." */
		actualVersion, ts+87 /* "): " */, errMsg, (uintptr(0))))
	return (uintptr(0))
}

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// The following #if block allows you to change how Tcl finds the startup
// script, prime the library or encoding paths, fiddle with the argv, etc.,
// without needing to rewrite Tcl_Main()

//----------------------------------------------------------------------
//
// main --
//
//	This is the main program for the application.
//
// Results:
//	None: Tcl_Main never returns here, so this procedure never returns
//	either.
//
// Side effects:
//	Just about anything, since from here we call arbitrary Tcl code.
//
//----------------------------------------------------------------------

func main(tls *crt.TLS, argc int32, argv uintptr) int32 { /* tclAppInit.c:72:1: */

	tcl.XTcl_MainEx(tls, argc, argv, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) int32 }{Tcl_AppInit})), (tcl.XTcl_CreateInterp(tls)))
	return 0 // Needed only to prevent compiler warning.
}

//----------------------------------------------------------------------
//
// Tcl_AppInit --
//
//	This procedure performs application-specific initialization. Most
//	applications, especially those that incorporate additional packages,
//	will have their own version of this procedure.
//
// Results:
//	Returns a standard Tcl completion code, and leaves an error message in
//	the interp's result if an error occurs.
//
// Side effects:
//	Depends on the startup script.
//
//----------------------------------------------------------------------

func Tcl_AppInit(tls *crt.TLS, interp uintptr) int32 { /* tclAppInit.c:108:1: */
	if tcl.XTcl_Init(tls, interp) == 1 {
		return 1
	}

	if Tcltest_Init(tls, interp) == 1 {
		return 1
	}
	tcl.XTcl_StaticPackage(tls, interp, ts+205 /* "Tcltest" */, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) int32 }{Tcltest_Init})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) int32 }{Tcltest_SafeInit})))

	// Call the init procedures for included packages. Each call should look
	// like this:
	//
	// if (Mod_Init(interp) == TCL_ERROR) {
	//     return TCL_ERROR;
	// }
	//
	// where "Mod" is the name of the module. (Dynamically-loadable packages
	// should have the same entry-point name.)

	// Call Tcl_CreateCommand for application-specific commands, if they
	// weren't already created by the init procedures called above.

	// Specify a user-specific startup file to invoke if the application is
	// run interactively. Typically the startup file is "~/.apprc" where "app"
	// is the name of the application. If this line is deleted then no
	// user-specific startup file will be run under any conditions.

	tcl.XTcl_ObjSetVar2(tls, interp, tcl.XTcl_NewStringObj(tls, ts+213 /* "tcl_rcFileName" */, -1), (uintptr(0)),
		tcl.XTcl_NewStringObj(tls, ts+228 /* "~/.tclshrc" */, -1), 1)

	return 0
}

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Inline function declarations:

// !END!: Do not edit above this line.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// Declarations for math functions.
//   Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.12 Mathematics	<math.h>

// Handle feature test macros at the start of a header.
//   Copyright (C) 2016-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// This header is internal to glibc and should not be included outside
//   of glibc headers.  Headers including it must define
//   __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
//   cannot have multiple include guards because ISO C feature test
//   macros depend on the definition of the macro when an affected
//   header is included, not when the first system header is
//   included.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
//   macro.

// ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
//   macro.

// ISO/IEC TS 18661-4:2015 defines the
//   __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.

// ISO/IEC TS 18661-3:2015 defines the
//   __STDC_WANT_IEC_60559_TYPES_EXT__ macro.

// Get definitions of __intmax_t and __uintmax_t.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//   Copyright (C) 2002-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Get machine-dependent vector math functions declarations.
// Platform-specific SIMD declarations of math functions.
//   Copyright (C) 2014-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Get default empty definitions for simd declarations.
// Empty definitions required for __MATHCALL_VEC unfolding in mathcalls.h.
//   Copyright (C) 2014-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Needed definitions could be generated with:
//   for func in $(grep __MATHCALL_VEC math/bits/mathcalls.h |		 sed -r "s|__MATHCALL_VEC.?\(||; s|,.*||"); do
//     echo "#define __DECL_SIMD_${func}";
//     echo "#define __DECL_SIMD_${func}f";
//     echo "#define __DECL_SIMD_${func}l";
//   done
//

// Gather machine dependent type support.
// Macros to control TS 18661-3 glibc features on x86.
//   Copyright (C) 2017-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Value returned on overflow.  With IEEE 754 floating point, this is
//   +Infinity, otherwise the largest representable positive value.
// This may provoke compiler warnings, and may not be rounded to
//   +Infinity in all IEEE 754 rounding modes, but is the best that can
//   be done in ISO C while remaining a constant expression.  10,000 is
//   greater than the maximum (decimal) exponent for all supported
//   floating-point formats and widths.

// IEEE positive infinity.

// IEEE Not A Number.
// This will raise an "invalid" exception outside static initializers,
//   but is the best that can be done in ISO C while remaining a
//   constant expression.

// Get __GLIBC_FLT_EVAL_METHOD.
// Define __GLIBC_FLT_EVAL_METHOD.  x86 version.
//   Copyright (C) 2016-2018 Free Software Foundation, Inc.
//   This file is part of the GNU C Library.
//
//   The GNU C Library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   The GNU C Library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.
//
//   You should have received a copy of the GNU Lesser General Public
//   License along with the GNU C Library; if not, see
//   <http://www.gnu.org/licenses/>.

// Define the following typedefs.
//
//    float_t	floating-point type at least as wide as `float' used
//		to evaluate `float' expressions
//    double_t	floating-point type at least as wide as `double' used
//		to evaluate `double' expressions
type float_t = float32  /* math.h:149:15 */
type double_t = float64 /* math.h:150:16 */

// GCC bug 66462 means we cannot use the math builtins with -fsignaling-nan,
//   so disable builtins if this is enabled.  When fixed in a newer GCC,
//   the __SUPPORT_SNAN__ check may be skipped for those versions.

// Return number of classification appropriate for X.

// Return nonzero value if sign of X is negative.

// Return nonzero value if X is not +-Inf or NaN.

// Return nonzero value if X is neither zero, subnormal, Inf, nor NaN.

// Return nonzero value if X is a NaN.  We could use `fpclassify' but
//   we already have this functions `__isnan' and it is faster.

// Return nonzero value if X is positive or negative infinity.

// Bitmasks for the math_errhandling macro.

// By default all math functions support both errno and exception handling
//   (except for soft floating point implementations which may only support
//   errno handling).  If errno handling is disabled, exceptions are still
//   supported by GLIBC.  Set math_errhandling to 0 with -ffast-math (this is
//   nonconforming but it is more useful than leaving it undefined).

// Some useful constants.

// The above constants are not adequate for computation using `long double's.
//   Therefore we provide as an extension constants with similar names as a
//   GNU extension.  Provide enough digits for the 128-bit IEEE quad.

// When compiling in strict ISO C compatible mode we must not use the
//   inline functions since they, among other things, do not set the
//   `errno' variable correctly.

// isunordered must always check both operands first for signaling NaNs.

// Get machine-dependent inline versions (if there are any).

// Define special entry points to use when the compiler got told to
//   only expect finite results.

// Required for Testregexp*Cmd
// tclRegexp.h --
//
//	This file contains definitions used internally by Henry Spencer's
//	regular expression code.
//
// Copyright (c) 1998 by Sun Microsystems, Inc.
// Copyright (c) 1998-1999 by Scriptics Corporation.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// tclInt.h --
//
//	Declarations of things used internally by the Tcl interpreter.
//
// Copyright (c) 1987-1993 The Regents of the University of California.
// Copyright (c) 1993-1997 Lucent Technologies.
// Copyright (c) 1994-1998 Sun Microsystems, Inc.
// Copyright (c) 1998-1999 by Scriptics Corporation.
// Copyright (c) 2001, 2002 by Kevin B. Kenny.  All rights reserved.
// Copyright (c) 2007 Daniel A. Steffen <das@users.sourceforge.net>
// Copyright (c) 2006-2008 by Joe Mistachkin.  All rights reserved.
// Copyright (c) 2008 by Miguel Sofer. All rights reserved.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// regular expressions
//
// Copyright (c) 1998, 1999 Henry Spencer.  All rights reserved.
//
// Development of this software was funded, in part, by Cray Research Inc.,
// UUNET Communications Services Inc., Sun Microsystems Inc., and Scriptics
// Corporation, none of whom are responsible for the results. The author
// thanks all of them.
//
// Redistribution and use in source and binary forms -- with or without
// modification -- are permitted for any purpose, provided that
// redistributions in source form retain this entire copyright notice and
// indicate the origin and nature of any modifications.
//
// I'd appreciate being given credit for this package in the documentation of
// software which uses it, but that is not a requirement.
//
// THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
// HENRY SPENCER BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
// OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//
// Prototypes etc. marked with "^" within comments get gathered up (and
// possibly edited) by the regfwd program and inserted near the bottom of this
// file.
//
// We offer the option of declaring one wide-character version of the RE
// functions as well as the char versions. To do that, define __REG_WIDE_T to
// the type of wide characters (unfortunately, there is no consensus that
// wchar_t is suitable) and __REG_WIDE_COMPILE and __REG_WIDE_EXEC to the
// names to be used for the compile and execute functions (suggestion:
// re_Xcomp and re_Xexec, where X is a letter suggestive of the wide type,
// e.g. re_ucomp and re_uexec for Unicode). For cranky old compilers, it may
// be necessary to do something like:
// #define	__REG_WIDE_COMPILE(a,b,c,d)	re_Xcomp(a,b,c,d)
// #define	__REG_WIDE_EXEC(a,b,c,d,e,f,g)	re_Xexec(a,b,c,d,e,f,g)
// rather than just #defining the names as parameterless macros.
//
// For some specialized purposes, it may be desirable to suppress the
// declarations of the "front end" functions, regcomp() and regexec(), or of
// the char versions of the compile and execute functions. To suppress the
// front-end functions, define __REG_NOFRONT. To suppress the char versions,
// define __REG_NOCHAR.
//
// The right place to do those defines (and some others you may want, see
// below) would be <sys/types.h>. If you don't have control of that file, the
// right place to add your own defines to this file is marked below. This is
// normally done automatically, by the makefile and regmkhdr, based on the
// contents of regcustom.h.

// voodoo for C++

// Add your own defines, if needed, here.

// Location where a chunk of regcustom.h is automatically spliced into this
// file (working from its prototype, regproto.h).

// --- begin ---
// ensure certain things don't sneak in from system headers
// interface types
// names and declarations
// --- end ---

// interface types etc.

// regoff_t has to be large enough to hold either off_t or ssize_t, and must
// be signed; it's only a guess that long is suitable, so we offer
// <sys/types.h> an override.
type regoff_t = int64 /* regex.h:123:24 */

// other interface types

// the biggie, a compiled RE (or rather, a front end to same)
type regex_t = struct {
	re_magic int32
	re_nsub  size_t
	re_info  int64
	re_csize int32
	re_endp  uintptr
	re_guts  uintptr
	re_fns   uintptr
} /* regex.h:156:3 */

// result reporting (may acquire more fields later)
type regmatch_t = struct {
	rm_so regoff_t
	rm_eo regoff_t
} /* regex.h:162:3 */

// supplementary control and reporting
type rm_detail_t = struct{ rm_extend regmatch_t } /* regex.h:167:3 */
// automatically gathered by fwd; do not hand-edit
// =====^!^===== end forwards =====^!^=====

// more C++ voodoo

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// The TclRegexp structure encapsulates a compiled regex_t, the flags that
// were used to compile it, and an array of pointers that are used to indicate
// subexpressions after a call to Tcl_RegExpExec. Note that the string and
// objPtr are mutually exclusive. These values are needed by Tcl_RegExpRange
// in order to return pointers into the original string.

type TclRegexp1 = struct {
	flags      int32
	re         regex_t
	string     uintptr
	objPtr     uintptr
	globObjPtr uintptr
	matches    uintptr
	details    rm_detail_t
	refCount   int32
	_          [4]byte
}

// automatically gathered by fwd; do not hand-edit
// =====^!^===== end forwards =====^!^=====

// more C++ voodoo

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// The TclRegexp structure encapsulates a compiled regex_t, the flags that
// were used to compile it, and an array of pointers that are used to indicate
// subexpressions after a call to Tcl_RegExpExec. Note that the string and
// objPtr are mutually exclusive. These values are needed by Tcl_RegExpRange
// in order to return pointers into the original string.

type TclRegexp = TclRegexp1 /* tclRegexp.h:42:3 */

// This value can be passed to `uselocale' and may be returned by it.
//   Passing this value to any other function has undefined behavior.

// Required for the TestChannelCmd and TestChannelEventCmd
// tclIO.h --
//
//	This file provides the generic portions (those that are the same on
//	all platforms and for all channel types) of Tcl's IO facilities.
//
// Copyright (c) 1998-2000 Ajuba Solutions
// Copyright (c) 1995-1997 Sun Microsystems, Inc.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// Make sure that both EAGAIN and EWOULDBLOCK are defined. This does not
// compile on systems where neither is defined. We want both defined so that
// we can test safely for both. In the code we still have to test for both
// because there may be systems on which both are defined and have different
// values.

// struct ChannelBuffer:
//
// Buffers data being sent to or from a channel.

type ChannelBuffer1 = struct {
	refCount    int32
	nextAdded   int32
	nextRemoved int32
	bufLength   int32
	nextPtr     uintptr
	buf         [1]int8
	_           [7]byte
}

// This value can be passed to `uselocale' and may be returned by it.
//   Passing this value to any other function has undefined behavior.

// Required for the TestChannelCmd and TestChannelEventCmd
// tclIO.h --
//
//	This file provides the generic portions (those that are the same on
//	all platforms and for all channel types) of Tcl's IO facilities.
//
// Copyright (c) 1998-2000 Ajuba Solutions
// Copyright (c) 1995-1997 Sun Microsystems, Inc.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// Make sure that both EAGAIN and EWOULDBLOCK are defined. This does not
// compile on systems where neither is defined. We want both defined so that
// we can test safely for both. In the code we still have to test for both
// because there may be systems on which both are defined and have different
// values.

// struct ChannelBuffer:
//
// Buffers data being sent to or from a channel.

type ChannelBuffer = ChannelBuffer1 /* tclIO.h:51:3 */

// How much extra space to allocate in buffer to hold bytes from previous
// buffer (when converting to UTF-8) or to hold bytes that will go to next
// buffer (when converting from UTF-8).

// The following defines the *default* buffer size for channels.

// The following structure describes the information saved from a call to
// "fileevent". This is used later when the event being waited for to invoke
// the saved script in the interpreter designed in this record.

type EventScriptRecord1 = struct {
	chanPtr   uintptr
	scriptPtr uintptr
	interp    uintptr
	mask      int32
	nextPtr   uintptr
}

// How much extra space to allocate in buffer to hold bytes from previous
// buffer (when converting to UTF-8) or to hold bytes that will go to next
// buffer (when converting from UTF-8).

// The following defines the *default* buffer size for channels.

// The following structure describes the information saved from a call to
// "fileevent". This is used later when the event being waited for to invoke
// the saved script in the interpreter designed in this record.

type Channel1 = struct {
	state        uintptr
	instanceData ClientData
	typePtr      uintptr
	downChanPtr  uintptr
	upChanPtr    uintptr
	inQueueHead  uintptr
	inQueueTail  uintptr
	refCount     int32
	_            [4]byte
}

// How much extra space to allocate in buffer to hold bytes from previous
// buffer (when converting to UTF-8) or to hold bytes that will go to next
// buffer (when converting from UTF-8).

// The following defines the *default* buffer size for channels.

// The following structure describes the information saved from a call to
// "fileevent". This is used later when the event being waited for to invoke
// the saved script in the interpreter designed in this record.

type EventScriptRecord = EventScriptRecord1 /* tclIO.h:86:3 */

// struct Channel:
//
// One of these structures is allocated for each open channel. It contains
// data specific to the channel but which belongs to the generic part of the
// Tcl channel mechanism, and it points at an instance specific (and type
// specific) instance data, and at a channel type structure.

type ChannelState1 = struct {
	channelName         uintptr
	flags               int32
	encoding            Tcl_Encoding
	inputEncodingState  Tcl_EncodingState
	inputEncodingFlags  int32
	outputEncodingState Tcl_EncodingState
	outputEncodingFlags int32
	inputTranslation    TclEolTranslation
	outputTranslation   TclEolTranslation
	inEofChar           int32
	outEofChar          int32
	unreportedError     int32
	refCount            int32
	closeCbPtr          uintptr
	outputStage         uintptr
	curOutPtr           uintptr
	outQueueHead        uintptr
	outQueueTail        uintptr
	saveInBufPtr        uintptr
	inQueueHead         uintptr
	inQueueTail         uintptr
	chPtr               uintptr
	interestMask        int32
	scriptRecordPtr     uintptr
	bufSize             int32
	timer               Tcl_TimerToken
	csPtrR              uintptr
	csPtrW              uintptr
	topChanPtr          uintptr
	bottomChanPtr       uintptr
	nextCSPtr           uintptr
	managingThread      Tcl_ThreadId
	chanMsg             uintptr
	unreportedMsg       uintptr
	epoch               int32
	_                   [4]byte
}

// struct Channel:
//
// One of these structures is allocated for each open channel. It contains
// data specific to the channel but which belongs to the generic part of the
// Tcl channel mechanism, and it points at an instance specific (and type
// specific) instance data, and at a channel type structure.

type Channel = Channel1 /* tclIO.h:117:3 */

// struct ChannelState:
//
// One of these structures is allocated for each open channel. It contains
// data specific to the channel but which belongs to the generic part of the
// Tcl channel mechanism, and it points at an instance specific (and type
// specific) instance data, and at a channel type structure.

type ChannelState = ChannelState1 /* tclIO.h:219:3 */

// Dynamic string shared by TestdcallCmd and DelCallbackProc; used to collect
// the results of the various deletion callbacks.

var delString Tcl_DString /* tclTest.c:61:20: */
var delInterp uintptr     /* tclTest.c:62:19: */

// One of the following structures exists for each asynchronous handler
// created by the "testasync" command".

type TestAsyncHandler1 = struct {
	id      int32
	handler Tcl_AsyncHandler
	command uintptr
	nextPtr uintptr
}

// One of the following structures exists for each asynchronous handler
// created by the "testasync" command".

type TestAsyncHandler = TestAsyncHandler1 /* tclTest.c:76:3 */

var firstHandler uintptr = (uintptr(0)) /* tclTest.c:80:25 */

// The dynamic string below is used by the "testdstring" command to test the
// dynamic string facilities.

var dstring Tcl_DString /* tclTest.c:87:20: */

// The command trace below is used by the "testcmdtraceCmd" command to test
// the command tracing facilities.

var cmdTrace Tcl_Trace /* tclTest.c:94:18: */

// One of the following structures exists for each command created by
// TestdelCmd:

type DelCmd1 = struct {
	interp    uintptr
	deleteCmd uintptr
}

// One of the following structures exists for each command created by
// TestdelCmd:

type DelCmd = DelCmd1 /* tclTest.c:105:3 */

// The following is used to keep track of an encoding that invokes a Tcl
// command.

type TclEncoding1 = struct {
	interp     uintptr
	toUtfCmd   uintptr
	fromUtfCmd uintptr
}

// The following is used to keep track of an encoding that invokes a Tcl
// command.

type TclEncoding = TclEncoding1 /* tclTest.c:116:3 */

// The counter below is used to determine if the TestsaveresultFree routine
// was called for a result.

var freeCount int32 /* tclTest.c:123:12: */

// Boolean flag used by the "testsetmainloop" and "testexitmainloop" commands.

var exitMainLoop int32 = 0 /* tclTest.c:129:12 */

// Event structure used in testing the event queue management procedures.

type TestEvent1 = struct {
	header  Tcl_Event
	interp  uintptr
	command uintptr
	tag     uintptr
}

// Event structure used in testing the event queue management procedures.

type TestEvent = TestEvent1 /* tclTest.c:140:3 */

// Simple detach/attach facility for testchannel cut|splice. Allow testing of
// channel transfer in core testsuite.

type TestChannel1 = struct {
	__chan  Tcl_Channel
	nextPtr uintptr
}

// Simple detach/attach facility for testchannel cut|splice. Allow testing of
// channel transfer in core testsuite.

type TestChannel = TestChannel1 /* tclTest.c:150:3 */

var firstDetached uintptr /* tclTest.c:152:20: */

var testReportingFilesystem = Tcl_Filesystem{
	ts + 239, /* "reporting" */
	int32(248),
	(uintptr(0x1)),
	0, // path in
	0,
	0,
	(uintptr(0)), // native to norm
	(uintptr(0)), // convert to native
	0,
	(uintptr(0)), // path type
	(uintptr(0)), // separator
	0,
	0,
	0,
	0,
	0,
	0,
	(uintptr(0)),
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	(uintptr(0)),
	0,
} /* tclTest.c:442:29 */

var simpleFilesystem = Tcl_Filesystem{
	ts + 249, /* "simple" */
	int32(248),
	(uintptr(0x1)),
	0,
	(uintptr(0)),
	(uintptr(0)),
	// No internal to normalized, since we don't create any
	// pure 'internal' Tcl_Obj path representations
	(uintptr(0)),
	// No create native rep function, since we don't use it
	// or 'Tcl_FSNewNativePath'
	(uintptr(0)),
	// Normalize path isn't needed - we assume paths only have
	// one representation
	(uintptr(0)),
	(uintptr(0)),
	(uintptr(0)),
	0,
	0,
	0,
	0,
	(uintptr(0)),
	// We choose not to support symbolic links inside our vfs's
	(uintptr(0)),
	0,
	(uintptr(0)),
	(uintptr(0)),
	(uintptr(0)),
	(uintptr(0)),
	(uintptr(0)),
	(uintptr(0)),
	// No copy file - fallback will occur at Tcl level
	(uintptr(0)),
	// No rename file - fallback will occur at Tcl level
	(uintptr(0)),
	// No copy directory - fallback will occur at Tcl level
	(uintptr(0)),
	// Use stat for lstat
	(uintptr(0)),
	// No load - fallback on core implementation
	(uintptr(0)),
	// We don't need a getcwd or chdir - fallback on Tcl's versions
	(uintptr(0)),
	(uintptr(0)),
} /* tclTest.c:476:29 */

//----------------------------------------------------------------------
//
// Tcltest_Init --
//
//	This procedure performs application-specific initialization. Most
//	applications, especially those that incorporate additional packages,
//	will have their own version of this procedure.
//
// Results:
//	Returns a standard Tcl completion code, and leaves an error message in
//	the interp's result if an error occurs.
//
// Side effects:
//	Depends on the startup script.
//
//----------------------------------------------------------------------

func Tcltest_Init(tls *crt.TLS, interp uintptr) int32 { /* tclTest.c:544:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var t3ArgTypes [2]Tcl_ValueType at bp, 8

	var listPtr uintptr
	// var objv uintptr at bp+16, 8

	// var objc int32 at bp+8, 4

	// var index int32 at bp+24, 4

	if Tcl_InitStubs(tls, interp, ts+256 /* "8.5" */, 0) == (uintptr(0)) {
		return 1
	}
	if (TclTomMathInitializeStubs(tls, (interp), (ts + 256 /* "8.5" */), 0, 0)) == (uintptr(0)) {
		return 1
	}
	if TclOOInitializeStubs(tls, (interp), ts+260 /* "1.1.0" */) == (uintptr(0)) {
		return 1
	}
	// TIP #268: Full patchlevel instead of just major.minor

	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 16 /* &.tcl_PkgProvideEx */))))(tls, interp, ts+205 /* "Tcltest" */, ts+266 /* "8.6.10" */, (uintptr(0))) == 1 {
		return 1
	}

	// Create additional commands and math functions for testing Tcl.

	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+273 /* "gettimes" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{GetTimesObjCmd})), (uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+282 /* "noop" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{NoopCmd})), (uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+282 /* "noop" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{NoopObjCmd})), (uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+287 /* "testpurebytesobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestpurebytesobjObjCmd})), (uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+304 /* "testbytestring" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestbytestringObjCmd})), (uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+319 /* "testwrongnumargs" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestWrongNumArgsObjCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+336 /* "testfilesystem" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestFilesystemObjCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+351 /* "testsimplefilesy..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestSimpleFilesystemObjCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+372, /* "testgetindexfrom..." */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TestGetIndexFromObjStructObjCmd})), (uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+398 /* "testasync" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestasyncCmd})), (uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+408, /* "testbumpinterpep..." */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TestbumpinterpepochObjCmd})), (uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+428 /* "testchannel" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestChannelCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+440 /* "testchannelevent" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestChannelEventCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+457 /* "testcmdtoken" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestcmdtokenCmd})), (uintptr(0)),
		(uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+470 /* "testcmdinfo" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestcmdinfoCmd})), (uintptr(0)),
		(uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+482 /* "testcmdtrace" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestcmdtraceCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+495 /* "testconcatobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestconcatobjCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+509 /* "testcreatecomman..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestcreatecommandCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+527 /* "testdcall" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestdcallCmd})), (uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+537 /* "testdel" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestdelCmd})), (uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+545 /* "testdelassocdata" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestdelassocdataCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+562 /* "testdoubledigits" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestdoubledigitsObjCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 992 /* &.tcl_DStringInit */))))(tls, uintptr(unsafe.Pointer(&dstring)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+579 /* "testdstring" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestdstringCmd})), (uintptr(0)),
		(uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+591 /* "testencoding" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestencodingObjCmd})), (uintptr(0)),
		(uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+604 /* "testevalex" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestevalexObjCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+615 /* "testevalobjv" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestevalobjvObjCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+628 /* "testevent" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TesteventObjCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+638 /* "testexithandler" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestexithandlerCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+654 /* "testexprlong" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestexprlongCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+667 /* "testexprlongobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestexprlongobjCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+683 /* "testexprdouble" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestexprdoubleCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+698 /* "testexprdoubleob..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestexprdoubleobjCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+716 /* "testexprparser" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestexprparserObjCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+731 /* "testexprstring" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestexprstringCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+746 /* "testfevent" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestfeventCmd})), (uintptr(0)),
		(uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+757 /* "testfilelink" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestfilelinkCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+770 /* "testfile" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestfileCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+779, /* "testhashsystemha..." */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TestHashSystemHashCmd})), (uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+798 /* "testgetassocdata" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestgetassocdataCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+815 /* "testgetint" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestgetintCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+826 /* "testgetplatform" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestgetplatformCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+842, /* "testgetvarfullna..." */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TestgetvarfullnameCmd})), (uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+861 /* "testinterpdelete" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestinterpdeleteCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+878 /* "testlink" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestlinkCmd})), (uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+887 /* "testlocale" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestlocaleCmd})), (uintptr(0)),
		(uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+898 /* "testpanic" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestpanicCmd})), (uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+908 /* "testparseargs" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestparseargsCmd})), (uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+922 /* "testparser" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestparserObjCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+933 /* "testparsevar" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestparsevarObjCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+946 /* "testparsevarname" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestparsevarnameObjCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+963 /* "testregexp" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestregexpObjCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+974 /* "testreturn" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestreturnObjCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+985 /* "testsaveresult" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestsaveresultCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+1000 /* "testsetassocdata" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestsetassocdataCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+1017 /* "testsetnoerr" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestsetCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+1030 /* "testseterr" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestsetCmd})),
		uintptr(0x200), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+1041 /* "testset2" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{Testset2Cmd})),
		uintptr(0x200), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+1050 /* "testseterrorcode" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestseterrorcodeCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+1067, /* "testsetobjerrorc..." */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TestsetobjerrorcodeCmd})), (uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+1087, /* "testnumutfchars" */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TestNumUtfCharsCmd})), (uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+1103, /* "testfindfirst" */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TestFindFirstCmd})), (uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+1117, /* "testfindlast" */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TestFindLastCmd})), (uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+1130 /* "testsetplatform" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestsetplatformCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+1146 /* "teststaticpkg" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TeststaticpkgCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+1160, /* "testtranslatefil..." */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
		}{TesttranslatefilenameCmd})), (uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+1182 /* "testupvar" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestupvarCmd})), (uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, ClientData))(unsafe.Pointer((tclStubsPtr + 776 /* &.tcl_CreateMathFunc */))))(tls, interp, ts+1192 /* "T1" */, 0, (uintptr(0)), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, uintptr, uintptr) int32
	}{TestMathFunc})), uintptr(123))
	(*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, ClientData))(unsafe.Pointer((tclStubsPtr + 776 /* &.tcl_CreateMathFunc */))))(tls, interp, ts+1195 /* "T2" */, 0, (uintptr(0)), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, uintptr, uintptr) int32
	}{TestMathFunc})), uintptr(345))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+1198 /* "testmainthread" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestmainthreadCmd})), (uintptr(0)),
		(uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+1213 /* "testsetmainloop" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestsetmainloopCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+1229 /* "testexitmainloop" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestexitmainloopCmd})),
		(uintptr(0)), (uintptr(0)))
	*(*Tcl_ValueType)(unsafe.Pointer(bp /* &t3ArgTypes */ + uintptr(0)*4)) = Tcl_ValueType(2)
	*(*Tcl_ValueType)(unsafe.Pointer(bp /* &t3ArgTypes */ + uintptr(1)*4)) = Tcl_ValueType(2)
	(*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr, ClientData))(unsafe.Pointer((tclStubsPtr + 776 /* &.tcl_CreateMathFunc */))))(tls, interp, ts+1246 /* "T3" */, 2, bp /* &t3ArgTypes */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, uintptr, uintptr) int32
	}{TestMathFunc2})),
		(uintptr(0)))

	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+1249 /* "testnreunwind" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestNREUnwind})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+1263 /* "testnrelevels" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestNRELevels})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+1277 /* "testinterpresolv..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestInterpResolverCmd})),
		(uintptr(0)), (uintptr(0)))

	if TclObjTest_Init(tls, interp) != 0 {
		return 1
	}
	if Procbodytest_Init(tls, interp) != 0 {
		return 1
	}

	// Check for special options used in ../tests/main.test

	listPtr = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 2464 /* &.tcl_GetVar2Ex */))))(tls, interp, ts+1296 /* "argv" */, (uintptr(0)), 1)
	if listPtr != (uintptr(0)) {
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 376 /* &.tcl_ListObjGetElements */))))(tls, interp, listPtr, bp+8 /* &objc */, bp+16 /* &objv */) != 0 {
			return 1
		}
		if (*(*int32)(unsafe.Pointer(bp + 8 /* objc */)) != 0) && ((*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 2448 /* &.tcl_GetIndexFromObjStruct */))))(tls, (uintptr(0)), *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* objv */)) + uintptr(0)*8)), uintptr(unsafe.Pointer(&specialOptions)), int32(8), (uintptr(0)), 1, bp+24 /* &index */) == 0) {
			switch *(*int32)(unsafe.Pointer(bp + 24 /* index */)) {
			case 0:
				return 1
				fallthrough
			case 1:
				(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 896 /* &.tcl_DeleteInterp */))))(tls, interp)
				return 1
				fallthrough
			case 2:
				{
					// var mode int32 at bp+28, 4

					(*(*func(*crt.TLS, uintptr, Tcl_Channel) int32)(unsafe.Pointer((tclStubsPtr + 2032 /* &.tcl_UnregisterChannel */))))(tls, interp,
						(*(*func(*crt.TLS, uintptr, uintptr, uintptr) Tcl_Channel)(unsafe.Pointer((tclStubsPtr + 1224 /* &.tcl_GetChannel */))))(tls, interp, ts+1301 /* "stderr" */, bp+28 /* &mode */))
					return 1
				}
				fallthrough
			case 3:
				if (*(*int32)(unsafe.Pointer(bp + 8 /* objc */)) - 1) != 0 {
					(*(*func(*crt.TLS, uintptr, uintptr, uintptr, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 2552 /* &.tcl_SetVar2Ex */))))(tls, interp, ts+213 /* "tcl_rcFileName" */, (uintptr(0)), *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16 /* objv */)) + uintptr(1)*8)),
						1)
				}
				return 1
			}
		}
	}

	// And finally add any platform specific test commands.

	return TclplatformtestInit(tls, interp)
}

var specialOptions = [5]uintptr{
	ts + 1308 /* "-appinitprocerro..." */, ts + 1326, /* "-appinitprocdele..." */
	ts + 1351 /* "-appinitprocclos..." */, ts + 1375 /* "-appinitprocsetr..." */, (uintptr(0)),
} /* tclTest.c:552:23 */

//----------------------------------------------------------------------
//
// Tcltest_SafeInit --
//
//	This procedure performs application-specific initialization. Most
//	applications, especially those that incorporate additional packages,
//	will have their own version of this procedure.
//
// Results:
//	Returns a standard Tcl completion code, and leaves an error message in
//	the interp's result if an error occurs.
//
// Side effects:
//	Depends on the startup script.
//
//----------------------------------------------------------------------

func Tcltest_SafeInit(tls *crt.TLS, interp uintptr) int32 { /* tclTest.c:793:1: */
	if Tcl_InitStubs(tls, interp, ts+256 /* "8.5" */, 0) == (uintptr(0)) {
		return 1
	}
	return Procbodytest_SafeInit(tls, interp)
}

//----------------------------------------------------------------------
//
// TestasyncCmd --
//
//	This procedure implements the "testasync" command.  It is used
//	to test the asynchronous handler facilities of Tcl.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates, deletes, and invokes handlers.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestasyncCmd(tls *crt.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:821:1: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var asyncPtr uintptr
	var prevPtr uintptr
	// var id int32 at bp+32, 4

	// var code int32 at bp+36, 4

	if !(argc < 2) {
		goto __1
	}
wrongNumArgs:
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, ts+1397 /* "wrong # args" */, (uintptr(0)))
	return 1
__1:
	;
	if !(crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+1410 /* "create" */) == 0) {
		goto __2
	}
	if !(argc != 3) {
		goto __4
	}
	goto wrongNumArgs
__4:
	;
	asyncPtr = ((*(*func(*crt.TLS, uint32) uintptr)(unsafe.Pointer((tclStubsPtr + 40 /* &.tcl_Alloc */))))(tls, (uint32(32))))
	(*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).command = ((*(*func(*crt.TLS, uint32) uintptr)(unsafe.Pointer((tclStubsPtr + 40 /* &.tcl_Alloc */))))(tls, (uint32(crt.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8))) + uint64(1)))))
	crt.Xstrcpy(tls, (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).command, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)))

	(*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).id = nextId
	nextId++
	(*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).handler = (*(*func(*crt.TLS, uintptr, ClientData) Tcl_AsyncHandler)(unsafe.Pointer((tclStubsPtr + 584 /* &.tcl_AsyncCreate */))))(tls, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32) int32
	}{AsyncHandlerProc})),
		(uintptr((intptr_t((*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).id)))))
	(*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).nextPtr = firstHandler
	firstHandler = asyncPtr

	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).id))
	goto __3
__2:
	if !(crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+1417 /* "delete" */) == 0) {
		goto __5
	}
	if !(argc == 2) {
		goto __7
	}

__8:
	if !(firstHandler != (uintptr(0))) {
		goto __9
	}
	asyncPtr = firstHandler
	firstHandler = (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).nextPtr
	(*(*func(*crt.TLS, Tcl_AsyncHandler))(unsafe.Pointer((tclStubsPtr + 592 /* &.tcl_AsyncDelete */))))(tls, (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).handler)
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, ((*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).command))
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, (asyncPtr))
	goto __8
__9:
	;

	return 0
__7:
	;
	if !(argc != 3) {
		goto __10
	}
	goto wrongNumArgs
__10:
	;
	if !((*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), bp+32 /* &id */) != 0) {
		goto __11
	}
	return 1
__11:
	;

	prevPtr = (uintptr(0))
	asyncPtr = firstHandler
__12:
	if !(asyncPtr != (uintptr(0))) {
		goto __14
	}
	if !((*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).id != *(*int32)(unsafe.Pointer(bp + 32 /* id */))) {
		goto __15
	}
	goto __13
__15:
	;
	if !(prevPtr == (uintptr(0))) {
		goto __16
	}
	firstHandler = (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).nextPtr
	goto __17
__16:
	(*TestAsyncHandler)(unsafe.Pointer(prevPtr)).nextPtr = (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).nextPtr
__17:
	;
	(*(*func(*crt.TLS, Tcl_AsyncHandler))(unsafe.Pointer((tclStubsPtr + 592 /* &.tcl_AsyncDelete */))))(tls, (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).handler)
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, ((*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).command))
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, (asyncPtr))
	goto __14
	goto __13
__13:
	prevPtr = asyncPtr
	asyncPtr = (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).nextPtr
	goto __12
	goto __14
__14:
	;
	goto __6
__5:
	if !(crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+1424 /* "mark" */) == 0) {
		goto __18
	}
	if !(argc != 5) {
		goto __20
	}
	goto wrongNumArgs
__20:
	;
	if !(((*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), bp+32 /* &id */) != 0) ||
		((*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)), bp+36 /* &code */) != 0)) {
		goto __21
	}
	return 1
__21:
	;

	asyncPtr = firstHandler
__22:
	if !(asyncPtr != (uintptr(0))) {
		goto __24
	}
	if !((*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).id == *(*int32)(unsafe.Pointer(bp + 32 /* id */))) {
		goto __25
	}
	(*(*func(*crt.TLS, Tcl_AsyncHandler))(unsafe.Pointer((tclStubsPtr + 608 /* &.tcl_AsyncMark */))))(tls, (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).handler)
	goto __24
__25:
	;
	goto __23
__23:
	asyncPtr = (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).nextPtr
	goto __22
	goto __24
__24:
	;
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), -1))

	return *(*int32)(unsafe.Pointer(bp + 36 /* code */))
	goto __19
__18:
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+1429 /* "bad option \"" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)),
		ts+1442 /* "\": must be creat..." */, (uintptr(0))))
	return 1
__19:
	;
__6:
	;
__3:
	;
	return 0
}

var nextId int32 = 1 /* tclTest.c:829:16 */

func AsyncHandlerProc(tls *crt.TLS, clientData ClientData, interp uintptr, code int32) int32 { /* tclTest.c:946:1: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var asyncPtr uintptr
	var id int32 = (int32((clientData)))
	// var listArgv [4]uintptr at bp+24, 32

	var cmd uintptr
	// var string [24]int8 at bp, 24

	for asyncPtr = firstHandler; asyncPtr != (uintptr(0)); asyncPtr = (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).nextPtr {
		if (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).id == id {
			break
		}
	}

	if !(asyncPtr != 0) {
		// Woops - this one was deleted between the AsyncMark and now
		return 0
	}

	(*(*func(*crt.TLS, uintptr, int64) int32)(unsafe.Pointer((tclIntStubsPtr + 208 /* &.tclFormatInt */))))(tls, bp /* &string */, int64(code))
	*(*uintptr)(unsafe.Pointer(bp + 24 /* &listArgv */ + uintptr(0)*8)) = (*TestAsyncHandler)(unsafe.Pointer(asyncPtr)).command
	*(*uintptr)(unsafe.Pointer(bp + 24 /* &listArgv */ + uintptr(1)*8)) = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp))
	*(*uintptr)(unsafe.Pointer(bp + 24 /* &listArgv */ + uintptr(2)*8)) = bp /* &string */
	*(*uintptr)(unsafe.Pointer(bp + 24 /* &listArgv */ + uintptr(3)*8)) = (uintptr(0))
	cmd = (*(*func(*crt.TLS, int32, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1552 /* &.tcl_Merge */))))(tls, 3, bp+24 /* &listArgv */)
	if interp != (uintptr(0)) {
		code = (*(*func(*crt.TLS, uintptr, uintptr, int32, int32) int32)(unsafe.Pointer((tclStubsPtr + 2344 /* &.tcl_EvalEx */))))(tls, interp, cmd, -1, 0)
	} else {
	}
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, (cmd))
	return code
}

//----------------------------------------------------------------------
//
// AsyncThreadProc --
//
//	Delivers an asynchronous event to a handler in another thread.
//
// Results:
//	None.
//
// Side effects:
//	Invokes Tcl_AsyncMark on the handler
//
//----------------------------------------------------------------------

func TestbumpinterpepochObjCmd(tls *crt.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:1031:1: */
	var iPtr uintptr = interp
	if objc != 1 {
		(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+1482 /* "" */)
		return 1
	}
	(*Interp)(unsafe.Pointer(iPtr)).compileEpoch++
	return 0
}

//----------------------------------------------------------------------
//
// TestcmdinfoCmd --
//
//	This procedure implements the "testcmdinfo" command.  It is used to
//	test Tcl_GetCommandInfo, Tcl_SetCommandInfo, and command creation and
//	deletion.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates and deletes various commands and modifies their data.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestcmdinfoCmd(tls *crt.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1066:1: */
	bp := tls.Alloc(344)
	defer tls.Free(344)

	// var info Tcl_CmdInfo at bp+280, 64

	if argc != 3 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+1483 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+1509 /* " option cmdName\"" */, (uintptr(0))))
		return 1
	}
	if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+1410 /* "create" */) == 0 {
		(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
		}{CmdProc1})), ts+1526, /* "original" */
			*(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, ClientData) }{CmdDelProc1})))
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+1417 /* "delete" */) == 0 {
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 992 /* &.tcl_DStringInit */))))(tls, uintptr(unsafe.Pointer(&delString)))
		(*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 840 /* &.tcl_DeleteCommand */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)))
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1000 /* &.tcl_DStringResult */))))(tls, interp, uintptr(unsafe.Pointer(&delString)))
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+1535 /* "get" */) == 0 {
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 1288 /* &.tcl_GetCommandInfo */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), bp+280 /* &info */) == 0 {
			(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, ts+1539 /* "??" */, (uintptr(0)))
			return 0
		}
		if (*Tcl_CmdInfo)(unsafe.Pointer(bp+280 /* &info */)).proc == *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
		}{CmdProc1})) {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+32, ts+1542 /* "CmdProc1" */, ts+1551, /* " " */
				(*Tcl_CmdInfo)(unsafe.Pointer(bp+280 /* &info */)).clientData, (uintptr(0))))
		} else if (*Tcl_CmdInfo)(unsafe.Pointer(bp+280 /* &info */)).proc == *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
		}{CmdProc2})) {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+64, ts+1553 /* "CmdProc2" */, ts+1551, /* " " */
				(*Tcl_CmdInfo)(unsafe.Pointer(bp+280 /* &info */)).clientData, (uintptr(0))))
		} else {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+96, ts+1562 /* "unknown" */, (uintptr(0))))
		}
		if (*Tcl_CmdInfo)(unsafe.Pointer(bp+280 /* &info */)).deleteProc == *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, ClientData) }{CmdDelProc1})) {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+112, ts+1570 /* " CmdDelProc1" */, ts+1551, /* " " */
				(*Tcl_CmdInfo)(unsafe.Pointer(bp+280 /* &info */)).deleteData, (uintptr(0))))
		} else if (*Tcl_CmdInfo)(unsafe.Pointer(bp+280 /* &info */)).deleteProc == *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, ClientData) }{CmdDelProc2})) {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+144, ts+1583 /* " CmdDelProc2" */, ts+1551, /* " " */
				(*Tcl_CmdInfo)(unsafe.Pointer(bp+280 /* &info */)).deleteData, (uintptr(0))))
		} else {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+176, ts+1596 /* " unknown" */, (uintptr(0))))
		}
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+192, ts+1551 /* " " */, (*Tcl_Namespace)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp+280 /* &info */)).namespacePtr)).fullName, (uintptr(0))))
		if (*Tcl_CmdInfo)(unsafe.Pointer(bp+280 /* &info */)).isNativeObjectProc != 0 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+216, ts+1605 /* " nativeObjectPro..." */, (uintptr(0))))
		} else {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+232, ts+1623 /* " stringProc" */, (uintptr(0))))
		}
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+1635 /* "modify" */) == 0 {
		(*Tcl_CmdInfo)(unsafe.Pointer(bp + 280 /* &info */)).proc = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
		}{CmdProc2}))
		(*Tcl_CmdInfo)(unsafe.Pointer(bp + 280 /* &info */)).clientData = ts + 1642 /* "new_command_data" */
		(*Tcl_CmdInfo)(unsafe.Pointer(bp + 280 /* &info */)).objProc = (uintptr(0))
		(*Tcl_CmdInfo)(unsafe.Pointer(bp + 280 /* &info */)).objClientData = (uintptr(0))
		(*Tcl_CmdInfo)(unsafe.Pointer(bp + 280 /* &info */)).deleteProc = *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, ClientData) }{CmdDelProc2}))
		(*Tcl_CmdInfo)(unsafe.Pointer(bp + 280 /* &info */)).deleteData = ts + 1659 /* "new_delete_data" */
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 1824 /* &.tcl_SetCommandInfo */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), bp+280 /* &info */) == 0 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, 0))
		} else {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, 1))
		}
	} else {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+248, ts+1429 /* "bad option \"" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)),
			ts+1675 /* "\": must be creat..." */, (uintptr(0))))
		return 1
	}
	return 0
}

//ARGSUSED
func CmdProc1(tls *crt.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1137:1: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+1717 /* "CmdProc1 " */, clientData, (uintptr(0))))
	return 0
}

//ARGSUSED
func CmdProc2(tls *crt.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1149:1: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+1727 /* "CmdProc2 " */, clientData, (uintptr(0))))
	return 0
}

func CmdDelProc1(tls *crt.TLS, clientData ClientData) { /* tclTest.c:1160:1: */
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 992 /* &.tcl_DStringInit */))))(tls, uintptr(unsafe.Pointer(&delString)))
	(*(*func(*crt.TLS, uintptr, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 952 /* &.tcl_DStringAppend */))))(tls, uintptr(unsafe.Pointer(&delString)), ts+1737 /* "CmdDelProc1 " */, -1)
	(*(*func(*crt.TLS, uintptr, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 952 /* &.tcl_DStringAppend */))))(tls, uintptr(unsafe.Pointer(&delString)), clientData, -1)
}

func CmdDelProc2(tls *crt.TLS, clientData ClientData) { /* tclTest.c:1169:1: */
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 992 /* &.tcl_DStringInit */))))(tls, uintptr(unsafe.Pointer(&delString)))
	(*(*func(*crt.TLS, uintptr, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 952 /* &.tcl_DStringAppend */))))(tls, uintptr(unsafe.Pointer(&delString)), ts+1750 /* "CmdDelProc2 " */, -1)
	(*(*func(*crt.TLS, uintptr, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 952 /* &.tcl_DStringAppend */))))(tls, uintptr(unsafe.Pointer(&delString)), clientData, -1)
}

//----------------------------------------------------------------------
//
// TestcmdtokenCmd --
//
//	This procedure implements the "testcmdtoken" command. It is used to
//	test Tcl_Command tokens and procedures such as Tcl_GetCommandFullName.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates and deletes various commands and modifies their data.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestcmdtokenCmd(tls *crt.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1196:1: */
	bp := tls.Alloc(152)
	defer tls.Free(152)

	var token Tcl_Command
	// var l uintptr at bp+144, 8

	// var buf [30]int8 at bp+112, 30

	if argc != 3 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+1483 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+1763 /* " option arg\"" */, (uintptr(0))))
		return 1
	}
	if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+1410 /* "create" */) == 0 {
		token = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
		}{CmdProc1})),
			ts+1526 /* "original" */, (uintptr(0)))
		crt.Xsprintf(tls, bp+112 /* &buf */, ts+1776 /* "%p" */, crt.VaList(bp+32, token))
		(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, bp+112 /* &buf */, (uintptr(1)))
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+1779 /* "name" */) == 0 {
		var objPtr uintptr

		if crt.X__isoc99_sscanf(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), ts+1776 /* "%p" */, crt.VaList(bp+40, bp+144 /* &l */)) != 1 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+48, ts+1784 /* "bad command toke..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)),
				ts+1804 /* "\"" */, (uintptr(0))))
			return 1
		}

		objPtr = (*(*func(*crt.TLS) uintptr)(unsafe.Pointer((tclStubsPtr + 456 /* &.tcl_NewObj */))))(tls)
		(*(*func(*crt.TLS, uintptr, Tcl_Command, uintptr))(unsafe.Pointer((tclIntStubsPtr + 1000 /* &.tcl_GetCommandFullName */))))(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 144 /* l */)), objPtr)

		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp,
			(*(*func(*crt.TLS, uintptr, Tcl_Command) uintptr)(unsafe.Pointer((tclStubsPtr + 1296 /* &.tcl_GetCommandName */))))(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 144 /* l */))))
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, objPtr))
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (objPtr)
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
			}
		}
	} else {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+80, ts+1429 /* "bad option \"" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)),
			ts+1806 /* "\": must be creat..." */, (uintptr(0))))
		return 1
	}
	return 0
}

//----------------------------------------------------------------------
//
// TestcmdtraceCmd --
//
//	This procedure implements the "testcmdtrace" command. It is used
//	to test Tcl_CreateTrace and Tcl_DeleteTrace.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates and deletes a command trace, and tests the invocation of
//	a procedure by the command trace.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestcmdtraceCmd(tls *crt.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1260:1: */
	bp := tls.Alloc(328)
	defer tls.Free(328)

	// var buffer Tcl_DString at bp+112, 216

	var result int32

	if argc != 3 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+1483 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+1832 /* " option script\"" */, (uintptr(0))))
		return 1
	}

	if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+1848 /* "tracetest" */) == 0 {
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 992 /* &.tcl_DStringInit */))))(tls, bp+112 /* &buffer */)
		cmdTrace = (*(*func(*crt.TLS, uintptr, int32, uintptr, ClientData) Tcl_Trace)(unsafe.Pointer((tclStubsPtr + 808 /* &.tcl_CreateTrace */))))(tls, interp, 50000, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, ClientData, uintptr, int32, uintptr, uintptr, ClientData, int32, uintptr)
		}{CmdTraceProc})), bp+112 /* &buffer */)
		result = (*(*func(*crt.TLS, uintptr, uintptr, int32, int32) int32)(unsafe.Pointer((tclStubsPtr + 2344 /* &.tcl_EvalEx */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), -1, 0)
		if result == 0 {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 1752 /* &.tcl_ResetResult */))))(tls, interp)
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+32, ((*Tcl_DString)(unsafe.Pointer((bp + 112 /* &buffer */))).string), (uintptr(0))))
		}
		(*(*func(*crt.TLS, uintptr, Tcl_Trace))(unsafe.Pointer((tclStubsPtr + 920 /* &.tcl_DeleteTrace */))))(tls, interp, cmdTrace)
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 976 /* &.tcl_DStringFree */))))(tls, bp+112 /* &buffer */)
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+1858 /* "deletetest" */) == 0 {
		// Create a command trace then eval a script to check whether it is
		// called. Note that this trace procedure removes itself as a further
		// check of the robustness of the trace proc calling code in
		// TclNRExecuteByteCode.

		cmdTrace = (*(*func(*crt.TLS, uintptr, int32, uintptr, ClientData) Tcl_Trace)(unsafe.Pointer((tclStubsPtr + 808 /* &.tcl_CreateTrace */))))(tls, interp, 50000, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, ClientData, uintptr, int32, uintptr, uintptr, ClientData, int32, uintptr)
		}{CmdTraceDeleteProc})), (uintptr(0)))
		(*(*func(*crt.TLS, uintptr, uintptr, int32, int32) int32)(unsafe.Pointer((tclStubsPtr + 2344 /* &.tcl_EvalEx */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), -1, 0)
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+1869 /* "leveltest" */) == 0 {
		var iPtr uintptr = interp
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 992 /* &.tcl_DStringInit */))))(tls, bp+112 /* &buffer */)
		cmdTrace = (*(*func(*crt.TLS, uintptr, int32, uintptr, ClientData) Tcl_Trace)(unsafe.Pointer((tclStubsPtr + 808 /* &.tcl_CreateTrace */))))(tls, interp, ((*Interp)(unsafe.Pointer(iPtr)).numLevels + 4), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, ClientData, uintptr, int32, uintptr, uintptr, ClientData, int32, uintptr)
		}{CmdTraceProc})),
			bp+112 /* &buffer */)
		result = (*(*func(*crt.TLS, uintptr, uintptr, int32, int32) int32)(unsafe.Pointer((tclStubsPtr + 2344 /* &.tcl_EvalEx */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), -1, 0)
		if result == 0 {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 1752 /* &.tcl_ResetResult */))))(tls, interp)
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+48, ((*Tcl_DString)(unsafe.Pointer((bp + 112 /* &buffer */))).string), (uintptr(0))))
		}
		(*(*func(*crt.TLS, uintptr, Tcl_Trace))(unsafe.Pointer((tclStubsPtr + 920 /* &.tcl_DeleteTrace */))))(tls, interp, cmdTrace)
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 976 /* &.tcl_DStringFree */))))(tls, bp+112 /* &buffer */)
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+1879 /* "resulttest" */) == 0 {

		deleteCalled = 0
		cmdTrace = (*(*func(*crt.TLS, uintptr, int32, int32, uintptr, ClientData, uintptr) Tcl_Trace)(unsafe.Pointer((tclStubsPtr + 3880 /* &.tcl_CreateObjTrace */))))(tls, interp, 50000,
			0x20000, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, ClientData, uintptr, int32, uintptr, Tcl_Command, int32, uintptr) int32
			}{ObjTraceProc})),
			uintptr(unsafe.Pointer(&deleteCalled)), *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, ClientData) }{ObjTraceDeleteProc})))
		result = (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 1048 /* &.tcl_Eval */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)))
		(*(*func(*crt.TLS, uintptr, Tcl_Trace))(unsafe.Pointer((tclStubsPtr + 920 /* &.tcl_DeleteTrace */))))(tls, interp, cmdTrace)
		if !(deleteCalled != 0) {
			(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, ts+1890 /* "Delete wasn't ca..." */, (uintptr(0)))
			return 1
		} else {
			return result
		}
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+1911 /* "doubletest" */) == 0 {
		var t1 Tcl_Trace
		var t2 Tcl_Trace

		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 992 /* &.tcl_DStringInit */))))(tls, bp+112 /* &buffer */)
		t1 = (*(*func(*crt.TLS, uintptr, int32, uintptr, ClientData) Tcl_Trace)(unsafe.Pointer((tclStubsPtr + 808 /* &.tcl_CreateTrace */))))(tls, interp, 1, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, ClientData, uintptr, int32, uintptr, uintptr, ClientData, int32, uintptr)
		}{CmdTraceProc})), bp+112 /* &buffer */)
		t2 = (*(*func(*crt.TLS, uintptr, int32, uintptr, ClientData) Tcl_Trace)(unsafe.Pointer((tclStubsPtr + 808 /* &.tcl_CreateTrace */))))(tls, interp, 50000, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, ClientData, uintptr, int32, uintptr, uintptr, ClientData, int32, uintptr)
		}{CmdTraceProc})), bp+112 /* &buffer */)
		result = (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 1048 /* &.tcl_Eval */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)))
		if result == 0 {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 1752 /* &.tcl_ResetResult */))))(tls, interp)
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+64, ((*Tcl_DString)(unsafe.Pointer((bp + 112 /* &buffer */))).string), (uintptr(0))))
		}
		(*(*func(*crt.TLS, uintptr, Tcl_Trace))(unsafe.Pointer((tclStubsPtr + 920 /* &.tcl_DeleteTrace */))))(tls, interp, t2)
		(*(*func(*crt.TLS, uintptr, Tcl_Trace))(unsafe.Pointer((tclStubsPtr + 920 /* &.tcl_DeleteTrace */))))(tls, interp, t1)
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 976 /* &.tcl_DStringFree */))))(tls, bp+112 /* &buffer */)
	} else {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+80, ts+1429 /* "bad option \"" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)),
			ts+1922 /* "\": must be trace..." */, (uintptr(0))))
		return 1
	}
	return 0
}

var deleteCalled int32 /* tclTest.c:1312:13: */

func CmdTraceProc(tls *crt.TLS, clientData ClientData, interp uintptr, level int32, command uintptr, cmdProc uintptr, cmdClientData ClientData, argc int32, argv uintptr) { /* tclTest.c:1349:1: */
	var bufPtr uintptr = clientData
	var i int32

	(*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 960 /* &.tcl_DStringAppendElement */))))(tls, bufPtr, command)

	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 1016 /* &.tcl_DStringStartSublist */))))(tls, bufPtr)
	for i = 0; i < argc; i++ {
		(*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 960 /* &.tcl_DStringAppendElement */))))(tls, bufPtr, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
	}
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 968 /* &.tcl_DStringEndSublist */))))(tls, bufPtr)
}

func CmdTraceDeleteProc(tls *crt.TLS, clientData ClientData, interp uintptr, level int32, command uintptr, cmdProc uintptr, cmdClientData ClientData, argc int32, argv uintptr) { /* tclTest.c:1376:1: */
	// Remove ourselves to test whether calling Tcl_DeleteTrace within a trace
	// callback causes the for loop in TclNRExecuteByteCode that calls traces to
	// reference freed memory.

	(*(*func(*crt.TLS, uintptr, Tcl_Trace))(unsafe.Pointer((tclStubsPtr + 920 /* &.tcl_DeleteTrace */))))(tls, interp, cmdTrace)
}

func ObjTraceProc(tls *crt.TLS, clientData ClientData, interp uintptr, level int32, command uintptr, token Tcl_Command, objc int32, objv uintptr) int32 { /* tclTest.c:1398:1: */
	var word uintptr = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)))

	if !(crt.Xstrcmp(tls, word, ts+1981 /* "Error" */) != 0) {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, command, -1))
		return 1
	} else if !(crt.Xstrcmp(tls, word, ts+1987 /* "Break" */) != 0) {
		return 3
	} else if !(crt.Xstrcmp(tls, word, ts+1993 /* "Continue" */) != 0) {
		return 4
	} else if !(crt.Xstrcmp(tls, word, ts+2002 /* "Return" */) != 0) {
		return 2
	} else if !(crt.Xstrcmp(tls, word, ts+2009 /* "OtherStatus" */) != 0) {
		return 6
	} else {
		return 0
	}
	return int32(0)
}

func ObjTraceDeleteProc(tls *crt.TLS, clientData ClientData) { /* tclTest.c:1426:1: */
	var intPtr uintptr = clientData
	*(*int32)(unsafe.Pointer(intPtr)) = 1 // Record that the trace was deleted
}

//----------------------------------------------------------------------
//
// TestcreatecommandCmd --
//
//	This procedure implements the "testcreatecommand" command. It is used
//	to test that the Tcl_CreateCommand creates a new command in the
//	namespace specified as part of its name, if any. It also checks that
//	the namespace code ignore single ":"s in the middle or end of a
//	command name.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates and deletes two commands ("test_ns_basic::createdcommand"
//	and "value:at:").
//
//----------------------------------------------------------------------

func TestcreatecommandCmd(tls *crt.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1455:1: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	if argc != 2 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+1483 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+2021 /* " option\"" */, (uintptr(0))))
		return 1
	}
	if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+1410 /* "create" */) == 0 {
		(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+2030, /* "test_ns_basic::c..." */
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
			}{CreatedCommandProc})), (uintptr(0)), (uintptr(0)))
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+1417 /* "delete" */) == 0 {
		(*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 840 /* &.tcl_DeleteCommand */))))(tls, interp, ts+2030 /* "test_ns_basic::c..." */)
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+2060 /* "create2" */) == 0 {
		(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+2068, /* "value:at:" */
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
			}{CreatedCommandProc2})), (uintptr(0)), (uintptr(0)))
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+2078 /* "delete2" */) == 0 {
		(*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 840 /* &.tcl_DeleteCommand */))))(tls, interp, ts+2068 /* "value:at:" */)
	} else {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+32, ts+1429 /* "bad option \"" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)),
			ts+2086 /* "\": must be creat..." */, (uintptr(0))))
		return 1
	}
	return 0
}

func CreatedCommandProc(tls *crt.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1485:1: */
	bp := tls.Alloc(104)
	defer tls.Free(104)

	// var info Tcl_CmdInfo at bp+40, 64

	var found int32

	found = (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 1288 /* &.tcl_GetCommandInfo */))))(tls, interp, ts+2030, /* "test_ns_basic::c..." */
		bp+40 /* &info */)
	if !(found != 0) {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+2133, /* "CreatedCommandPr..." */
			(uintptr(0))))
		return 1
	}
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+16, ts+2213, /* "CreatedCommandPr..." */
		(*Tcl_Namespace)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp+40 /* &info */)).namespacePtr)).fullName, (uintptr(0))))
	return 0
}

func CreatedCommandProc2(tls *crt.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1507:1: */
	bp := tls.Alloc(104)
	defer tls.Free(104)

	// var info Tcl_CmdInfo at bp+40, 64

	var found int32

	found = (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 1288 /* &.tcl_GetCommandInfo */))))(tls, interp, ts+2068 /* "value:at:" */, bp+40 /* &info */)
	if !(found != 0) {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+2236, /* "CreatedCommandPr..." */
			(uintptr(0))))
		return 1
	}
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+16, ts+2317, /* "CreatedCommandPr..." */
		(*Tcl_Namespace)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp+40 /* &info */)).namespacePtr)).fullName, (uintptr(0))))
	return 0
}

//----------------------------------------------------------------------
//
// TestdcallCmd --
//
//	This procedure implements the "testdcall" command.  It is used
//	to test Tcl_CallWhenDeleted.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates and deletes interpreters.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestdcallCmd(tls *crt.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1546:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var i int32
	// var id int32 at bp, 4

	delInterp = ((*(*func(*crt.TLS) uintptr)(unsafe.Pointer((tclStubsPtr + 768 /* &.tcl_CreateInterp */))))(tls))
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 992 /* &.tcl_DStringInit */))))(tls, uintptr(unsafe.Pointer(&delString)))
	for i = 1; i < argc; i++ {
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), bp /* &id */) != 0 {
			return 1
		}
		if *(*int32)(unsafe.Pointer(bp /* id */)) < 0 {
			(*(*func(*crt.TLS, uintptr, uintptr, ClientData))(unsafe.Pointer((tclStubsPtr + 928 /* &.tcl_DontCallWhenDeleted */))))(tls, delInterp, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, ClientData, uintptr)
			}{DelCallbackProc})),
				(uintptr((intptr_t(-*(*int32)(unsafe.Pointer(bp /* id */)))))))
		} else {
			(*(*func(*crt.TLS, uintptr, uintptr, ClientData))(unsafe.Pointer((tclStubsPtr + 648 /* &.tcl_CallWhenDeleted */))))(tls, delInterp, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, ClientData, uintptr)
			}{DelCallbackProc})),
				(uintptr((intptr_t(*(*int32)(unsafe.Pointer(bp /* id */)))))))
		}
	}
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 896 /* &.tcl_DeleteInterp */))))(tls, delInterp)
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1000 /* &.tcl_DStringResult */))))(tls, interp, uintptr(unsafe.Pointer(&delString)))
	return 0
}

// The deletion callback used by TestdcallCmd:

func DelCallbackProc(tls *crt.TLS, clientData ClientData, interp uintptr) { /* tclTest.c:1578:1: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var id int32 = (int32((clientData)))
	// var buffer [24]int8 at bp, 24

	(*(*func(*crt.TLS, uintptr, int64) int32)(unsafe.Pointer((tclIntStubsPtr + 208 /* &.tclFormatInt */))))(tls, bp /* &buffer */, int64(id))
	(*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 960 /* &.tcl_DStringAppendElement */))))(tls, uintptr(unsafe.Pointer(&delString)), bp /* &buffer */)
	if interp != delInterp {
		(*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 960 /* &.tcl_DStringAppendElement */))))(tls, uintptr(unsafe.Pointer(&delString)), ts+2341 /* "bogus interprete..." */)
	}
}

//----------------------------------------------------------------------
//
// TestdelCmd --
//
//	This procedure implements the "testdel" command.  It is used
//	to test calling of command deletion callbacks.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates a command.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestdelCmd(tls *crt.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1611:1: */
	var dPtr uintptr
	var slave uintptr

	if argc != 4 {
		(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, ts+1397 /* "wrong # args" */, (uintptr(0)))
		return 1
	}

	slave = (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1392 /* &.tcl_GetSlave */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	if slave == (uintptr(0)) {
		return 1
	}

	dPtr = ((*(*func(*crt.TLS, uint32) uintptr)(unsafe.Pointer((tclStubsPtr + 40 /* &.tcl_Alloc */))))(tls, (uint32(16))))
	(*DelCmd)(unsafe.Pointer(dPtr)).interp = interp
	(*DelCmd)(unsafe.Pointer(dPtr)).deleteCmd = ((*(*func(*crt.TLS, uint32) uintptr)(unsafe.Pointer((tclStubsPtr + 40 /* &.tcl_Alloc */))))(tls, (uint32(crt.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8))) + uint64(1)))))
	crt.Xstrcpy(tls, (*DelCmd)(unsafe.Pointer(dPtr)).deleteCmd, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)))

	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, slave, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{DelCmdProc})), dPtr,
		*(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, ClientData) }{DelDeleteProc})))
	return 0
}

func DelCmdProc(tls *crt.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1641:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var dPtr uintptr = clientData

	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, (*DelCmd)(unsafe.Pointer(dPtr)).deleteCmd, (uintptr(0))))
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, ((*DelCmd)(unsafe.Pointer(dPtr)).deleteCmd))
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, (dPtr))
	return 0
}

func DelDeleteProc(tls *crt.TLS, clientData ClientData) { /* tclTest.c:1656:1: */
	var dPtr uintptr = clientData

	(*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 1048 /* &.tcl_Eval */))))(tls, (*DelCmd)(unsafe.Pointer(dPtr)).interp, (*DelCmd)(unsafe.Pointer(dPtr)).deleteCmd)
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 1752 /* &.tcl_ResetResult */))))(tls, (*DelCmd)(unsafe.Pointer(dPtr)).interp)
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, ((*DelCmd)(unsafe.Pointer(dPtr)).deleteCmd))
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, (dPtr))
}

//----------------------------------------------------------------------
//
// TestdelassocdataCmd --
//
//	This procedure implements the "testdelassocdata" command. It is used
//	to test Tcl_DeleteAssocData.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Deletes an association between a key and associated data from an
//	interpreter.
//
//----------------------------------------------------------------------

func TestdelassocdataCmd(tls *crt.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1686:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	if argc != 2 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+2369 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+2400 /* " data_key\"" */, (uintptr(0))))
		return 1
	}
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 816 /* &.tcl_DeleteAssocData */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	return 0
}

//-----------------------------------------------------------------------------
//
// TestdoubledigitsCmd --
//
//	This procedure implements the 'testdoubledigits' command. It is
//	used to test the low-level floating-point formatting primitives
//	in Tcl.
//
// Usage:
//	testdoubledigits fpval ndigits type ?shorten"
//
// Parameters:
//	fpval - Floating-point value to format.
//	ndigits - Digit count to request from Tcl_DoubleDigits
//	type - One of 'shortest', 'Steele', 'e', 'f'
//	shorten - Indicates that the 'shorten' flag should be passed in.
//
//-----------------------------------------------------------------------------

func TestdoubledigitsObjCmd(tls *crt.TLS, unused ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:1723:1: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var doubleType uintptr
	// var d float64 at bp+8, 8

	var status int32
	// var ndigits int32 at bp+16, 4

	// var type1 int32 at bp+20, 4

	// var decpt int32 at bp+24, 4

	// var signum int32 at bp+28, 4

	var str uintptr
	// var endPtr uintptr at bp+32, 8

	// var strObj uintptr at bp+40, 8

	var retval uintptr

	if (objc < 4) || (objc > 5) {
		(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+2411 /* "fpval ndigits ty..." */)
		return 1
	}
	status = (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 296 /* &.tcl_GetDoubleFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+8 /* &d */)
	if status != 0 {
		doubleType = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 336 /* &.tcl_GetObjType */))))(tls, ts+2440 /* "double" */)
		if ((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))).typePtr == doubleType) ||
			(func() int32 {
				if 8 == 4 {
					return crt.X__isnanf(tls, float32(*(*float64)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)) + 32 /* &.internalRep */))))
				}
				return func() int32 {
					if 8 == 8 {
						return crt.X__isnan(tls, *(*float64)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)) + 32 /* &.internalRep */)))
					}
					return crt.X__isnanl(tls, *(*float64)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)) + 32 /* &.internalRep */)))
				}()
			}() != 0) {
			status = 0
			crt.Xmemcpy(tls, bp+8 /* &d */, (*(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)) + 32 /* &.internalRep */ /* &.doubleValue */), 8)
		}
	}
	if ((status != 0) ||
		((*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 320 /* &.tcl_GetIntFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+16 /* &ndigits */) != 0)) ||
		((*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 2448 /* &.tcl_GetIndexFromObjStruct */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), uintptr(unsafe.Pointer(&options)), int32(8), ts+2447 /* "conversion type" */, 1, bp+20 /* &type1 */) != 0) {
		crt.Xfprintf(tls, crt.Xstderr, ts+2463 /* "bad value? %g\n" */, crt.VaList(bp, *(*float64)(unsafe.Pointer(bp + 8 /* d */))))
		return 1
	}
	*(*int32)(unsafe.Pointer(bp + 20 /* type1 */)) = types[*(*int32)(unsafe.Pointer(bp + 20 /* type1 */))]
	if objc > 4 {
		if crt.Xstrcmp(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8))), ts+2478 /* "shorten" */) != 0 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, ts+2486 /* "bad flag" */, -1))
			return 1
		}
		*(*int32)(unsafe.Pointer(bp + 20 /* type1 */)) |= 0x4
	}
	str = (*(*func(*crt.TLS, float64, int32, int32, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer((tclIntStubsPtr + 2008 /* &.tclDoubleDigits */))))(tls, *(*float64)(unsafe.Pointer(bp + 8 /* d */)), *(*int32)(unsafe.Pointer(bp + 16 /* ndigits */)), *(*int32)(unsafe.Pointer(bp + 20 /* type1 */)), bp+24 /* &decpt */, bp+28 /* &signum */, bp+32 /* &endPtr */)
	*(*uintptr)(unsafe.Pointer(bp + 40 /* strObj */)) = (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, str, (int32((int64(*(*uintptr)(unsafe.Pointer(bp + 32 /* endPtr */))) - int64(str)) / 1)))
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, (str))
	retval = (*(*func(*crt.TLS, int32, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 440 /* &.tcl_NewListObj */))))(tls, 1, bp+40 /* &strObj */)
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 368 /* &.tcl_ListObjAppendElement */))))(tls, (uintptr(0)), retval, (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, *(*int32)(unsafe.Pointer(bp + 24 /* decpt */))))
	*(*uintptr)(unsafe.Pointer(bp + 40 /* strObj */)) = (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, func() uintptr {
		if *(*int32)(unsafe.Pointer(bp + 28 /* signum */)) != 0 {
			return ts + 2495 /* "-" */
		}
		return ts + 2497 /* "+" */
	}(), 1)
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 368 /* &.tcl_ListObjAppendElement */))))(tls, (uintptr(0)), retval, *(*uintptr)(unsafe.Pointer(bp + 40 /* strObj */)))
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, retval)
	return 0
}

var options = [5]uintptr{
	ts + 2499, /* "shortest" */
	ts + 2508, /* "Steele" */
	ts + 2515, /* "e" */
	ts + 2517, /* "f" */
	(uintptr(0)),
} /* tclTest.c:1732:22 */
var types = [4]int32{
	0x4,
	0x5,
	0x2,
	0x3,
} /* tclTest.c:1739:22 */

//----------------------------------------------------------------------
//
// TestdstringCmd --
//
//	This procedure implements the "testdstring" command.  It is used
//	to test the dynamic string facilities of Tcl.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates, deletes, and invokes handlers.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestdstringCmd(tls *crt.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:1816:1: */
	bp := tls.Alloc(68)
	defer tls.Free(68)

	// var count int32 at bp+64, 4

	var s uintptr
	var s1 uintptr

	if !(argc < 2) {
		goto __1
	}
wrongNumArgs:
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, ts+1397 /* "wrong # args" */, (uintptr(0)))
	return 1
__1:
	;
	if !(crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+2519 /* "append" */) == 0) {
		goto __2
	}
	if !(argc != 4) {
		goto __4
	}
	goto wrongNumArgs
__4:
	;
	if !((*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), bp+64 /* &count */) != 0) {
		goto __5
	}
	return 1
__5:
	;
	(*(*func(*crt.TLS, uintptr, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 952 /* &.tcl_DStringAppend */))))(tls, uintptr(unsafe.Pointer(&dstring)), *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), *(*int32)(unsafe.Pointer(bp + 64 /* count */)))
	goto __3
__2:
	if !(crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+2526 /* "element" */) == 0) {
		goto __6
	}
	if !(argc != 3) {
		goto __8
	}
	goto wrongNumArgs
__8:
	;
	(*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 960 /* &.tcl_DStringAppendElement */))))(tls, uintptr(unsafe.Pointer(&dstring)), *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)))
	goto __7
__6:
	if !(crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+2534 /* "end" */) == 0) {
		goto __9
	}
	if !(argc != 2) {
		goto __11
	}
	goto wrongNumArgs
__11:
	;
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 968 /* &.tcl_DStringEndSublist */))))(tls, uintptr(unsafe.Pointer(&dstring)))
	goto __10
__9:
	if !(crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+2538 /* "free" */) == 0) {
		goto __12
	}
	if !(argc != 2) {
		goto __14
	}
	goto wrongNumArgs
__14:
	;
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 976 /* &.tcl_DStringFree */))))(tls, uintptr(unsafe.Pointer(&dstring)))
	goto __13
__12:
	if !(crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+1535 /* "get" */) == 0) {
		goto __15
	}
	if !(argc != 2) {
		goto __17
	}
	goto wrongNumArgs
__17:
	;
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, ((*Tcl_DString)(unsafe.Pointer((uintptr(unsafe.Pointer(&dstring))))).string), (uintptr(1)))
	goto __16
__15:
	if !(crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+2543 /* "gresult" */) == 0) {
		goto __18
	}
	if !(argc != 3) {
		goto __20
	}
	goto wrongNumArgs
__20:
	;
	if !(crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), ts+2551 /* "staticsmall" */) == 0) {
		goto __21
	}
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, ts+2563 /* "short" */, (uintptr(0)))
	goto __22
__21:
	if !(crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), ts+2569 /* "staticlarge" */) == 0) {
		goto __23
	}
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, ts+2581 /* "first0 first1 fi..." */, (uintptr(0)))
	goto __24
__23:
	if !(crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), ts+2538 /* "free" */) == 0) {
		goto __25
	}
	s = ((*(*func(*crt.TLS, uint32) uintptr)(unsafe.Pointer((tclStubsPtr + 40 /* &.tcl_Alloc */))))(tls, (uint32(100))))
	crt.Xstrcpy(tls, s, ts+3112 /* "This is a malloc..." */)
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, s, (uintptr(3)))
	goto __26
__25:
	if !(crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), ts+3139 /* "special" */) == 0) {
		goto __27
	}
	s1 = (((*(*func(*crt.TLS, uint32) uintptr)(unsafe.Pointer((tclStubsPtr + 40 /* &.tcl_Alloc */))))(tls, (uint32(100)))) + uintptr(16))
	crt.Xstrcpy(tls, s1, ts+3147 /* "This is a specia..." */)
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, s1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{SpecialFree})))
	goto __28
__27:
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+3184 /* "bad gresult opti..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)),
		ts+3205, /* "\": must be stati..." */
		(uintptr(0))))
	return 1
__28:
	;
__26:
	;
__24:
	;
__22:
	;
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 984 /* &.tcl_DStringGetResult */))))(tls, interp, uintptr(unsafe.Pointer(&dstring)))
	goto __19
__18:
	if !(crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+3259 /* "length" */) == 0) {
		goto __29
	}

	if !(argc != 2) {
		goto __31
	}
	goto wrongNumArgs
__31:
	;
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, ((*Tcl_DString)(unsafe.Pointer((uintptr(unsafe.Pointer(&dstring))))).length)))
	goto __30
__29:
	if !(crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+3266 /* "result" */) == 0) {
		goto __32
	}
	if !(argc != 2) {
		goto __34
	}
	goto wrongNumArgs
__34:
	;
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1000 /* &.tcl_DStringResult */))))(tls, interp, uintptr(unsafe.Pointer(&dstring)))
	goto __33
__32:
	if !(crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+3273 /* "trunc" */) == 0) {
		goto __35
	}
	if !(argc != 3) {
		goto __37
	}
	goto wrongNumArgs
__37:
	;
	if !((*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), bp+64 /* &count */) != 0) {
		goto __38
	}
	return 1
__38:
	;
	(*(*func(*crt.TLS, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 1008 /* &.tcl_DStringSetLength */))))(tls, uintptr(unsafe.Pointer(&dstring)), *(*int32)(unsafe.Pointer(bp + 64 /* count */)))
	goto __36
__35:
	if !(crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+3279 /* "start" */) == 0) {
		goto __39
	}
	if !(argc != 2) {
		goto __41
	}
	goto wrongNumArgs
__41:
	;
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 1016 /* &.tcl_DStringStartSublist */))))(tls, uintptr(unsafe.Pointer(&dstring)))
	goto __40
__39:
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+32, ts+1429 /* "bad option \"" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)),

		ts+3285 /* "\": must be appen..." */, (uintptr(0))))
	return 1
__40:
	;
__36:
	;
__33:
	;
__30:
	;
__19:
	;
__16:
	;
__13:
	;
__10:
	;
__7:
	;
__3:
	;
	return 0
}

// The procedure below is used as a special freeProc to test how well
// Tcl_DStringGetResult handles freeProc's other than free.

func SpecialFree(tls *crt.TLS, blockPtr uintptr) { /* tclTest.c:1918:13: */
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, (blockPtr - uintptr(16)))
}

//----------------------------------------------------------------------
//
// TestencodingCmd --
//
//	This procedure implements the "testencoding" command.  It is used
//	to test the encoding package.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Load encodings.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestencodingObjCmd(tls *crt.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:1943:1: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var encoding Tcl_Encoding
	// var index int32 at bp, 4

	// var length int32 at bp+4, 4

	var string uintptr
	var encodingPtr uintptr
	const ( /* tclTest.c:1956:5: */
		ENC_CREATE = 0
		ENC_DELETE = 1
	)

	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 2448 /* &.tcl_GetIndexFromObjStruct */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), uintptr(unsafe.Pointer(&optionStrings)), int32(8), ts+3361 /* "option" */, 0, bp /* &index */) != 0 {
		return 1
	}

	switch uint32(*(*int32)(unsafe.Pointer(bp /* index */))) {
	case ENC_CREATE:
		{
			// var type1 Tcl_EncodingType at bp+8, 48

			if objc != 5 {
				return 1
			}
			encodingPtr = ((*(*func(*crt.TLS, uint32) uintptr)(unsafe.Pointer((tclStubsPtr + 40 /* &.tcl_Alloc */))))(tls, (uint32(24))))
			(*TclEncoding)(unsafe.Pointer(encodingPtr)).interp = interp

			string = (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 344 /* &.tcl_GetStringFromObj */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+4 /* &length */)
			(*TclEncoding)(unsafe.Pointer(encodingPtr)).toUtfCmd = ((*(*func(*crt.TLS, uint32) uintptr)(unsafe.Pointer((tclStubsPtr + 40 /* &.tcl_Alloc */))))(tls, (uint32(*(*int32)(unsafe.Pointer(bp + 4 /* length */)) + 1))))
			crt.Xmemcpy(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).toUtfCmd, string, (uint64(uint32(*(*int32)(unsafe.Pointer(bp + 4 /* length */))) + uint32(1))))

			string = (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 344 /* &.tcl_GetStringFromObj */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8)), bp+4 /* &length */)
			(*TclEncoding)(unsafe.Pointer(encodingPtr)).fromUtfCmd = ((*(*func(*crt.TLS, uint32) uintptr)(unsafe.Pointer((tclStubsPtr + 40 /* &.tcl_Alloc */))))(tls, (uint32(*(*int32)(unsafe.Pointer(bp + 4 /* length */)) + 1))))
			crt.Xmemcpy(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).fromUtfCmd, string, uint64((uint32(*(*int32)(unsafe.Pointer(bp + 4 /* length */)) + 1))))

			string = (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 344 /* &.tcl_GetStringFromObj */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+4 /* &length */)

			(*Tcl_EncodingType)(unsafe.Pointer(bp + 8 /* &type1 */)).encodingName = string
			(*Tcl_EncodingType)(unsafe.Pointer(bp + 8 /* &type1 */)).toUtfProc = *(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, ClientData, uintptr, int32, int32, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32
			}{EncodingToUtfProc}))
			(*Tcl_EncodingType)(unsafe.Pointer(bp + 8 /* &type1 */)).fromUtfProc = *(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, ClientData, uintptr, int32, int32, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32
			}{EncodingFromUtfProc}))
			(*Tcl_EncodingType)(unsafe.Pointer(bp + 8 /* &type1 */)).freeProc = *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, ClientData) }{EncodingFreeProc}))
			(*Tcl_EncodingType)(unsafe.Pointer(bp + 8 /* &type1 */)).clientData = encodingPtr
			(*Tcl_EncodingType)(unsafe.Pointer(bp + 8 /* &type1 */)).nullSize = 1

			(*(*func(*crt.TLS, uintptr) Tcl_Encoding)(unsafe.Pointer((tclStubsPtr + 2312 /* &.tcl_CreateEncoding */))))(tls, bp+8 /* &type1 */)
			break
		}
	case ENC_DELETE:
		if objc != 3 {
			return 1
		}
		encoding = (*(*func(*crt.TLS, uintptr, uintptr) Tcl_Encoding)(unsafe.Pointer((tclStubsPtr + 2424 /* &.tcl_GetEncoding */))))(tls, (uintptr(0)), (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))))
		(*(*func(*crt.TLS, Tcl_Encoding))(unsafe.Pointer((tclStubsPtr + 2408 /* &.tcl_FreeEncoding */))))(tls, encoding)
		(*(*func(*crt.TLS, Tcl_Encoding))(unsafe.Pointer((tclStubsPtr + 2408 /* &.tcl_FreeEncoding */))))(tls, encoding)
		break
	}
	return 0
}

var optionStrings = [3]uintptr{
	ts + 1410 /* "create" */, ts + 1417 /* "delete" */, (uintptr(0)),
} /* tclTest.c:1953:23 */

func EncodingToUtfProc(tls *crt.TLS, clientData ClientData, src uintptr, srcLen int32, flags int32, statePtr uintptr, dst uintptr, dstLen int32, srcReadPtr uintptr, dstWrotePtr uintptr, dstCharsPtr uintptr) int32 { /* tclTest.c:2008:1: */
	var len int32
	var encodingPtr uintptr

	encodingPtr = clientData
	(*(*func(*crt.TLS, uintptr, uintptr, int32, int32) int32)(unsafe.Pointer((tclStubsPtr + 2344 /* &.tcl_EvalEx */))))(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).interp, (*TclEncoding)(unsafe.Pointer(encodingPtr)).toUtfCmd, -1, 0x020000)

	len = int32(crt.Xstrlen(tls, ((*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1408 /* &.tcl_GetStringResult */))))(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).interp))))
	if len > dstLen {
		len = dstLen
	}
	crt.Xmemcpy(tls, dst, ((*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1408 /* &.tcl_GetStringResult */))))(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).interp)), uint64(uint32(len)))
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 1752 /* &.tcl_ResetResult */))))(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).interp)

	*(*int32)(unsafe.Pointer(srcReadPtr)) = srcLen
	*(*int32)(unsafe.Pointer(dstWrotePtr)) = len
	*(*int32)(unsafe.Pointer(dstCharsPtr)) = len
	return 0
}

func EncodingFromUtfProc(tls *crt.TLS, clientData ClientData, src uintptr, srcLen int32, flags int32, statePtr uintptr, dst uintptr, dstLen int32, srcReadPtr uintptr, dstWrotePtr uintptr, dstCharsPtr uintptr) int32 { /* tclTest.c:2040:1: */
	var len int32
	var encodingPtr uintptr

	encodingPtr = clientData
	(*(*func(*crt.TLS, uintptr, uintptr, int32, int32) int32)(unsafe.Pointer((tclStubsPtr + 2344 /* &.tcl_EvalEx */))))(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).interp, (*TclEncoding)(unsafe.Pointer(encodingPtr)).fromUtfCmd, -1, 0x020000)

	len = int32(crt.Xstrlen(tls, ((*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1408 /* &.tcl_GetStringResult */))))(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).interp))))
	if len > dstLen {
		len = dstLen
	}
	crt.Xmemcpy(tls, dst, ((*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1408 /* &.tcl_GetStringResult */))))(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).interp)), uint64(uint32(len)))
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 1752 /* &.tcl_ResetResult */))))(tls, (*TclEncoding)(unsafe.Pointer(encodingPtr)).interp)

	*(*int32)(unsafe.Pointer(srcReadPtr)) = srcLen
	*(*int32)(unsafe.Pointer(dstWrotePtr)) = len
	*(*int32)(unsafe.Pointer(dstCharsPtr)) = len
	return 0
}

func EncodingFreeProc(tls *crt.TLS, clientData ClientData) { /* tclTest.c:2072:1: */
	var encodingPtr uintptr = clientData

	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, ((*TclEncoding)(unsafe.Pointer(encodingPtr)).toUtfCmd))
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, ((*TclEncoding)(unsafe.Pointer(encodingPtr)).fromUtfCmd))
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, (encodingPtr))
}

//----------------------------------------------------------------------
//
// TestevalexObjCmd --
//
//	This procedure implements the "testevalex" command.  It is
//	used to test Tcl_EvalEx.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestevalexObjCmd(tls *crt.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:2100:1: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var length int32 at bp+32, 4

	var flags int32
	var script uintptr

	flags = 0
	if objc == 3 {
		var global uintptr = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
		if crt.Xstrcmp(tls, global, ts+3368 /* "global" */) != 0 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+3375 /* "bad value \"" */, global,
				ts+3387 /* "\": must be globa..." */, (uintptr(0))))
			return 1
		}
		flags = 0x020000
	} else if objc != 2 {
		(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+3405 /* "script ?global?" */)
		return 1
	}

	script = (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 344 /* &.tcl_GetStringFromObj */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+32 /* &length */)
	return (*(*func(*crt.TLS, uintptr, uintptr, int32, int32) int32)(unsafe.Pointer((tclStubsPtr + 2344 /* &.tcl_EvalEx */))))(tls, interp, script, *(*int32)(unsafe.Pointer(bp + 32 /* length */)), flags)
}

//----------------------------------------------------------------------
//
// TestevalobjvObjCmd --
//
//	This procedure implements the "testevalobjv" command.  It is
//	used to test Tcl_EvalObjv.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestevalobjvObjCmd(tls *crt.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:2145:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var evalGlobal int32 at bp, 4

	if objc < 3 {
		(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+3421 /* "global word ?wor..." */)
		return 1
	}
	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 320 /* &.tcl_GetIntFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &evalGlobal */) != 0 {
		return 1
	}
	return (*(*func(*crt.TLS, uintptr, int32, uintptr, int32) int32)(unsafe.Pointer((tclStubsPtr + 2352 /* &.tcl_EvalObjv */))))(tls, interp, (objc - 2), (objv + uintptr(2)*8),
		func() int32 {
			if *(*int32)(unsafe.Pointer(bp /* evalGlobal */)) != 0 {
				return 0x020000
			}
			return 0
		}())
}

//----------------------------------------------------------------------
//
// TesteventObjCmd --
//
//	This procedure implements a 'testevent' command.  The command
//	is used to test event queue management.
//
// The command takes two forms:
//	- testevent queue name position script
//		Queues an event at the given position in the queue, and
//		associates a given name with it (the same name may be
//		associated with multiple events). When the event comes
//		to the head of the queue, executes the given script at
//		global level in the current interp. The position may be
//		one of 'head', 'tail' or 'mark'.
//	- testevent delete name
//		Deletes any events associated with the given name from
//		the queue.
//
// Return value:
//	Returns a standard Tcl result.
//
// Side effects:
//	Manipulates the event queue as directed.
//
//----------------------------------------------------------------------

func TesteventObjCmd(tls *crt.TLS, unused ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:2194:1: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var subCmdIndex int32 at bp, 4

	// var posIndex int32 at bp+4, 4

	var ev uintptr // Event to be queued

	if objc < 2 {
		(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+3444 /* "subcommand ?arg ..." */)
		return 1
	}
	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 2448 /* &.tcl_GetIndexFromObjStruct */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), uintptr(unsafe.Pointer(&subcommands)), int32(8), ts+3465 /* "subcommand" */, 1, bp /* &subCmdIndex */) != 0 {
		return 1
	}
	switch *(*int32)(unsafe.Pointer(bp /* subCmdIndex */)) {
	case 0: // queue
		if objc != 5 {
			(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 2, objv, ts+3476 /* "name position sc..." */)
			return 1
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 2448 /* &.tcl_GetIndexFromObjStruct */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), uintptr(unsafe.Pointer(&positions)), int32(8), ts+3497 /* "position specifi..." */, 1, bp+4 /* &posIndex */) != 0 {
			return 1
		}
		ev = ((*(*func(*crt.TLS, uint32) uintptr)(unsafe.Pointer((tclStubsPtr + 40 /* &.tcl_Alloc */))))(tls, (uint32(40))))
		(*TestEvent)(unsafe.Pointer(ev)).header.proc = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, int32) int32
		}{TesteventProc}))
		(*TestEvent)(unsafe.Pointer(ev)).header.nextPtr = (uintptr(0))
		(*TestEvent)(unsafe.Pointer(ev)).interp = interp
		(*TestEvent)(unsafe.Pointer(ev)).command = *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8))
		(*Tcl_Obj)(unsafe.Pointer(((*TestEvent)(unsafe.Pointer(ev)).command))).refCount++
		(*TestEvent)(unsafe.Pointer(ev)).tag = *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))
		(*Tcl_Obj)(unsafe.Pointer(((*TestEvent)(unsafe.Pointer(ev)).tag))).refCount++
		(*(*func(*crt.TLS, uintptr, Tcl_QueuePosition))(unsafe.Pointer((tclStubsPtr + 1656 /* &.tcl_QueueEvent */))))(tls, ev, posNum[*(*int32)(unsafe.Pointer(bp + 4 /* posIndex */))])
		break

	case 1: // delete
		if objc != 3 {
			(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 2, objv, ts+1779 /* "name" */)
			return 1
		}
		(*(*func(*crt.TLS, uintptr, ClientData))(unsafe.Pointer((tclStubsPtr + 856 /* &.tcl_DeleteEvents */))))(tls, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, ClientData) int32
		}{TesteventDeleteProc})), *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
		break
	}

	return 0
}

var subcommands = [3]uintptr{ // Possible subcommands
	ts + 3516 /* "queue" */, ts + 1417 /* "delete" */, (uintptr(0)),
}                           /* tclTest.c:2200:23 */
var positions = [4]uintptr{ // Possible queue positions
	ts + 3522 /* "head" */, ts + 3527 /* "tail" */, ts + 1424 /* "mark" */, (uintptr(0)),
} /* tclTest.c:2204:23 */
var posNum = [3]Tcl_QueuePosition{
	// Interpretation of the chosen position
	Tcl_QueuePosition(1),
	Tcl_QueuePosition(0),
	Tcl_QueuePosition(2),
} /* tclTest.c:2208:36 */

//----------------------------------------------------------------------
//
// TesteventProc --
//
//	Delivers a test event to the Tcl interpreter as part of event
//	queue testing.
//
// Results:
//	Returns 1 if the event has been serviced, 0 otherwise.
//
// Side effects:
//	Evaluates the event's callback script, so has whatever side effects
//	the callback has.  The return value of the callback script becomes the
//	return value of this function.  If the callback script reports an
//	error, it is reported as a background error.
//
//----------------------------------------------------------------------

func TesteventProc(tls *crt.TLS, event uintptr, flags int32) int32 { /* tclTest.c:2278:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var ev uintptr = event
	var interp uintptr = (*TestEvent)(unsafe.Pointer(ev)).interp
	var command uintptr = (*TestEvent)(unsafe.Pointer(ev)).command
	var result int32 = (*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer((tclStubsPtr + 2360 /* &.tcl_EvalObjEx */))))(tls, interp, command,
		(0x020000 | 0x040000))
	// var retval int32 at bp, 4

	if result != 0 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 544 /* &.tcl_AddErrorInfo */))))(tls, interp,
			ts+3532 /* "    (command bou..." */)
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 624 /* &.tcl_BackgroundError */))))(tls, interp)
		return 1
	}
	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 272 /* &.tcl_GetBooleanFromObj */))))(tls, interp, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp),
		bp /* &retval */) != 0 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 544 /* &.tcl_AddErrorInfo */))))(tls, interp,
			ts+3576 /* "    (return valu..." */)
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 624 /* &.tcl_BackgroundError */))))(tls, interp)
		return 1
	}
	if *(*int32)(unsafe.Pointer(bp /* retval */)) != 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = ((*TestEvent)(unsafe.Pointer(ev)).tag)
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
			}
		}
		for ok1 := true; ok1; ok1 = 0 != 0 {
			var _objPtr uintptr = ((*TestEvent)(unsafe.Pointer(ev)).command)
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
			}
		}
	}

	return *(*int32)(unsafe.Pointer(bp /* retval */))
}

//----------------------------------------------------------------------
//
// TesteventDeleteProc --
//
//	Removes some set of events from the queue.
//
// This procedure is used as part of testing event queue management.
//
// Results:
//	Returns 1 if a given event should be deleted, 0 otherwise.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TesteventDeleteProc(tls *crt.TLS, event uintptr, clientData ClientData) int32 { /* tclTest.c:2329:1: */
	var ev uintptr // Event to examine
	var evNameStr uintptr
	var targetName uintptr // Name of the event(s) to delete
	var targetNameStr uintptr

	if (*Tcl_Event)(unsafe.Pointer(event)).proc != *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, int32) int32
	}{TesteventProc})) {
		return 0
	}
	targetName = clientData
	targetNameStr = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, targetName)
	ev = event
	evNameStr = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, (*TestEvent)(unsafe.Pointer(ev)).tag)
	if crt.Xstrcmp(tls, evNameStr, targetNameStr) == 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = ((*TestEvent)(unsafe.Pointer(ev)).tag)
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
			}
		}
		for ok1 := true; ok1; ok1 = 0 != 0 {
			var _objPtr uintptr = ((*TestEvent)(unsafe.Pointer(ev)).command)
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
			}
		}
		return 1
	} else {
		return 0
	}
	return int32(0)
}

//----------------------------------------------------------------------
//
// TestexithandlerCmd --
//
//	This procedure implements the "testexithandler" command. It is
//	used to test Tcl_CreateExitHandler and Tcl_DeleteExitHandler.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestexithandlerCmd(tls *crt.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:2373:1: */
	bp := tls.Alloc(68)
	defer tls.Free(68)

	// var value int32 at bp+64, 4

	if argc != 3 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+2369 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+3621 /* " create|delete v..." */, (uintptr(0))))
		return 1
	}
	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), bp+64 /* &value */) != 0 {
		return 1
	}
	if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+1410 /* "create" */) == 0 {
		(*(*func(*crt.TLS, uintptr, ClientData))(unsafe.Pointer((tclStubsPtr + 760 /* &.tcl_CreateExitHandler */))))(tls, func() uintptr {
			if (*(*int32)(unsafe.Pointer(bp + 64 /* value */)) & 1) != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, ClientData) }{ExitProcOdd}))
			}
			return *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, ClientData) }{ExitProcEven}))
		}(),
			(uintptr((intptr_t(*(*int32)(unsafe.Pointer(bp + 64 /* value */)))))))
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+1417 /* "delete" */) == 0 {
		(*(*func(*crt.TLS, uintptr, ClientData))(unsafe.Pointer((tclStubsPtr + 872 /* &.tcl_DeleteExitHandler */))))(tls, func() uintptr {
			if (*(*int32)(unsafe.Pointer(bp + 64 /* value */)) & 1) != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, ClientData) }{ExitProcOdd}))
			}
			return *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, ClientData) }{ExitProcEven}))
		}(),
			(uintptr((intptr_t(*(*int32)(unsafe.Pointer(bp + 64 /* value */)))))))
	} else {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+32, ts+1429 /* "bad option \"" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)),
			ts+3643 /* "\": must be creat..." */, (uintptr(0))))
		return 1
	}
	return 0
}

func ExitProcOdd(tls *crt.TLS, clientData ClientData) { /* tclTest.c:2404:1: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// var buf [40]int8 at bp+8, 40

	var len int32

	crt.Xsprintf(tls, bp+8 /* &buf */, ts+3671 /* "odd %d\n" */, crt.VaList(bp, (int32((clientData)))))
	len = int32(crt.Xstrlen(tls, bp+8 /* &buf */))
	if len != int32(crt.Xwrite(tls, 1, bp+8 /* &buf */, uint64(len))) {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 32 /* &.tcl_Panic */))))(tls, ts+3679 /* "ExitProcOdd: una..." */, 0)
	}
}

func ExitProcEven(tls *crt.TLS, clientData ClientData) { /* tclTest.c:2418:1: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// var buf [40]int8 at bp+8, 40

	var len int32

	crt.Xsprintf(tls, bp+8 /* &buf */, ts+3718 /* "even %d\n" */, crt.VaList(bp, (int32((clientData)))))
	len = int32(crt.Xstrlen(tls, bp+8 /* &buf */))
	if len != int32(crt.Xwrite(tls, 1, bp+8 /* &buf */, uint64(len))) {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 32 /* &.tcl_Panic */))))(tls, ts+3727 /* "ExitProcEven: un..." */, 0)
	}
}

//----------------------------------------------------------------------
//
// TestexprlongCmd --
//
//	This procedure verifies that Tcl_ExprLong does not modify the
//	interpreter result if there is no error.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestexprlongCmd(tls *crt.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:2449:1: */
	bp := tls.Alloc(92)
	defer tls.Free(92)

	// var exprResult int64 at bp+56, 8

	// var buf [28]int8 at bp+64, 28

	var result int32

	if argc != 2 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+2369 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+3767 /* " expression\"" */, (uintptr(0))))
		return 1
	}
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, ts+3780 /* "This is a result" */, (uintptr(0)))
	result = (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 1128 /* &.tcl_ExprLong */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+56 /* &exprResult */)
	if result != 0 {
		return result
	}
	crt.Xsprintf(tls, bp+64 /* &buf */, ts+3797 /* ": %ld" */, crt.VaList(bp+32, *(*int64)(unsafe.Pointer(bp + 56 /* exprResult */))))
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+40, bp+64 /* &buf */, (uintptr(0))))
	return 0
}

//----------------------------------------------------------------------
//
// TestexprlongobjCmd --
//
//	This procedure verifies that Tcl_ExprLongObj does not modify the
//	interpreter result if there is no error.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestexprlongobjCmd(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:2492:1: */
	bp := tls.Alloc(60)
	defer tls.Free(60)

	// var exprResult int64 at bp+24, 8

	// var buf [28]int8 at bp+32, 28

	var result int32

	if objc != 2 {
		(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+3803 /* "expression" */)
		return 1
	}
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, ts+3780 /* "This is a result" */, (uintptr(0)))
	result = (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 1136 /* &.tcl_ExprLongObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+24 /* &exprResult */)
	if result != 0 {
		return result
	}
	crt.Xsprintf(tls, bp+32 /* &buf */, ts+3797 /* ": %ld" */, crt.VaList(bp, *(*int64)(unsafe.Pointer(bp + 24 /* exprResult */))))
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+8, bp+32 /* &buf */, (uintptr(0))))
	return 0
}

//----------------------------------------------------------------------
//
// TestexprdoubleCmd --
//
//	This procedure verifies that Tcl_ExprDouble does not modify the
//	interpreter result if there is no error.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestexprdoubleCmd(tls *crt.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:2534:1: */
	bp := tls.Alloc(87)
	defer tls.Free(87)

	// var exprResult float64 at bp+48, 8

	// var buf [31]int8 at bp+56, 31

	var result int32

	if argc != 2 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+2369 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+3767 /* " expression\"" */, (uintptr(0))))
		return 1
	}
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, ts+3780 /* "This is a result" */, (uintptr(0)))
	result = (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 1112 /* &.tcl_ExprDouble */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+48 /* &exprResult */)
	if result != 0 {
		return result
	}
	crt.Xstrcpy(tls, bp+56 /* &buf */, ts+3814 /* ": " */)
	(*(*func(*crt.TLS, uintptr, float64, uintptr))(unsafe.Pointer((tclStubsPtr + 1632 /* &.tcl_PrintDouble */))))(tls, interp, *(*float64)(unsafe.Pointer(bp + 48 /* exprResult */)), (bp + 56 /* &buf */ + uintptr(2)))
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+32, bp+56 /* &buf */, (uintptr(0))))
	return 0
}

//----------------------------------------------------------------------
//
// TestexprdoubleobjCmd --
//
//	This procedure verifies that Tcl_ExprLongObj does not modify the
//	interpreter result if there is no error.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestexprdoubleobjCmd(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:2578:1: */
	bp := tls.Alloc(55)
	defer tls.Free(55)

	// var exprResult float64 at bp+16, 8

	// var buf [31]int8 at bp+24, 31

	var result int32

	if objc != 2 {
		(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+3803 /* "expression" */)
		return 1
	}
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, ts+3780 /* "This is a result" */, (uintptr(0)))
	result = (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 1120 /* &.tcl_ExprDoubleObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+16 /* &exprResult */)
	if result != 0 {
		return result
	}
	crt.Xstrcpy(tls, bp+24 /* &buf */, ts+3814 /* ": " */)
	(*(*func(*crt.TLS, uintptr, float64, uintptr))(unsafe.Pointer((tclStubsPtr + 1632 /* &.tcl_PrintDouble */))))(tls, interp, *(*float64)(unsafe.Pointer(bp + 16 /* exprResult */)), (bp + 24 /* &buf */ + uintptr(2)))
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, bp+24 /* &buf */, (uintptr(0))))
	return 0
}

//----------------------------------------------------------------------
//
// TestexprstringCmd --
//
//	This procedure tests the basic operation of Tcl_ExprString.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestexprstringCmd(tls *crt.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:2620:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	if argc != 2 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+2369 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+3767 /* " expression\"" */, (uintptr(0))))
		return 1
	}
	return (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 1152 /* &.tcl_ExprString */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
}

//----------------------------------------------------------------------
//
// TestfilelinkCmd --
//
//	This procedure implements the "testfilelink" command.  It is used to
//	test the effects of creating and manipulating filesystem links in Tcl.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	May create a link on disk.
//
//----------------------------------------------------------------------

func TestfilelinkCmd(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:2652:1: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	var contents uintptr

	if (objc < 2) || (objc > 3) {
		(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+3817 /* "source ?target?" */)
		return 1
	}

	if (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 3688 /* &.tcl_FSConvertToPathType */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))) != 0 {
		return 1
	}

	if objc == 3 {
		// Create link from source to target
		contents = (*(*func(*crt.TLS, uintptr, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 3584 /* &.tcl_FSLink */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)),
			(0x01 | 0x02))
		if contents == (uintptr(0)) {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+3833, /* "could not create..." */
				(*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), ts+3862, /* "\" to \"" */
				(*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))), ts+3869, /* "\": " */
				(*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1648 /* &.tcl_PosixError */))))(tls, interp), (uintptr(0))))
			return 1
		}
	} else {
		// Read link
		contents = (*(*func(*crt.TLS, uintptr, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 3584 /* &.tcl_FSLink */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), (uintptr(0)), 0)
		if contents == (uintptr(0)) {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+56, ts+3873, /* "could not read l..." */
				(*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), ts+3869, /* "\": " */
				(*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1648 /* &.tcl_PosixError */))))(tls, interp), (uintptr(0))))
			return 1
		}
	}
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, contents)
	if objc == 2 {
		// If we are creating a link, this will actually just
		// be objv[3], and we don't own it
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (contents)
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
			}
		}
	}
	return 0
}

//----------------------------------------------------------------------
//
// TestgetassocdataCmd --
//
//	This procedure implements the "testgetassocdata" command. It is
//	used to test Tcl_GetAssocData.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestgetassocdataCmd(tls *crt.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:2719:1: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var res uintptr

	if argc != 2 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+2369 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+2400 /* " data_key\"" */, (uintptr(0))))
		return 1
	}
	res = (*(*func(*crt.TLS, uintptr, uintptr, uintptr) ClientData)(unsafe.Pointer((tclStubsPtr + 1216 /* &.tcl_GetAssocData */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), (uintptr(0)))
	if res != (uintptr(0)) {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+32, res, (uintptr(0))))
	}
	return 0
}

//----------------------------------------------------------------------
//
// TestgetplatformCmd --
//
//	This procedure implements the "testgetplatform" command. It is
//	used to retrievel the value of the tclPlatform global variable.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestgetplatformCmd(tls *crt.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:2757:1: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var platform uintptr

	platform = (*(*func(*crt.TLS) uintptr)(unsafe.Pointer((tclIntStubsPtr + 1808 /* &.tclGetPlatform */))))(tls)

	if argc != 1 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+2369 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			(uintptr(0))))
		return 1
	}

	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+24, platformStrings[*(*TclPlatformType)(unsafe.Pointer(platform))], (uintptr(0))))
	return 0
}

var platformStrings = [3]uintptr{ts + 3895 /* "unix" */, ts + 3900 /* "mac" */, ts + 3904 /* "windows" */} /* tclTest.c:2763:23 */

//----------------------------------------------------------------------
//
// TestinterpdeleteCmd --
//
//	This procedure tests the code in tclInterp.c that deals with
//	interpreter deletion. It deletes a user-specified interpreter
//	from the hierarchy, and subsequent code checks integrity.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Deletes one or more interpreters.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestinterpdeleteCmd(tls *crt.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:2798:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var slaveToDelete uintptr

	if argc != 2 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+1483 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+3912 /* " path\"" */, (uintptr(0))))
		return 1
	}
	slaveToDelete = (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1392 /* &.tcl_GetSlave */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	if slaveToDelete == (uintptr(0)) {
		return 1
	}
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 896 /* &.tcl_DeleteInterp */))))(tls, slaveToDelete)
	return 0
}

//----------------------------------------------------------------------
//
// TestlinkCmd --
//
//	This procedure implements the "testlink" command.  It is used
//	to test Tcl_LinkVar and related library procedures.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates and deletes various variable links, plus returns
//	values of the linked variables.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestlinkCmd(tls *crt.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:2839:1: */
	bp := tls.Alloc(312)
	defer tls.Free(312)

	// var buffer [54]int8 at bp+212, 54

	// var writable int32 at bp+208, 4

	var flag int32
	var tmp uintptr

	if argc < 2 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+1483 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),

			ts+3919 /* " option ?arg arg..." */, (uintptr(0))))
		return 1
	}
	if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+1410 /* "create" */) == 0 {
		if argc != 16 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+32, ts+1483, /* "wrong # args: sh..." */
				*(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)), ts+1551 /* " " */, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)),

				ts+3986 /* " intRO realRO bo..." */, (uintptr(0))))
			return 1
		}
		if created != 0 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2024 /* &.tcl_UnlinkVar */))))(tls, interp, ts+4094 /* "int" */)
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2024 /* &.tcl_UnlinkVar */))))(tls, interp, ts+4098 /* "real" */)
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2024 /* &.tcl_UnlinkVar */))))(tls, interp, ts+4103 /* "bool" */)
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2024 /* &.tcl_UnlinkVar */))))(tls, interp, ts+4108 /* "string" */)
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2024 /* &.tcl_UnlinkVar */))))(tls, interp, ts+4115 /* "wide" */)
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2024 /* &.tcl_UnlinkVar */))))(tls, interp, ts+4120 /* "char" */)
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2024 /* &.tcl_UnlinkVar */))))(tls, interp, ts+4125 /* "uchar" */)
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2024 /* &.tcl_UnlinkVar */))))(tls, interp, ts+2563 /* "short" */)
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2024 /* &.tcl_UnlinkVar */))))(tls, interp, ts+4131 /* "ushort" */)
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2024 /* &.tcl_UnlinkVar */))))(tls, interp, ts+4138 /* "uint" */)
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2024 /* &.tcl_UnlinkVar */))))(tls, interp, ts+4143 /* "long" */)
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2024 /* &.tcl_UnlinkVar */))))(tls, interp, ts+4148 /* "ulong" */)
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2024 /* &.tcl_UnlinkVar */))))(tls, interp, ts+4154 /* "float" */)
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2024 /* &.tcl_UnlinkVar */))))(tls, interp, ts+4160 /* "uwide" */)
		}
		created = 1
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 264 /* &.tcl_GetBoolean */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), bp+208 /* &writable */) != 0 {
			return 1
		}
		if *(*int32)(unsafe.Pointer(bp + 208 /* writable */)) != 0 {
			flag = 0
		} else {
			flag = 0x80
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32) int32)(unsafe.Pointer((tclStubsPtr + 1512 /* &.tcl_LinkVar */))))(tls, interp, ts+4094 /* "int" */, uintptr(unsafe.Pointer(&intVar)),
			(1|flag)) != 0 {
			return 1
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 264 /* &.tcl_GetBoolean */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), bp+208 /* &writable */) != 0 {
			return 1
		}
		if *(*int32)(unsafe.Pointer(bp + 208 /* writable */)) != 0 {
			flag = 0
		} else {
			flag = 0x80
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32) int32)(unsafe.Pointer((tclStubsPtr + 1512 /* &.tcl_LinkVar */))))(tls, interp, ts+4098 /* "real" */, uintptr(unsafe.Pointer(&realVar)),
			(2|flag)) != 0 {
			return 1
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 264 /* &.tcl_GetBoolean */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)), bp+208 /* &writable */) != 0 {
			return 1
		}
		if *(*int32)(unsafe.Pointer(bp + 208 /* writable */)) != 0 {
			flag = 0
		} else {
			flag = 0x80
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32) int32)(unsafe.Pointer((tclStubsPtr + 1512 /* &.tcl_LinkVar */))))(tls, interp, ts+4103 /* "bool" */, uintptr(unsafe.Pointer(&boolVar)),
			(3|flag)) != 0 {
			return 1
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 264 /* &.tcl_GetBoolean */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(5)*8)), bp+208 /* &writable */) != 0 {
			return 1
		}
		if *(*int32)(unsafe.Pointer(bp + 208 /* writable */)) != 0 {
			flag = 0
		} else {
			flag = 0x80
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32) int32)(unsafe.Pointer((tclStubsPtr + 1512 /* &.tcl_LinkVar */))))(tls, interp, ts+4108 /* "string" */, uintptr(unsafe.Pointer(&stringVar)),
			(4|flag)) != 0 {
			return 1
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 264 /* &.tcl_GetBoolean */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(6)*8)), bp+208 /* &writable */) != 0 {
			return 1
		}
		if *(*int32)(unsafe.Pointer(bp + 208 /* writable */)) != 0 {
			flag = 0
		} else {
			flag = 0x80
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32) int32)(unsafe.Pointer((tclStubsPtr + 1512 /* &.tcl_LinkVar */))))(tls, interp, ts+4115 /* "wide" */, uintptr(unsafe.Pointer(&wideVar)),
			(5|flag)) != 0 {
			return 1
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 264 /* &.tcl_GetBoolean */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(7)*8)), bp+208 /* &writable */) != 0 {
			return 1
		}
		if *(*int32)(unsafe.Pointer(bp + 208 /* writable */)) != 0 {
			flag = 0
		} else {
			flag = 0x80
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32) int32)(unsafe.Pointer((tclStubsPtr + 1512 /* &.tcl_LinkVar */))))(tls, interp, ts+4120 /* "char" */, uintptr(unsafe.Pointer(&charVar)),
			(6|flag)) != 0 {
			return 1
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 264 /* &.tcl_GetBoolean */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(8)*8)), bp+208 /* &writable */) != 0 {
			return 1
		}
		if *(*int32)(unsafe.Pointer(bp + 208 /* writable */)) != 0 {
			flag = 0
		} else {
			flag = 0x80
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32) int32)(unsafe.Pointer((tclStubsPtr + 1512 /* &.tcl_LinkVar */))))(tls, interp, ts+4125 /* "uchar" */, uintptr(unsafe.Pointer(&ucharVar)),
			(7|flag)) != 0 {
			return 1
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 264 /* &.tcl_GetBoolean */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(9)*8)), bp+208 /* &writable */) != 0 {
			return 1
		}
		if *(*int32)(unsafe.Pointer(bp + 208 /* writable */)) != 0 {
			flag = 0
		} else {
			flag = 0x80
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32) int32)(unsafe.Pointer((tclStubsPtr + 1512 /* &.tcl_LinkVar */))))(tls, interp, ts+2563 /* "short" */, uintptr(unsafe.Pointer(&shortVar)),
			(8|flag)) != 0 {
			return 1
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 264 /* &.tcl_GetBoolean */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(10)*8)), bp+208 /* &writable */) != 0 {
			return 1
		}
		if *(*int32)(unsafe.Pointer(bp + 208 /* writable */)) != 0 {
			flag = 0
		} else {
			flag = 0x80
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32) int32)(unsafe.Pointer((tclStubsPtr + 1512 /* &.tcl_LinkVar */))))(tls, interp, ts+4131 /* "ushort" */, uintptr(unsafe.Pointer(&ushortVar)),
			(9|flag)) != 0 {
			return 1
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 264 /* &.tcl_GetBoolean */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(11)*8)), bp+208 /* &writable */) != 0 {
			return 1
		}
		if *(*int32)(unsafe.Pointer(bp + 208 /* writable */)) != 0 {
			flag = 0
		} else {
			flag = 0x80
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32) int32)(unsafe.Pointer((tclStubsPtr + 1512 /* &.tcl_LinkVar */))))(tls, interp, ts+4138 /* "uint" */, uintptr(unsafe.Pointer(&uintVar)),
			(10|flag)) != 0 {
			return 1
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 264 /* &.tcl_GetBoolean */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(12)*8)), bp+208 /* &writable */) != 0 {
			return 1
		}
		if *(*int32)(unsafe.Pointer(bp + 208 /* writable */)) != 0 {
			flag = 0
		} else {
			flag = 0x80
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32) int32)(unsafe.Pointer((tclStubsPtr + 1512 /* &.tcl_LinkVar */))))(tls, interp, ts+4143 /* "long" */, uintptr(unsafe.Pointer(&longVar)),
			(11|flag)) != 0 {
			return 1
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 264 /* &.tcl_GetBoolean */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(13)*8)), bp+208 /* &writable */) != 0 {
			return 1
		}
		if *(*int32)(unsafe.Pointer(bp + 208 /* writable */)) != 0 {
			flag = 0
		} else {
			flag = 0x80
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32) int32)(unsafe.Pointer((tclStubsPtr + 1512 /* &.tcl_LinkVar */))))(tls, interp, ts+4148 /* "ulong" */, uintptr(unsafe.Pointer(&ulongVar)),
			(12|flag)) != 0 {
			return 1
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 264 /* &.tcl_GetBoolean */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(14)*8)), bp+208 /* &writable */) != 0 {
			return 1
		}
		if *(*int32)(unsafe.Pointer(bp + 208 /* writable */)) != 0 {
			flag = 0
		} else {
			flag = 0x80
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32) int32)(unsafe.Pointer((tclStubsPtr + 1512 /* &.tcl_LinkVar */))))(tls, interp, ts+4154 /* "float" */, uintptr(unsafe.Pointer(&floatVar)),
			(13|flag)) != 0 {
			return 1
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 264 /* &.tcl_GetBoolean */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(15)*8)), bp+208 /* &writable */) != 0 {
			return 1
		}
		if *(*int32)(unsafe.Pointer(bp + 208 /* writable */)) != 0 {
			flag = 0
		} else {
			flag = 0x80
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32) int32)(unsafe.Pointer((tclStubsPtr + 1512 /* &.tcl_LinkVar */))))(tls, interp, ts+4160 /* "uwide" */, uintptr(unsafe.Pointer(&uwideVar)),
			(14|flag)) != 0 {
			return 1
		}
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+1417 /* "delete" */) == 0 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2024 /* &.tcl_UnlinkVar */))))(tls, interp, ts+4094 /* "int" */)
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2024 /* &.tcl_UnlinkVar */))))(tls, interp, ts+4098 /* "real" */)
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2024 /* &.tcl_UnlinkVar */))))(tls, interp, ts+4103 /* "bool" */)
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2024 /* &.tcl_UnlinkVar */))))(tls, interp, ts+4108 /* "string" */)
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2024 /* &.tcl_UnlinkVar */))))(tls, interp, ts+4115 /* "wide" */)
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2024 /* &.tcl_UnlinkVar */))))(tls, interp, ts+4120 /* "char" */)
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2024 /* &.tcl_UnlinkVar */))))(tls, interp, ts+4125 /* "uchar" */)
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2024 /* &.tcl_UnlinkVar */))))(tls, interp, ts+2563 /* "short" */)
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2024 /* &.tcl_UnlinkVar */))))(tls, interp, ts+4131 /* "ushort" */)
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2024 /* &.tcl_UnlinkVar */))))(tls, interp, ts+4138 /* "uint" */)
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2024 /* &.tcl_UnlinkVar */))))(tls, interp, ts+4143 /* "long" */)
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2024 /* &.tcl_UnlinkVar */))))(tls, interp, ts+4148 /* "ulong" */)
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2024 /* &.tcl_UnlinkVar */))))(tls, interp, ts+4154 /* "float" */)
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2024 /* &.tcl_UnlinkVar */))))(tls, interp, ts+4160 /* "uwide" */)
		created = 0
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+1535 /* "get" */) == 0 {
		(*(*func(*crt.TLS, uintptr, int64) int32)(unsafe.Pointer((tclIntStubsPtr + 208 /* &.tclFormatInt */))))(tls, bp+212 /* &buffer */, int64(intVar))
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, bp+212 /* &buffer */)
		(*(*func(*crt.TLS, uintptr, float64, uintptr))(unsafe.Pointer((tclStubsPtr + 1632 /* &.tcl_PrintDouble */))))(tls, (uintptr(0)), realVar, bp+212 /* &buffer */)
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, bp+212 /* &buffer */)
		(*(*func(*crt.TLS, uintptr, int64) int32)(unsafe.Pointer((tclIntStubsPtr + 208 /* &.tclFormatInt */))))(tls, bp+212 /* &buffer */, int64(boolVar))
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, bp+212 /* &buffer */)
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, func() uintptr {
			if stringVar == (uintptr(0)) {
				return ts + 2495 /* "-" */
			}
			return stringVar
		}())
		// Wide ints only have an object-based interface.
		tmp = (*(*func(*crt.TLS, Tcl_WideInt) uintptr)(unsafe.Pointer((tclStubsPtr + 3920 /* &.tcl_NewWideIntObj */))))(tls, wideVar)
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, tmp))
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (tmp)
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
			}
		}
		(*(*func(*crt.TLS, uintptr, int64) int32)(unsafe.Pointer((tclIntStubsPtr + 208 /* &.tclFormatInt */))))(tls, bp+212 /* &buffer */, int64(int32(charVar)))
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, bp+212 /* &buffer */)
		(*(*func(*crt.TLS, uintptr, int64) int32)(unsafe.Pointer((tclIntStubsPtr + 208 /* &.tclFormatInt */))))(tls, bp+212 /* &buffer */, int64(int32(ucharVar)))
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, bp+212 /* &buffer */)
		(*(*func(*crt.TLS, uintptr, int64) int32)(unsafe.Pointer((tclIntStubsPtr + 208 /* &.tclFormatInt */))))(tls, bp+212 /* &buffer */, int64(int32(shortVar)))
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, bp+212 /* &buffer */)
		(*(*func(*crt.TLS, uintptr, int64) int32)(unsafe.Pointer((tclIntStubsPtr + 208 /* &.tclFormatInt */))))(tls, bp+212 /* &buffer */, int64(int32(ushortVar)))
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, bp+212 /* &buffer */)
		(*(*func(*crt.TLS, uintptr, int64) int32)(unsafe.Pointer((tclIntStubsPtr + 208 /* &.tclFormatInt */))))(tls, bp+212 /* &buffer */, int64(int32(uintVar)))
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, bp+212 /* &buffer */)
		tmp = (*(*func(*crt.TLS, int64) uintptr)(unsafe.Pointer((tclStubsPtr + 448 /* &.tcl_NewLongObj */))))(tls, longVar)
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, tmp))
		for ok1 := true; ok1; ok1 = 0 != 0 {
			var _objPtr uintptr = (tmp)
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
			}
		}
		tmp = (*(*func(*crt.TLS, int64) uintptr)(unsafe.Pointer((tclStubsPtr + 448 /* &.tcl_NewLongObj */))))(tls, int64(ulongVar))
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, tmp))
		for ok2 := true; ok2; ok2 = 0 != 0 {
			var _objPtr uintptr = (tmp)
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
			}
		}
		(*(*func(*crt.TLS, uintptr, float64, uintptr))(unsafe.Pointer((tclStubsPtr + 1632 /* &.tcl_PrintDouble */))))(tls, (uintptr(0)), float64(floatVar), bp+212 /* &buffer */)
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, bp+212 /* &buffer */)
		tmp = (*(*func(*crt.TLS, Tcl_WideInt) uintptr)(unsafe.Pointer((tclStubsPtr + 3920 /* &.tcl_NewWideIntObj */))))(tls, Tcl_WideInt(uwideVar))
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, tmp))
		for ok3 := true; ok3; ok3 = 0 != 0 {
			var _objPtr uintptr = (tmp)
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
			}
		}
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+4166 /* "set" */) == 0 {
		// var v int32 at bp+268, 4

		if argc != 16 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+80, ts+1483, /* "wrong # args: sh..." */
				*(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)), ts+1551 /* " " */, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)),

				ts+4170 /* " intValue realVa..." */, (uintptr(0))))
			return 1
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)) + uintptr(0)))) != 0 {
			if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), uintptr(unsafe.Pointer(&intVar))) != 0 {
				return 1
			}
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)) + uintptr(0)))) != 0 {
			if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 288 /* &.tcl_GetDouble */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), uintptr(unsafe.Pointer(&realVar))) != 0 {
				return 1
			}
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)) + uintptr(0)))) != 0 {
			if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)), uintptr(unsafe.Pointer(&boolVar))) != 0 {
				return 1
			}
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(5)*8)) + uintptr(0)))) != 0 {
			if stringVar != (uintptr(0)) {
				(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, (stringVar))
			}
			if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(5)*8)), ts+2495 /* "-" */) == 0 {
				stringVar = (uintptr(0))
			} else {
				stringVar = ((*(*func(*crt.TLS, uint32) uintptr)(unsafe.Pointer((tclStubsPtr + 40 /* &.tcl_Alloc */))))(tls, (uint32(crt.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(5)*8))) + uint64(1)))))
				crt.Xstrcpy(tls, stringVar, *(*uintptr)(unsafe.Pointer(argv + uintptr(5)*8)))
			}
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(6)*8)) + uintptr(0)))) != 0 {
			tmp = (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(6)*8)), -1)
			if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 3912 /* &.tcl_GetWideIntFromObj */))))(tls, interp, tmp, uintptr(unsafe.Pointer(&wideVar))) != 0 {
				for ok4 := true; ok4; ok4 = 0 != 0 {
					var _objPtr uintptr = (tmp)
					if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
						(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
					}
				}
				return 1
			}
			for ok5 := true; ok5; ok5 = 0 != 0 {
				var _objPtr uintptr = (tmp)
				if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
					(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
				}
			}
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(7)*8)) + uintptr(0))) != 0 {
			if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(7)*8)), bp+268 /* &v */) != 0 {
				return 1
			}
			charVar = int8(*(*int32)(unsafe.Pointer(bp + 268 /* v */)))
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(8)*8)) + uintptr(0))) != 0 {
			if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(8)*8)), bp+268 /* &v */) != 0 {
				return 1
			}
			ucharVar = uint8(*(*int32)(unsafe.Pointer(bp + 268 /* v */)))
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(9)*8)) + uintptr(0))) != 0 {
			if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(9)*8)), bp+268 /* &v */) != 0 {
				return 1
			}
			shortVar = int16(*(*int32)(unsafe.Pointer(bp + 268 /* v */)))
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(10)*8)) + uintptr(0))) != 0 {
			if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(10)*8)), bp+268 /* &v */) != 0 {
				return 1
			}
			ushortVar = uint16(*(*int32)(unsafe.Pointer(bp + 268 /* v */)))
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(11)*8)) + uintptr(0))) != 0 {
			if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(11)*8)), bp+268 /* &v */) != 0 {
				return 1
			}
			uintVar = uint32(*(*int32)(unsafe.Pointer(bp + 268 /* v */)))
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(12)*8)) + uintptr(0))) != 0 {
			if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(12)*8)), bp+268 /* &v */) != 0 {
				return 1
			}
			longVar = int64(*(*int32)(unsafe.Pointer(bp + 268 /* v */)))
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(13)*8)) + uintptr(0))) != 0 {
			if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(13)*8)), bp+268 /* &v */) != 0 {
				return 1
			}
			ulongVar = uint64(*(*int32)(unsafe.Pointer(bp + 268 /* v */)))
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(14)*8)) + uintptr(0))) != 0 {
			// var d float64 at bp+272, 8

			if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 288 /* &.tcl_GetDouble */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(14)*8)), bp+272 /* &d */) != 0 {
				return 1
			}
			floatVar = float32(*(*float64)(unsafe.Pointer(bp + 272 /* d */)))
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(15)*8)) + uintptr(0))) != 0 {
			// var w Tcl_WideInt at bp+280, 8

			tmp = (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(15)*8)), -1)
			if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 3912 /* &.tcl_GetWideIntFromObj */))))(tls, interp, tmp, bp+280 /* &w */) != 0 {
				for ok6 := true; ok6; ok6 = 0 != 0 {
					var _objPtr uintptr = (tmp)
					if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
						(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
					}
				}
				return 1
			}
			for ok7 := true; ok7; ok7 = 0 != 0 {
				var _objPtr uintptr = (tmp)
				if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
					(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
				}
			}
			uwideVar = Tcl_WideUInt(*(*Tcl_WideInt)(unsafe.Pointer(bp + 280 /* w */)))
		}
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+4320 /* "update" */) == 0 {
		// var v int32 at bp+288, 4

		if argc != 16 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+128, ts+1483, /* "wrong # args: sh..." */
				*(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)), ts+1551 /* " " */, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)),

				ts+4170 /* " intValue realVa..." */, (uintptr(0))))
			return 1
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)) + uintptr(0)))) != 0 {
			if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), uintptr(unsafe.Pointer(&intVar))) != 0 {
				return 1
			}
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2072 /* &.tcl_UpdateLinkedVar */))))(tls, interp, ts+4094 /* "int" */)
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)) + uintptr(0)))) != 0 {
			if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 288 /* &.tcl_GetDouble */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), uintptr(unsafe.Pointer(&realVar))) != 0 {
				return 1
			}
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2072 /* &.tcl_UpdateLinkedVar */))))(tls, interp, ts+4098 /* "real" */)
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)) + uintptr(0)))) != 0 {
			if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)), uintptr(unsafe.Pointer(&boolVar))) != 0 {
				return 1
			}
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2072 /* &.tcl_UpdateLinkedVar */))))(tls, interp, ts+4103 /* "bool" */)
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(5)*8)) + uintptr(0)))) != 0 {
			if stringVar != (uintptr(0)) {
				(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, (stringVar))
			}
			if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(5)*8)), ts+2495 /* "-" */) == 0 {
				stringVar = (uintptr(0))
			} else {
				stringVar = ((*(*func(*crt.TLS, uint32) uintptr)(unsafe.Pointer((tclStubsPtr + 40 /* &.tcl_Alloc */))))(tls, (uint32(crt.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(5)*8))) + uint64(1)))))
				crt.Xstrcpy(tls, stringVar, *(*uintptr)(unsafe.Pointer(argv + uintptr(5)*8)))
			}
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2072 /* &.tcl_UpdateLinkedVar */))))(tls, interp, ts+4108 /* "string" */)
		}
		if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(6)*8)) + uintptr(0)))) != 0 {
			tmp = (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(6)*8)), -1)
			if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 3912 /* &.tcl_GetWideIntFromObj */))))(tls, interp, tmp, uintptr(unsafe.Pointer(&wideVar))) != 0 {
				for ok8 := true; ok8; ok8 = 0 != 0 {
					var _objPtr uintptr = (tmp)
					if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
						(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
					}
				}
				return 1
			}
			for ok9 := true; ok9; ok9 = 0 != 0 {
				var _objPtr uintptr = (tmp)
				if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
					(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
				}
			}
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2072 /* &.tcl_UpdateLinkedVar */))))(tls, interp, ts+4115 /* "wide" */)
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(7)*8)) + uintptr(0))) != 0 {
			if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(7)*8)), bp+288 /* &v */) != 0 {
				return 1
			}
			charVar = int8(*(*int32)(unsafe.Pointer(bp + 288 /* v */)))
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2072 /* &.tcl_UpdateLinkedVar */))))(tls, interp, ts+4120 /* "char" */)
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(8)*8)) + uintptr(0))) != 0 {
			if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(8)*8)), bp+288 /* &v */) != 0 {
				return 1
			}
			ucharVar = uint8(*(*int32)(unsafe.Pointer(bp + 288 /* v */)))
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2072 /* &.tcl_UpdateLinkedVar */))))(tls, interp, ts+4125 /* "uchar" */)
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(9)*8)) + uintptr(0))) != 0 {
			if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(9)*8)), bp+288 /* &v */) != 0 {
				return 1
			}
			shortVar = int16(*(*int32)(unsafe.Pointer(bp + 288 /* v */)))
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2072 /* &.tcl_UpdateLinkedVar */))))(tls, interp, ts+2563 /* "short" */)
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(10)*8)) + uintptr(0))) != 0 {
			if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(10)*8)), bp+288 /* &v */) != 0 {
				return 1
			}
			ushortVar = uint16(*(*int32)(unsafe.Pointer(bp + 288 /* v */)))
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2072 /* &.tcl_UpdateLinkedVar */))))(tls, interp, ts+4131 /* "ushort" */)
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(11)*8)) + uintptr(0))) != 0 {
			if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(11)*8)), bp+288 /* &v */) != 0 {
				return 1
			}
			uintVar = uint32(*(*int32)(unsafe.Pointer(bp + 288 /* v */)))
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2072 /* &.tcl_UpdateLinkedVar */))))(tls, interp, ts+4138 /* "uint" */)
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(12)*8)) + uintptr(0))) != 0 {
			if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(12)*8)), bp+288 /* &v */) != 0 {
				return 1
			}
			longVar = int64(*(*int32)(unsafe.Pointer(bp + 288 /* v */)))
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2072 /* &.tcl_UpdateLinkedVar */))))(tls, interp, ts+4143 /* "long" */)
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(13)*8)) + uintptr(0))) != 0 {
			if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(13)*8)), bp+288 /* &v */) != 0 {
				return 1
			}
			ulongVar = uint64(*(*int32)(unsafe.Pointer(bp + 288 /* v */)))
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2072 /* &.tcl_UpdateLinkedVar */))))(tls, interp, ts+4148 /* "ulong" */)
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(14)*8)) + uintptr(0))) != 0 {
			// var d float64 at bp+296, 8

			if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 288 /* &.tcl_GetDouble */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(14)*8)), bp+296 /* &d */) != 0 {
				return 1
			}
			floatVar = float32(*(*float64)(unsafe.Pointer(bp + 296 /* d */)))
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2072 /* &.tcl_UpdateLinkedVar */))))(tls, interp, ts+4154 /* "float" */)
		}
		if *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(15)*8)) + uintptr(0))) != 0 {
			// var w Tcl_WideInt at bp+304, 8

			tmp = (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(15)*8)), -1)
			if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 3912 /* &.tcl_GetWideIntFromObj */))))(tls, interp, tmp, bp+304 /* &w */) != 0 {
				for ok10 := true; ok10; ok10 = 0 != 0 {
					var _objPtr uintptr = (tmp)
					if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
						(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
					}
				}
				return 1
			}
			for ok11 := true; ok11; ok11 = 0 != 0 {
				var _objPtr uintptr = (tmp)
				if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
					(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
				}
			}
			uwideVar = Tcl_WideUInt(*(*Tcl_WideInt)(unsafe.Pointer(bp + 304 /* w */)))
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2072 /* &.tcl_UpdateLinkedVar */))))(tls, interp, ts+4160 /* "uwide" */)
		}
	} else {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+176, ts+1429 /* "bad option \"" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)),
			ts+4327 /* "\": should be cre..." */, (uintptr(0))))
		return 1
	}
	return 0
}

var intVar int32 = 43                                    /* tclTest.c:2845:16 */
var boolVar int32 = 4                                    /* tclTest.c:2846:16 */
var realVar float64 = 1.23                               /* tclTest.c:2847:19 */
var wideVar Tcl_WideInt = (int64(79))                    /* tclTest.c:2848:24 */
var stringVar uintptr = (uintptr(0))                     /* tclTest.c:2849:17 */
var charVar int8 = int8('@')                             /* tclTest.c:2850:17 */
var ucharVar uint8 = uint8(130)                          /* tclTest.c:2851:26 */
var shortVar int16 = int16(3000)                         /* tclTest.c:2852:18 */
var ushortVar uint16 = uint16(60000)                     /* tclTest.c:2853:27 */
var uintVar uint32 = 0xbeeffeed                          /* tclTest.c:2854:25 */
var longVar int64 = 123456789                            /* tclTest.c:2855:17 */
var ulongVar uint64 = 3456789012                         /* tclTest.c:2856:26 */
var floatVar float32 = 4.5                               /* tclTest.c:2857:18 */
var uwideVar Tcl_WideUInt = (Tcl_WideUInt((int64(123)))) /* tclTest.c:2858:25 */
var created int32 = 0                                    /* tclTest.c:2859:16 */

//----------------------------------------------------------------------
//
// TestlocaleCmd --
//
//	This procedure implements the "testlocale" command.  It is used
//	to test the effects of setting different locales in Tcl.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Modifies the current C locale.
//
//----------------------------------------------------------------------

func TestlocaleCmd(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:3307:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var index int32 at bp, 4

	var locale uintptr

	// LC_CTYPE, etc. correspond to the indices for the strings.

	if (objc < 2) || (objc > 3) {
		(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+4376 /* "category ?locale..." */)
		return 1
	}

	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 2448 /* &.tcl_GetIndexFromObjStruct */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), uintptr(unsafe.Pointer(&optionStrings1)), int32(8), ts+3361 /* "option" */, 0, bp /* &index */) != 0 {
		return 1
	}

	if objc == 3 {
		locale = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	} else {
		locale = (uintptr(0))
	}
	locale = crt.Xsetlocale(tls, lcTypes[*(*int32)(unsafe.Pointer(bp /* index */))], locale)
	if locale != 0 {
		(*(*func(*crt.TLS, uintptr, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 536 /* &.tcl_SetStringObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp), locale, -1)
	}
	return 0
}

var optionStrings1 = [7]uintptr{
	ts + 4394 /* "ctype" */, ts + 4400 /* "numeric" */, ts + 4408 /* "time" */, ts + 4413 /* "collate" */, ts + 4421, /* "monetary" */
	ts + 4430 /* "all" */, (uintptr(0)),
} /* tclTest.c:3316:23 */
var lcTypes = [6]int32{
	0, 1, 2, 3, 4,
	6,
} /* tclTest.c:3320:22 */

//----------------------------------------------------------------------
//
// TestMathFunc --
//
//	This is a user-defined math procedure to test out math procedures
//	with no arguments.
//
// Results:
//	A normal Tcl completion code.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestMathFunc(tls *crt.TLS, clientData ClientData, interp uintptr, args uintptr, resultPtr uintptr) int32 { /* tclTest.c:3370:1: */
	(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = Tcl_ValueType(0)
	(*Tcl_Value)(unsafe.Pointer(resultPtr)).intValue = (int64(int32((clientData))))
	return 0
}

//----------------------------------------------------------------------
//
// TestMathFunc2 --
//
//	This is a user-defined math procedure to test out math procedures
//	that do have arguments, in this case 2.
//
// Results:
//	A normal Tcl completion code.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestMathFunc2(tls *crt.TLS, clientData ClientData, interp uintptr, args uintptr, resultPtr uintptr) int32 { /* tclTest.c:3400:1: */
	var result int32 = 0

	// Return the maximum of the two arguments with the correct type.

	if (*Tcl_Value)(unsafe.Pointer(args+uintptr(0)*32)).__type == Tcl_ValueType(0) {
		var i0 int32 = int32((*Tcl_Value)(unsafe.Pointer(args + uintptr(0)*32)).intValue)

		if (*Tcl_Value)(unsafe.Pointer(args+uintptr(1)*32)).__type == Tcl_ValueType(0) {
			var i1 int32 = int32((*Tcl_Value)(unsafe.Pointer(args + uintptr(1)*32)).intValue)

			(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = Tcl_ValueType(0)
			(*Tcl_Value)(unsafe.Pointer(resultPtr)).intValue = (func() int64 {
				if i0 > i1 {
					return int64(i0)
				}
				return int64(i1)
			}())
		} else if (*Tcl_Value)(unsafe.Pointer(args+uintptr(1)*32)).__type == Tcl_ValueType(1) {
			var d0 float64 = float64(i0)
			var d1 float64 = (*Tcl_Value)(unsafe.Pointer(args + uintptr(1)*32)).doubleValue

			(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = Tcl_ValueType(1)
			(*Tcl_Value)(unsafe.Pointer(resultPtr)).doubleValue = (func() float64 {
				if d0 > d1 {
					return d0
				}
				return d1
			}())
		} else if (*Tcl_Value)(unsafe.Pointer(args+uintptr(1)*32)).__type == Tcl_ValueType(3) {
			var w0 Tcl_WideInt = (int64(i0))
			var w1 Tcl_WideInt = (*Tcl_Value)(unsafe.Pointer(args + uintptr(1)*32)).wideValue

			(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = Tcl_ValueType(3)
			(*Tcl_Value)(unsafe.Pointer(resultPtr)).wideValue = (func() int64 {
				if w0 > w1 {
					return w0
				}
				return w1
			}())
		} else {
			(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, ts+4434 /* "T3: wrong type f..." */, (uintptr(0)))
			result = 1
		}
	} else if (*Tcl_Value)(unsafe.Pointer(args+uintptr(0)*32)).__type == Tcl_ValueType(1) {
		var d0 float64 = (*Tcl_Value)(unsafe.Pointer(args + uintptr(0)*32)).doubleValue

		if (*Tcl_Value)(unsafe.Pointer(args+uintptr(1)*32)).__type == Tcl_ValueType(0) {
			var d1 float64 = float64((*Tcl_Value)(unsafe.Pointer(args + uintptr(1)*32)).intValue)

			(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = Tcl_ValueType(1)
			(*Tcl_Value)(unsafe.Pointer(resultPtr)).doubleValue = (func() float64 {
				if d0 > d1 {
					return d0
				}
				return d1
			}())
		} else if (*Tcl_Value)(unsafe.Pointer(args+uintptr(1)*32)).__type == Tcl_ValueType(1) {
			var d1 float64 = (*Tcl_Value)(unsafe.Pointer(args + uintptr(1)*32)).doubleValue

			(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = Tcl_ValueType(1)
			(*Tcl_Value)(unsafe.Pointer(resultPtr)).doubleValue = (func() float64 {
				if d0 > d1 {
					return d0
				}
				return d1
			}())
		} else if (*Tcl_Value)(unsafe.Pointer(args+uintptr(1)*32)).__type == Tcl_ValueType(3) {
			var d1 float64 = (float64(((*Tcl_Value)(unsafe.Pointer(args + uintptr(1)*32)).wideValue)))

			(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = Tcl_ValueType(1)
			(*Tcl_Value)(unsafe.Pointer(resultPtr)).doubleValue = (func() float64 {
				if d0 > d1 {
					return d0
				}
				return d1
			}())
		} else {
			(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, ts+4434 /* "T3: wrong type f..." */, (uintptr(0)))
			result = 1
		}
	} else if (*Tcl_Value)(unsafe.Pointer(args+uintptr(0)*32)).__type == Tcl_ValueType(3) {
		var w0 Tcl_WideInt = (*Tcl_Value)(unsafe.Pointer(args + uintptr(0)*32)).wideValue

		if (*Tcl_Value)(unsafe.Pointer(args+uintptr(1)*32)).__type == Tcl_ValueType(0) {
			var w1 Tcl_WideInt = ((*Tcl_Value)(unsafe.Pointer(args + uintptr(1)*32)).intValue)

			(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = Tcl_ValueType(3)
			(*Tcl_Value)(unsafe.Pointer(resultPtr)).wideValue = (func() int64 {
				if w0 > w1 {
					return w0
				}
				return w1
			}())
		} else if (*Tcl_Value)(unsafe.Pointer(args+uintptr(1)*32)).__type == Tcl_ValueType(1) {
			var d0 float64 = (float64((w0)))
			var d1 float64 = (*Tcl_Value)(unsafe.Pointer(args + uintptr(1)*32)).doubleValue

			(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = Tcl_ValueType(1)
			(*Tcl_Value)(unsafe.Pointer(resultPtr)).doubleValue = (func() float64 {
				if d0 > d1 {
					return d0
				}
				return d1
			}())
		} else if (*Tcl_Value)(unsafe.Pointer(args+uintptr(1)*32)).__type == Tcl_ValueType(3) {
			var w1 Tcl_WideInt = (*Tcl_Value)(unsafe.Pointer(args + uintptr(1)*32)).wideValue

			(*Tcl_Value)(unsafe.Pointer(resultPtr)).__type = Tcl_ValueType(3)
			(*Tcl_Value)(unsafe.Pointer(resultPtr)).wideValue = (func() int64 {
				if w0 > w1 {
					return w0
				}
				return w1
			}())
		} else {
			(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, ts+4434 /* "T3: wrong type f..." */, (uintptr(0)))
			result = 1
		}
	} else {
		(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, ts+4459 /* "T3: wrong type f..." */, (uintptr(0)))
		result = 1
	}
	return result
}

//----------------------------------------------------------------------
//
// CleanupTestSetassocdataTests --
//
//	This function is called when an interpreter is deleted to clean
//	up any data left over from running the testsetassocdata command.
//
// Results:
//	None.
//
// Side effects:
//	Releases storage.
//
//----------------------------------------------------------------------
// ARGSUSED
func CleanupTestSetassocdataTests(tls *crt.TLS, clientData ClientData, interp uintptr) { /* tclTest.c:3507:1: */
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, (clientData))
}

//----------------------------------------------------------------------
//
// TestparserObjCmd --
//
//	This procedure implements the "testparser" command.  It is
//	used for testing the new Tcl script parser in Tcl 8.1.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestparserObjCmd(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:3532:1: */
	bp := tls.Alloc(584)
	defer tls.Free(584)

	var script uintptr
	// var length int32 at bp+4, 4

	// var dummy int32 at bp, 4

	// var parse Tcl_Parse at bp+8, 576

	if objc != 3 {
		(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+4484 /* "script length" */)
		return 1
	}
	script = (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 344 /* &.tcl_GetStringFromObj */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &dummy */)
	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 320 /* &.tcl_GetIntFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+4 /* &length */) != 0 {
		return 1
	}
	if *(*int32)(unsafe.Pointer(bp + 4 /* length */)) == 0 {
		*(*int32)(unsafe.Pointer(bp + 4 /* length */)) = *(*int32)(unsafe.Pointer(bp /* dummy */))
	}
	if (*(*func(*crt.TLS, uintptr, uintptr, int32, int32, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 2904 /* &.tcl_ParseCommand */))))(tls, interp, script, *(*int32)(unsafe.Pointer(bp + 4 /* length */)), 0, bp+8 /* &parse */) != 0 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 544 /* &.tcl_AddErrorInfo */))))(tls, interp, ts+4498 /* "\n    (remainder ..." */)
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 544 /* &.tcl_AddErrorInfo */))))(tls, interp, (*Tcl_Parse)(unsafe.Pointer(bp+8 /* &parse */)).term)
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 544 /* &.tcl_AddErrorInfo */))))(tls, interp, ts+4527 /* "\")" */)
		return 1
	}

	// The parse completed successfully.  Just print out the contents
	// of the parse structure into the interpreter's result.

	PrintParse(tls, interp, bp+8 /* &parse */)
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 2880 /* &.tcl_FreeParse */))))(tls, bp+8 /* &parse */)
	return 0
}

//----------------------------------------------------------------------
//
// TestexprparserObjCmd --
//
//	This procedure implements the "testexprparser" command.  It is
//	used for testing the new Tcl expression parser in Tcl 8.1.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestexprparserObjCmd(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:3588:1: */
	bp := tls.Alloc(584)
	defer tls.Free(584)

	var script uintptr
	// var length int32 at bp+4, 4

	// var dummy int32 at bp, 4

	// var parse Tcl_Parse at bp+8, 576

	if objc != 3 {
		(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+4530 /* "expr length" */)
		return 1
	}
	script = (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 344 /* &.tcl_GetStringFromObj */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &dummy */)
	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 320 /* &.tcl_GetIntFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+4 /* &length */) != 0 {
		return 1
	}
	if *(*int32)(unsafe.Pointer(bp + 4 /* length */)) == 0 {
		*(*int32)(unsafe.Pointer(bp + 4 /* length */)) = *(*int32)(unsafe.Pointer(bp /* dummy */))
	}
	(*Tcl_Parse)(unsafe.Pointer(bp + 8 /* &parse */)).commentStart = (uintptr(0))
	(*Tcl_Parse)(unsafe.Pointer(bp + 8 /* &parse */)).commentSize = 0
	(*Tcl_Parse)(unsafe.Pointer(bp + 8 /* &parse */)).commandStart = (uintptr(0))
	(*Tcl_Parse)(unsafe.Pointer(bp + 8 /* &parse */)).commandSize = 0
	if (*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 2912 /* &.tcl_ParseExpr */))))(tls, interp, script, *(*int32)(unsafe.Pointer(bp + 4 /* length */)), bp+8 /* &parse */) != 0 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 544 /* &.tcl_AddErrorInfo */))))(tls, interp, ts+4542 /* "\n    (remainder ..." */)
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 544 /* &.tcl_AddErrorInfo */))))(tls, interp, (*Tcl_Parse)(unsafe.Pointer(bp+8 /* &parse */)).term)
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 544 /* &.tcl_AddErrorInfo */))))(tls, interp, ts+4527 /* "\")" */)
		return 1
	}

	// The parse completed successfully.  Just print out the contents
	// of the parse structure into the interpreter's result.

	PrintParse(tls, interp, bp+8 /* &parse */)
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 2880 /* &.tcl_FreeParse */))))(tls, bp+8 /* &parse */)
	return 0
}

//----------------------------------------------------------------------
//
// PrintParse --
//
//	This procedure prints out the contents of a Tcl_Parse structure
//	in the result of an interpreter.
//
// Results:
//	Interp's result is set to a prettily formatted version of the
//	contents of parsePtr.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func PrintParse(tls *crt.TLS, interp uintptr, parsePtr uintptr) { /* tclTest.c:3649:1: */
	var objPtr uintptr
	var typeString uintptr
	var tokenPtr uintptr
	var i int32

	objPtr = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp)
	if (*Tcl_Parse)(unsafe.Pointer(parsePtr)).commentSize > 0 {
		(*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 368 /* &.tcl_ListObjAppendElement */))))(tls, (uintptr(0)), objPtr,
			(*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, (*Tcl_Parse)(unsafe.Pointer(parsePtr)).commentStart,
				(*Tcl_Parse)(unsafe.Pointer(parsePtr)).commentSize))
	} else {
		(*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 368 /* &.tcl_ListObjAppendElement */))))(tls, (uintptr(0)), objPtr, (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, ts+2495 /* "-" */, 1))
	}
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 368 /* &.tcl_ListObjAppendElement */))))(tls, (uintptr(0)), objPtr,
		(*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, (*Tcl_Parse)(unsafe.Pointer(parsePtr)).commandStart, (*Tcl_Parse)(unsafe.Pointer(parsePtr)).commandSize))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 368 /* &.tcl_ListObjAppendElement */))))(tls, (uintptr(0)), objPtr,
		(*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, (*Tcl_Parse)(unsafe.Pointer(parsePtr)).numWords))
	for i = 0; i < (*Tcl_Parse)(unsafe.Pointer(parsePtr)).numTokens; i++ {
		tokenPtr = ((*Tcl_Parse)(unsafe.Pointer(parsePtr)).tokenPtr + uintptr(i)*24)
		switch (*Tcl_Token)(unsafe.Pointer(tokenPtr)).__type {
		case 256:
			typeString = ts + 4569 /* "expand" */
			break
		case 1:
			typeString = ts + 4576 /* "word" */
			break
		case 2:
			typeString = ts + 249 /* "simple" */
			break
		case 4:
			typeString = ts + 4581 /* "text" */
			break
		case 8:
			typeString = ts + 4586 /* "backslash" */
			break
		case 16:
			typeString = ts + 4596 /* "command" */
			break
		case 32:
			typeString = ts + 4604 /* "variable" */
			break
		case 64:
			typeString = ts + 4613 /* "subexpr" */
			break
		case 128:
			typeString = ts + 4621 /* "operator" */
			break
		default:
			typeString = ts + 1539 /* "??" */
			break
		}
		(*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 368 /* &.tcl_ListObjAppendElement */))))(tls, (uintptr(0)), objPtr,
			(*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, typeString, -1))
		(*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 368 /* &.tcl_ListObjAppendElement */))))(tls, (uintptr(0)), objPtr,
			(*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, (*Tcl_Token)(unsafe.Pointer(tokenPtr)).start, (*Tcl_Token)(unsafe.Pointer(tokenPtr)).size))
		(*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 368 /* &.tcl_ListObjAppendElement */))))(tls, (uintptr(0)), objPtr,
			(*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, (*Tcl_Token)(unsafe.Pointer(tokenPtr)).numComponents))
	}
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 368 /* &.tcl_ListObjAppendElement */))))(tls, (uintptr(0)), objPtr,
		(*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, ((*Tcl_Parse)(unsafe.Pointer(parsePtr)).commandStart+uintptr((*Tcl_Parse)(unsafe.Pointer(parsePtr)).commandSize)),
			-1))
}

//----------------------------------------------------------------------
//
// TestparsevarObjCmd --
//
//	This procedure implements the "testparsevar" command.  It is
//	used for testing Tcl_ParseVar.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestparsevarObjCmd(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:3735:1: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var value uintptr
	var name uintptr
	// var termPtr uintptr at bp, 8

	if objc != 2 {
		(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+4630 /* "varName" */)
		return 1
	}
	name = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	value = (*(*func(*crt.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2176 /* &.tcl_ParseVar */))))(tls, interp, name, bp /* &termPtr */)
	if value == (uintptr(0)) {
		return 1
	}

	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, value)
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, *(*uintptr)(unsafe.Pointer(bp /* termPtr */)))
	return 0
}

//----------------------------------------------------------------------
//
// TestparsevarnameObjCmd --
//
//	This procedure implements the "testparsevarname" command.  It is
//	used for testing the new Tcl script parser in Tcl 8.1.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestparsevarnameObjCmd(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:3776:1: */
	bp := tls.Alloc(592)
	defer tls.Free(592)

	var script uintptr
	// var append int32 at bp+8, 4

	// var length int32 at bp+4, 4

	// var dummy int32 at bp, 4

	// var parse Tcl_Parse at bp+16, 576

	if objc != 4 {
		(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+4638 /* "script length ap..." */)
		return 1
	}
	script = (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 344 /* &.tcl_GetStringFromObj */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &dummy */)
	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 320 /* &.tcl_GetIntFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+4 /* &length */) != 0 {
		return 1
	}
	if *(*int32)(unsafe.Pointer(bp + 4 /* length */)) == 0 {
		*(*int32)(unsafe.Pointer(bp + 4 /* length */)) = *(*int32)(unsafe.Pointer(bp /* dummy */))
	}
	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 320 /* &.tcl_GetIntFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+8 /* &append */) != 0 {
		return 1
	}
	if (*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr, int32) int32)(unsafe.Pointer((tclStubsPtr + 2928 /* &.tcl_ParseVarName */))))(tls, interp, script, *(*int32)(unsafe.Pointer(bp + 4 /* length */)), bp+16 /* &parse */, *(*int32)(unsafe.Pointer(bp + 8 /* append */))) != 0 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 544 /* &.tcl_AddErrorInfo */))))(tls, interp, ts+4498 /* "\n    (remainder ..." */)
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 544 /* &.tcl_AddErrorInfo */))))(tls, interp, (*Tcl_Parse)(unsafe.Pointer(bp+16 /* &parse */)).term)
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 544 /* &.tcl_AddErrorInfo */))))(tls, interp, ts+4527 /* "\")" */)
		return 1
	}

	// The parse completed successfully.  Just print out the contents
	// of the parse structure into the interpreter's result.

	(*Tcl_Parse)(unsafe.Pointer(bp + 16 /* &parse */)).commentSize = 0
	(*Tcl_Parse)(unsafe.Pointer(bp + 16 /* &parse */)).commandStart = (script + uintptr((*Tcl_Token)(unsafe.Pointer((*Tcl_Parse)(unsafe.Pointer(bp+16 /* &parse */)).tokenPtr)).size))
	(*Tcl_Parse)(unsafe.Pointer(bp + 16 /* &parse */)).commandSize = 0
	PrintParse(tls, interp, bp+16 /* &parse */)
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 2880 /* &.tcl_FreeParse */))))(tls, bp+16 /* &parse */)
	return 0
}

//----------------------------------------------------------------------
//
// TestregexpObjCmd --
//
//	This procedure implements the "testregexp" command. It is used to give
//	a direct interface for regexp flags. It's identical to
//	Tcl_RegexpObjCmd except for the -xflags option, and the consequences
//	thereof (including the REG_EXPECT kludge).
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	See the user documentation.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestregexpObjCmd(tls *crt.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:3841:1: */
	bp := tls.Alloc(264)
	defer tls.Free(264)

	var i int32
	var ii int32
	var indices int32
	// var stringLength int32 at bp+92, 4

	var match int32
	var about int32
	var hasxflags int32
	// var cflags int32 at bp+96, 4

	// var eflags int32 at bp+100, 4

	var regExpr Tcl_RegExp
	var string uintptr
	var objPtr uintptr
	// var info Tcl_RegExpInfo at bp+160, 32

	var name uintptr
	// var index int32 at bp+88, 4

	var varName uintptr
	var value uintptr
	// var start int32 at bp+104, 4

	// var end int32 at bp+108, 4

	// var resinfo [48]int8 at bp+112, 48

	var varName1 uintptr
	var value1 uintptr
	// var resinfo1 [48]int8 at bp+192, 48

	// var objs [2]uintptr at bp+248, 16

	// var start1 int32 at bp+240, 4

	// var end1 int32 at bp+244, 4

	var newPtr uintptr
	var varPtr uintptr
	var valuePtr uintptr

	indices = 0
	about = 0
	*(*int32)(unsafe.Pointer(bp + 96 /* cflags */)) = 000003
	*(*int32)(unsafe.Pointer(bp + 100 /* eflags */)) = 0
	hasxflags = 0

	i = 1
__1:
	if !(i < objc) {
		goto __3
	}

	name = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)))
	if !(int32(*(*int8)(unsafe.Pointer(name + uintptr(0)))) != '-') {
		goto __4
	}
	goto __3
__4:
	;
	if !((*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 2448 /* &.tcl_GetIndexFromObjStruct */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)), uintptr(unsafe.Pointer(&options1)), int32(8), ts+4659 /* "switch" */, 1, bp+88 /* &index */) != 0) {
		goto __5
	}
	return 1
__5:
	;
	switch uint32(*(*int32)(unsafe.Pointer(bp + 88 /* index */))) {
	case uint32(0):
		goto __7
	case uint32(1):
		goto __8
	case uint32(2):
		goto __9
	case uint32(3):
		goto __10
	case uint32(4):
		goto __11
	case uint32(5):
		goto __12
	case uint32(6):
		goto __13
	case uint32(7):
		goto __14
	case uint32(8):
		goto __15
	}
	goto __6
__7:
	indices = 1
	goto __6
__8:
	*(*int32)(unsafe.Pointer(bp + 96 /* cflags */)) |= 000010
	goto __6
__9:
	about = 1
	goto __6
__10:
	*(*int32)(unsafe.Pointer(bp + 96 /* cflags */)) |= 000040
	goto __6
__11:
	*(*int32)(unsafe.Pointer(bp + 96 /* cflags */)) |= 000300
	goto __6
__12:
	*(*int32)(unsafe.Pointer(bp + 96 /* cflags */)) |= 000100
	goto __6
__13:
	*(*int32)(unsafe.Pointer(bp + 96 /* cflags */)) |= 000200
	goto __6
__14:
	hasxflags = 1
	goto __6
__15:
	i++
	goto endOfForLoop
__6:
	;
	goto __2
__2:
	i++
	goto __1
	goto __3
__3:
	;

endOfForLoop:
	if !((objc - i) < ((hasxflags + 2) - about)) {
		goto __16
	}
	(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv,
		ts+4666 /* "?-switch ...? ex..." */)
	return 1
__16:
	;
	objc = objc - (i)
	objv += 8 * uintptr(i)

	if !(hasxflags != 0) {
		goto __17
	}
	string = (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 344 /* &.tcl_GetStringFromObj */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), bp+92 /* &stringLength */)
	TestregexpXflags(tls, string, *(*int32)(unsafe.Pointer(bp + 92 /* stringLength */)), bp+96 /* &cflags */, bp+100 /* &eflags */)
	objc--
	objv += 8
__17:
	;

	regExpr = (*(*func(*crt.TLS, uintptr, uintptr, int32) Tcl_RegExp)(unsafe.Pointer((tclStubsPtr + 2864 /* &.tcl_GetRegExpFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8)), *(*int32)(unsafe.Pointer(bp + 96 /* cflags */)))
	if !(regExpr == (uintptr(0))) {
		goto __18
	}
	return 1
__18:
	;

	if !(about != 0) {
		goto __19
	}
	if !((*(*func(*crt.TLS, uintptr, Tcl_RegExp) int32)(unsafe.Pointer((tclIntStubsPtr + 1216 /* &.tclRegAbout */))))(tls, interp, regExpr) < 0) {
		goto __20
	}
	return 1
__20:
	;
	return 0
__19:
	;

	objPtr = *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))
	match = (*(*func(*crt.TLS, uintptr, Tcl_RegExp, uintptr, int32, int32, int32) int32)(unsafe.Pointer((tclStubsPtr + 3024 /* &.tcl_RegExpExecObj */))))(tls, interp, regExpr, objPtr, 0,
		(objc - 2), *(*int32)(unsafe.Pointer(bp + 100 /* eflags */)))

	if !(match < 0) {
		goto __21
	}
	return 1
__21:
	;
	if !(match == 0) {
		goto __22
	}
	// Set the interpreter's object result to an integer object w/
	// value 0.

	(*(*func(*crt.TLS, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 504 /* &.tcl_SetIntObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp), 0)
	if !(((objc > 2) && ((*(*int32)(unsafe.Pointer(bp + 96 /* cflags */)) & 001000) != 0)) && (indices != 0)) {
		goto __23
	}

	varName = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	(*(*func(*crt.TLS, Tcl_RegExp, int32, uintptr, uintptr))(unsafe.Pointer((tclIntStubsPtr + 1224 /* &.tclRegExpRangeUniChar */))))(tls, regExpr, -1, bp+104 /* &start */, bp+108 /* &end */)
	crt.Xsprintf(tls, bp+112 /* &resinfo */, ts+4720 /* "%d %d" */, crt.VaList(bp, *(*int32)(unsafe.Pointer(bp + 104 /* start */)), (*(*int32)(unsafe.Pointer(bp + 108 /* end */))-1)))
	value = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 1920 /* &.tcl_SetVar2 */))))(tls, interp, varName, (uintptr(0)), bp+112 /* &resinfo */, 0)
	if !(value == (uintptr(0))) {
		goto __25
	}
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+16, ts+4726, /* "couldn't set var..." */
		varName, ts+1804 /* "\"" */, (uintptr(0))))
	return 1
__25:
	;
	goto __24
__23:
	if !((*(*int32)(unsafe.Pointer(bp + 96 /* cflags */)) & 001000) != 0) {
		goto __26
	}

	(*(*func(*crt.TLS, Tcl_RegExp, uintptr))(unsafe.Pointer((tclStubsPtr + 3032 /* &.tcl_RegExpGetInfo */))))(tls, regExpr, bp+160 /* &info */)
	varName1 = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	crt.Xsprintf(tls, bp+192 /* &resinfo1 */, ts+4750 /* "%ld" */, crt.VaList(bp+48, (*Tcl_RegExpInfo)(unsafe.Pointer(bp+160 /* &info */)).extendStart))
	value1 = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 1920 /* &.tcl_SetVar2 */))))(tls, interp, varName1, (uintptr(0)), bp+192 /* &resinfo1 */, 0)
	if !(value1 == (uintptr(0))) {
		goto __27
	}
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+56, ts+4726, /* "couldn't set var..." */
		varName1, ts+1804 /* "\"" */, (uintptr(0))))
	return 1
__27:
	;
__26:
	;
__24:
	;
	return 0
__22:
	;

	// If additional variable names have been specified, return
	// index information in those variables.

	objc = objc - (2)
	objv += 8 * uintptr(2)

	(*(*func(*crt.TLS, Tcl_RegExp, uintptr))(unsafe.Pointer((tclStubsPtr + 3032 /* &.tcl_RegExpGetInfo */))))(tls, regExpr, bp+160 /* &info */)
	i = 0
__28:
	if !(i < objc) {
		goto __30
	}

	varPtr = *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8))
	if ((*(*int32)(unsafe.Pointer(bp + 96 /* cflags */)) & 001000) != 0) && (i == (objc - 1)) {
		ii = -1
	} else {
		ii = i
	}
	if !(indices != 0) {
		goto __31
	}

	if !(ii == -1) {
		goto __33
	}
	(*(*func(*crt.TLS, Tcl_RegExp, int32, uintptr, uintptr))(unsafe.Pointer((tclIntStubsPtr + 1224 /* &.tclRegExpRangeUniChar */))))(tls, regExpr, ii, bp+240 /* &start1 */, bp+244 /* &end1 */)
	goto __34
__33:
	if !(ii > (*Tcl_RegExpInfo)(unsafe.Pointer(bp+160 /* &info */)).nsubs) {
		goto __35
	}
	*(*int32)(unsafe.Pointer(bp + 240 /* start1 */)) = -1
	*(*int32)(unsafe.Pointer(bp + 244 /* end1 */)) = -1
	goto __36
__35:
	*(*int32)(unsafe.Pointer(bp + 240 /* start1 */)) = int32((*Tcl_RegExpIndices)(unsafe.Pointer((*Tcl_RegExpInfo)(unsafe.Pointer(bp+160 /* &info */)).matches + uintptr(ii)*16)).start)
	*(*int32)(unsafe.Pointer(bp + 244 /* end1 */)) = int32((*Tcl_RegExpIndices)(unsafe.Pointer((*Tcl_RegExpInfo)(unsafe.Pointer(bp+160 /* &info */)).matches + uintptr(ii)*16)).end)
__36:
	;
__34:
	;

	// Adjust index so it refers to the last character in the match
	// instead of the first character after the match.

	if !(*(*int32)(unsafe.Pointer(bp + 244 /* end1 */)) >= 0) {
		goto __37
	}
	*(*int32)(unsafe.Pointer(bp + 244 /* end1 */))--
__37:
	;

	*(*uintptr)(unsafe.Pointer(bp + 248 /* &objs */ + uintptr(0)*8)) = (*(*func(*crt.TLS, int64) uintptr)(unsafe.Pointer((tclStubsPtr + 448 /* &.tcl_NewLongObj */))))(tls, int64(*(*int32)(unsafe.Pointer(bp + 240 /* start1 */))))
	*(*uintptr)(unsafe.Pointer(bp + 248 /* &objs */ + uintptr(1)*8)) = (*(*func(*crt.TLS, int64) uintptr)(unsafe.Pointer((tclStubsPtr + 448 /* &.tcl_NewLongObj */))))(tls, int64(*(*int32)(unsafe.Pointer(bp + 244 /* end1 */))))

	newPtr = (*(*func(*crt.TLS, int32, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 440 /* &.tcl_NewListObj */))))(tls, 2, bp+248 /* &objs */)
	goto __32
__31:
	if !(ii == -1) {
		goto __38
	}
	(*(*func(*crt.TLS, Tcl_RegExp, int32, uintptr, uintptr))(unsafe.Pointer((tclIntStubsPtr + 1224 /* &.tclRegExpRangeUniChar */))))(tls, regExpr, ii, bp+240 /* &start1 */, bp+244 /* &end1 */)
	newPtr = (*(*func(*crt.TLS, uintptr, int32, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 3080 /* &.tcl_GetRange */))))(tls, objPtr, *(*int32)(unsafe.Pointer(bp + 240 /* start1 */)), *(*int32)(unsafe.Pointer(bp + 244 /* end1 */)))
	goto __39
__38:
	if !(ii > (*Tcl_RegExpInfo)(unsafe.Pointer(bp+160 /* &info */)).nsubs) {
		goto __40
	}
	newPtr = (*(*func(*crt.TLS) uintptr)(unsafe.Pointer((tclStubsPtr + 456 /* &.tcl_NewObj */))))(tls)
	goto __41
__40:
	newPtr = (*(*func(*crt.TLS, uintptr, int32, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 3080 /* &.tcl_GetRange */))))(tls, objPtr, int32((*Tcl_RegExpIndices)(unsafe.Pointer((*Tcl_RegExpInfo)(unsafe.Pointer(bp+160 /* &info */)).matches+uintptr(ii)*16)).start),
		(int32((*Tcl_RegExpIndices)(unsafe.Pointer((*Tcl_RegExpInfo)(unsafe.Pointer(bp+160 /* &info */)).matches+uintptr(ii)*16)).end - int64(1))))
__41:
	;
__39:
	;
__32:
	;
	valuePtr = ((*(*func(*crt.TLS, uintptr, uintptr, uintptr, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 1584 /* &.tcl_ObjSetVar2 */))))(tls, interp, varPtr, (uintptr(0)), newPtr, 0x200))
	if !(valuePtr == (uintptr(0))) {
		goto __42
	}
	return 1
__42:
	;
	goto __29
__29:
	i++
	goto __28
	goto __30
__30:
	;

	// Set the interpreter's object result to an integer object w/ value 1.

	(*(*func(*crt.TLS, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 504 /* &.tcl_SetIntObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp), 1)
	return 0
}

var options1 = [10]uintptr{
	ts + 4754 /* "-indices" */, ts + 4763 /* "-nocase" */, ts + 4771 /* "-about" */, ts + 4778, /* "-expanded" */
	ts + 4788 /* "-line" */, ts + 4794 /* "-linestop" */, ts + 4804, /* "-lineanchor" */
	ts + 4816, /* "-xflags" */
	ts + 4824 /* "--" */, (uintptr(0)),
} /* tclTest.c:3853:23 */

//---------------------------------------------------------------------------
//
// TestregexpXflags --
//
//	Parse a string of extended regexp flag letters, for testing.
//
// Results:
//	No return value (you're on your own for errors here).
//
// Side effects:
//	Modifies *cflagsPtr, a regcomp flags word, and *eflagsPtr, a
//	regexec flags word, as appropriate.
//
//----------------------------------------------------------------------

func TestregexpXflags(tls *crt.TLS, string uintptr, length int32, cflagsPtr uintptr, eflagsPtr uintptr) { /* tclTest.c:4074:1: */
	var i int32
	var cflags int32
	var eflags int32

	cflags = *(*int32)(unsafe.Pointer(cflagsPtr))
	eflags = *(*int32)(unsafe.Pointer(eflagsPtr))
	for i = 0; i < length; i++ {
		switch int32(*(*int8)(unsafe.Pointer(string + uintptr(i)))) {
		case 'a':
			cflags = cflags | (000002)
			break
		case 'b':
			cflags = cflags & (^int32(crt.Int32FromInt32(000003)))
			break
		case 'c':
			cflags = cflags | (001000)
			break
		case 'e':
			cflags = cflags & (^int32(crt.Int32FromInt32(000003)))
			cflags = cflags | (000001)
			break
		case 'q':
			cflags = cflags & (^int32(crt.Int32FromInt32(000003)))
			cflags = cflags | (000004)
			break
		case 'o': // o for opaque
			cflags = cflags | (000020)
			break
		case 's': // s for start
			cflags = cflags | (002000)
			break
		case '+':
			cflags = cflags | (010000)
			break
		case ',':
			cflags = cflags | (020000)
			break
		case '.':
			cflags = cflags | (004000)
			break
		case ':':
			eflags = eflags | (0020)
			break
		case ';':
			eflags = eflags | (0010)
			break
		case '^':
			eflags = eflags | (0001)
			break
		case '$':
			eflags = eflags | (0002)
			break
		case 't':
			cflags = cflags | (001000)
			break
		case '%':
			eflags = eflags | (0040)
			break
		}
	}

	*(*int32)(unsafe.Pointer(cflagsPtr)) = cflags
	*(*int32)(unsafe.Pointer(eflagsPtr)) = eflags
}

//----------------------------------------------------------------------
//
// TestreturnObjCmd --
//
//	This procedure implements the "testreturn" command. It is
//	used to verify that a
//		return TCL_RETURN;
//	has same behavior as
//		return Tcl_SetReturnOptions(interp, Tcl_NewObj());
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	See the user documentation.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestreturnObjCmd(tls *crt.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:4165:1: */
	return 2
}

//----------------------------------------------------------------------
//
// TestsetassocdataCmd --
//
//	This procedure implements the "testsetassocdata" command. It is used
//	to test Tcl_SetAssocData.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Modifies or creates an association between a key and associated
//	data for this interpreter.
//
//----------------------------------------------------------------------

func TestsetassocdataCmd(tls *crt.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4193:1: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var buf uintptr
	var oldData uintptr
	// var procPtr uintptr at bp+32, 8

	if argc != 3 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+2369 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+4827 /* " data_key data_i..." */, (uintptr(0))))
		return 1
	}

	buf = ((*(*func(*crt.TLS, uint32) uintptr)(unsafe.Pointer((tclStubsPtr + 40 /* &.tcl_Alloc */))))(tls, (uint32(crt.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8))) + uint64(1)))))
	crt.Xstrcpy(tls, buf, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)))

	// If we previously associated a malloced value with the variable,
	// free it before associating a new value.

	oldData = (*(*func(*crt.TLS, uintptr, uintptr, uintptr) ClientData)(unsafe.Pointer((tclStubsPtr + 1216 /* &.tcl_GetAssocData */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+32 /* &procPtr */)
	if (oldData != (uintptr(0))) && (*(*uintptr)(unsafe.Pointer(bp + 32 /* procPtr */)) == *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr)
	}{CleanupTestSetassocdataTests}))) {
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, (oldData))
	}

	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData))(unsafe.Pointer((tclStubsPtr + 1800 /* &.tcl_SetAssocData */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr)
	}{CleanupTestSetassocdataTests})),
		buf)
	return 0
}

//----------------------------------------------------------------------
//
// TestsetplatformCmd --
//
//	This procedure implements the "testsetplatform" command. It is
//	used to change the tclPlatform global variable so all file
//	name conversions can be tested on a single platform.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Sets the tclPlatform global variable.
//
//----------------------------------------------------------------------

func TestsetplatformCmd(tls *crt.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4245:1: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var length size_t
	var platform uintptr

	platform = (*(*func(*crt.TLS) uintptr)(unsafe.Pointer((tclIntStubsPtr + 1808 /* &.tclGetPlatform */))))(tls)

	if argc != 2 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+2369 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+4848 /* " platform\"" */, (uintptr(0))))
		return 1
	}

	length = crt.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	if crt.Xstrncmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+3895 /* "unix" */, length) == 0 {
		*(*TclPlatformType)(unsafe.Pointer(platform)) = TclPlatformType(0)
	} else if crt.Xstrncmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+3904 /* "windows" */, length) == 0 {
		*(*TclPlatformType)(unsafe.Pointer(platform)) = TclPlatformType(2)
	} else {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp,
			crt.VaList(bp+32, ts+4859 /* "unsupported plat..." */, (uintptr(0))))
		return 1
	}
	return 0
}

//----------------------------------------------------------------------
//
// TeststaticpkgCmd --
//
//	This procedure implements the "teststaticpkg" command.
//	It is used to test the procedure Tcl_StaticPackage.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	When the packge given by argv[1] is loaded into an interpeter,
//	variable "x" in that interpreter is set to "loaded".
//
//----------------------------------------------------------------------

func TeststaticpkgCmd(tls *crt.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4294:1: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var safe int32 at bp+32, 4

	// var loaded int32 at bp+36, 4

	if argc != 4 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+2369, /* "wrong # argument..." */
			*(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)), ts+4915 /* " pkgName safe lo..." */, (uintptr(0))))
		return 1
	}
	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), bp+32 /* &safe */) != 0 {
		return 1
	}
	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), bp+36 /* &loaded */) != 0 {
		return 1
	}
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1968 /* &.tcl_StaticPackage */))))(tls, func() uintptr {
		if *(*int32)(unsafe.Pointer(bp + 36 /* loaded */)) != 0 {
			return interp
		}
		return (uintptr(0))
	}(), *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)),
		*(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) int32 }{StaticInitProc})), func() uintptr {
			if *(*int32)(unsafe.Pointer(bp + 32 /* safe */)) != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) int32 }{StaticInitProc}))
			}
			return (uintptr(0))
		}())
	return 0
}

func StaticInitProc(tls *crt.TLS, interp uintptr) int32 { /* tclTest.c:4319:1: */
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 1920 /* &.tcl_SetVar2 */))))(tls, interp, ts+4937 /* "x" */, (uintptr(0)), ts+4939 /* "loaded" */, 1)
	return 0
}

//----------------------------------------------------------------------
//
// TesttranslatefilenameCmd --
//
//	This procedure implements the "testtranslatefilename" command.
//	It is used to test the Tcl_TranslateFileName command.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TesttranslatefilenameCmd(tls *crt.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4345:1: */
	bp := tls.Alloc(264)
	defer tls.Free(264)

	// var buffer Tcl_DString at bp+48, 216

	var result uintptr

	if argc != 2 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+2369, /* "wrong # argument..." */
			*(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)), ts+3912 /* " path\"" */, (uintptr(0))))
		return 1
	}
	result = (*(*func(*crt.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2008 /* &.tcl_TranslateFileName */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+48 /* &buffer */)
	if result == (uintptr(0)) {
		return 1
	}
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+32, result, (uintptr(0))))
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 976 /* &.tcl_DStringFree */))))(tls, bp+48 /* &buffer */)
	return 0
}

//----------------------------------------------------------------------
//
// TestupvarCmd --
//
//	This procedure implements the "testupvar" command.  It is used
//	to test Tcl_UpVar and Tcl_UpVar2.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates or modifies an "upvar" reference.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestupvarCmd(tls *crt.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4387:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var flags int32 = 0

	if (argc != 5) && (argc != 6) {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+2369, /* "wrong # argument..." */
			*(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)), ts+4946 /* " level name ?nam..." */, (uintptr(0))))
		return 1
	}

	if argc == 5 {
		if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)), ts+3368 /* "global" */) == 0 {
			flags = 1
		} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)), ts+4979 /* "namespace" */) == 0 {
			flags = 2
		}
		return (*(*func(*crt.TLS, uintptr, uintptr, uintptr, uintptr, uintptr, int32) int32)(unsafe.Pointer((tclStubsPtr + 2088 /* &.tcl_UpVar2 */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), (uintptr(0)), *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), flags)
	} else {
		if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(5)*8)), ts+3368 /* "global" */) == 0 {
			flags = 1
		} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(5)*8)), ts+4979 /* "namespace" */) == 0 {
			flags = 2
		}
		return (*(*func(*crt.TLS, uintptr, uintptr, uintptr, uintptr, uintptr, int32) int32)(unsafe.Pointer((tclStubsPtr + 2088 /* &.tcl_UpVar2 */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)),
			func() uintptr {
				if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)) + uintptr(0)))) == 0 {
					return (uintptr(0))
				}
				return *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8))
			}(), *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)),
			flags)
	}
	return int32(0)
}

//----------------------------------------------------------------------
//
// TestseterrorcodeCmd --
//
//	This procedure implements the "testseterrorcodeCmd".  This tests up to
//	five elements passed to the Tcl_SetErrorCode command.
//
// Results:
//	A standard Tcl result. Always returns TCL_ERROR so that
//	the error code can be tested.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestseterrorcodeCmd(tls *crt.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4440:1: */
	bp := tls.Alloc(176)
	defer tls.Free(176)

	if argc > 6 {
		(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, ts+4989 /* "too many args" */, (uintptr(0)))
		return 1
	}
	switch argc {
	case 1:
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1840 /* &.tcl_SetErrorCode */))))(tls, interp, crt.VaList(bp, ts+5003 /* "NONE" */, (uintptr(0))))
		break
	case 2:
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1840 /* &.tcl_SetErrorCode */))))(tls, interp, crt.VaList(bp+16, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), (uintptr(0))))
		break
	case 3:
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1840 /* &.tcl_SetErrorCode */))))(tls, interp, crt.VaList(bp+32, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), (uintptr(0))))
		break
	case 4:
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1840 /* &.tcl_SetErrorCode */))))(tls, interp, crt.VaList(bp+56, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), (uintptr(0))))
		break
	case 5:
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1840 /* &.tcl_SetErrorCode */))))(tls, interp, crt.VaList(bp+88, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)), (uintptr(0))))
		break
	case 6:
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1840 /* &.tcl_SetErrorCode */))))(tls, interp, crt.VaList(bp+128, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)),
			*(*uintptr)(unsafe.Pointer(argv + uintptr(5)*8)), (uintptr(0))))
	}
	return 1
}

//----------------------------------------------------------------------
//
// TestsetobjerrorcodeCmd --
//
//	This procedure implements the "testsetobjerrorcodeCmd".
//	This tests the Tcl_SetObjErrorCode function.
//
// Results:
//	A standard Tcl result. Always returns TCL_ERROR so that
//	the error code can be tested.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestsetobjerrorcodeCmd(tls *crt.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:4493:1: */
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1888 /* &.tcl_SetObjErrorCode */))))(tls, interp, (*(*func(*crt.TLS, int32, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 152 /* &.tcl_ConcatObj */))))(tls, (objc-1), (objv+uintptr(1)*8)))
	return 1
}

//----------------------------------------------------------------------
//
// TestfeventCmd --
//
//	This procedure implements the "testfevent" command.  It is
//	used for testing the "fileevent" command.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates and deletes interpreters.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestfeventCmd(tls *crt.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4522:1: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var code int32
	var chan1 Tcl_Channel

	if argc < 2 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+1483 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+5008 /* " option ?arg ......" */, (uintptr(0))))
		return 1
	}
	if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+5026 /* "cmd" */) == 0 {
		if argc != 3 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+32, ts+1483 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
				ts+5030 /* " cmd script" */, (uintptr(0))))
			return 1
		}
		if interp2 != (uintptr(0)) {
			code = (*(*func(*crt.TLS, uintptr, uintptr, int32, int32) int32)(unsafe.Pointer((tclStubsPtr + 2344 /* &.tcl_EvalEx */))))(tls, interp2, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), -1, 0x020000)
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp2))
			return code
		} else {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp,
				crt.VaList(bp+64, ts+5042, /* "called \"testfeve..." */
					(uintptr(0))))
			return 1
		}
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+1410 /* "create" */) == 0 {
		if interp2 != (uintptr(0)) {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 896 /* &.tcl_DeleteInterp */))))(tls, interp2)
		}
		interp2 = ((*(*func(*crt.TLS) uintptr)(unsafe.Pointer((tclStubsPtr + 768 /* &.tcl_CreateInterp */))))(tls))
		return ((*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 1456 /* &.tcl_Init */))))(tls, interp2))
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+1417 /* "delete" */) == 0 {
		if interp2 != (uintptr(0)) {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 896 /* &.tcl_DeleteInterp */))))(tls, interp2)
		}
		interp2 = (uintptr(0))
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+5094 /* "share" */) == 0 {
		if interp2 != (uintptr(0)) {
			chan1 = (*(*func(*crt.TLS, uintptr, uintptr, uintptr) Tcl_Channel)(unsafe.Pointer((tclStubsPtr + 1224 /* &.tcl_GetChannel */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), (uintptr(0)))
			if chan1 == (uintptr(0)) {
				return 1
			}
			(*(*func(*crt.TLS, uintptr, Tcl_Channel))(unsafe.Pointer((tclStubsPtr + 1696 /* &.tcl_RegisterChannel */))))(tls, interp2, chan1)
		}
	}

	return 0
}

var interp2 uintptr = (uintptr(0)) /* tclTest.c:4528:23 */

//----------------------------------------------------------------------
//
// TestpanicCmd --
//
//	Calls the panic routine.
//
// Results:
//	Always returns TCL_OK.
//
// Side effects:
//	May exit application.
//
//----------------------------------------------------------------------

func TestpanicCmd(tls *crt.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4594:1: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var argString uintptr

	//  Put the arguments into a var args structure
	//  Append all of the arguments together separated by spaces

	argString = (*(*func(*crt.TLS, int32, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1552 /* &.tcl_Merge */))))(tls, (argc - 1), (argv + uintptr(1)*8))
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 32 /* &.tcl_Panic */))))(tls, ts+5100 /* "%s" */, crt.VaList(bp, argString))
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, (argString))

	return 0
}

func TestfileCmd(tls *crt.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4615:1: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var force int32
	var i int32
	var j int32
	var result int32
	// var error uintptr at bp+40, 8

	var subcmd uintptr
	var _objPtr uintptr
	*(*uintptr)(unsafe.Pointer(bp + 40 /* error */)) = (uintptr(0))

	if !(argc < 3) {
		goto __1
	}
	return 1
__1:
	;

	force = 0
	i = 2
	if !(crt.Xstrcmp(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8))), ts+5103 /* "-force" */) == 0) {
		goto __2
	}
	force = 1
	i = 3
__2:
	;

	if !((argc - i) > 2) {
		goto __3
	}
	return 1
__3:
	;

	j = i
__4:
	if !(j < argc) {
		goto __6
	}
	if !((*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 3720 /* &.tcl_FSGetNormalizedPath */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(j)*8))) == (uintptr(0))) {
		goto __7
	}
	return 1
__7:
	;
	goto __5
__5:
	j++
	goto __4
	goto __6
__6:
	;

	subcmd = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))

	if !(crt.Xstrcmp(tls, subcmd, ts+5110 /* "mv" */) == 0) {
		goto __8
	}
	result = (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((tclIntStubsPtr + 1656 /* &.tclpObjRenameFile */))))(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), *(*uintptr)(unsafe.Pointer(argv + uintptr((i+1))*8)))
	goto __9
__8:
	if !(crt.Xstrcmp(tls, subcmd, ts+5113 /* "cp" */) == 0) {
		goto __10
	}
	result = (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((tclIntStubsPtr + 1648 /* &.tclpObjCopyFile */))))(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), *(*uintptr)(unsafe.Pointer(argv + uintptr((i+1))*8)))
	goto __11
__10:
	if !(crt.Xstrcmp(tls, subcmd, ts+5116 /* "rm" */) == 0) {
		goto __12
	}
	result = (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer((tclIntStubsPtr + 1640 /* &.tclpObjDeleteFile */))))(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
	goto __13
__12:
	if !(crt.Xstrcmp(tls, subcmd, ts+5119 /* "mkdir" */) == 0) {
		goto __14
	}
	result = (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer((tclIntStubsPtr + 1632 /* &.tclpObjCreateDirectory */))))(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
	goto __15
__14:
	if !(crt.Xstrcmp(tls, subcmd, ts+5125 /* "cpdir" */) == 0) {
		goto __16
	}
	result = (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclIntStubsPtr + 1624 /* &.tclpObjCopyDirectory */))))(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), *(*uintptr)(unsafe.Pointer(argv + uintptr((i+1))*8)), bp+40 /* &error */)
	goto __17
__16:
	if !(crt.Xstrcmp(tls, subcmd, ts+5131 /* "rmdir" */) == 0) {
		goto __18
	}
	result = (*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer((tclIntStubsPtr + 1616 /* &.tclpObjRemoveDirectory */))))(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), force, bp+40 /* &error */)
	goto __19
__18:
	result = 1
	goto end
__19:
	;
__17:
	;
__15:
	;
__13:
	;
__11:
	;
__9:
	;

	if !(result != 0) {
		goto __20
	}
	if !(*(*uintptr)(unsafe.Pointer(bp + 40 /* error */)) != (uintptr(0))) {
		goto __21
	}
	if !(int32(*(*int8)(unsafe.Pointer((*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* error */))) + uintptr(0)))) != 0) {
		goto __22
	}
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* error */))), ts+1551 /* " " */, (uintptr(0))))
__22:
	;
__23:
	_objPtr = (*(*uintptr)(unsafe.Pointer(bp + 40 /* error */)))
	if !(crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1) {
		goto __26
	}
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
__26:
	;
	goto __24
__24:
	if 0 != 0 {
		goto __23
	}
	goto __25
__25:
	;
__21:
	;
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+24, (*(*func(*crt.TLS) uintptr)(unsafe.Pointer((tclStubsPtr + 1032 /* &.tcl_ErrnoId */))))(tls), (uintptr(0))))
__20:
	;

end:
	return result
}

//----------------------------------------------------------------------
//
// TestgetvarfullnameCmd --
//
//	Implements the "testgetvarfullname" cmd that is used when testing
//	the Tcl_GetVariableFullName procedure.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestgetvarfullnameCmd(tls *crt.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:4697:1: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var name uintptr
	var arg uintptr
	var flags int32 = 0
	var namespacePtr uintptr
	// var framePtr uintptr at bp, 8

	var variable Tcl_Var

	if objc != 3 {
		(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+5137 /* "name scope" */)
		return 1
	}

	name = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))

	arg = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if crt.Xstrcmp(tls, arg, ts+3368 /* "global" */) == 0 {
		flags = 1
	} else if crt.Xstrcmp(tls, arg, ts+4979 /* "namespace" */) == 0 {
		flags = 2
	}

	// This command, like any other created with Tcl_Create[Obj]Command, runs
	// in the global namespace. As a "namespace-aware" command that needs to
	// run in a particular namespace, it must activate that namespace itself.

	if flags == 2 {
		namespacePtr = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32) uintptr)(unsafe.Pointer((tclIntStubsPtr + 952 /* &.tcl_FindNamespace */))))(tls, interp, ts+5148 /* "::test_ns_var" */, (uintptr(0)),
			0x200)
		if namespacePtr == (uintptr(0)) {
			return 1
		}
		(*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32) int32)(unsafe.Pointer((tclIntStubsPtr + 1752 /* &.tclPushStackFrame */))))(tls, interp, bp /* &framePtr */, namespacePtr,
			/*isProcCallFrame*/ 0)
	}

	variable = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32) Tcl_Var)(unsafe.Pointer((tclIntStubsPtr + 976 /* &.tcl_FindNamespaceVar */))))(tls, interp, name, (uintptr(0)),
		(flags | 0x200))

	if flags == 2 {
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclIntStubsPtr + 1760 /* &.tclPopStackFrame */))))(tls, interp)
	}
	if variable == (uintptr(0)) {
		return 1
	}
	(*(*func(*crt.TLS, uintptr, Tcl_Var, uintptr))(unsafe.Pointer((tclIntStubsPtr + 1024 /* &.tcl_GetVariableFullName */))))(tls, interp, variable, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp))
	return 0
}

//----------------------------------------------------------------------
//
// GetTimesObjCmd --
//
//	This procedure implements the "gettimes" command.  It is used for
//	computing the time needed for various basic operations such as reading
//	variables, allocating memory, sprintf, converting variables, etc.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Allocates and frees memory, sets a variable "a" in the interpreter.
//
//----------------------------------------------------------------------

func GetTimesObjCmd(tls *crt.TLS, unused ClientData, interp uintptr, notused1 int32, notused2 uintptr) int32 { /* tclTest.c:4771:1: */
	bp := tls.Alloc(164)
	defer tls.Free(164)

	var iPtr uintptr = interp
	var i int32
	// var n int32 at bp+136, 4

	var timePer float64
	// var start Tcl_Time at bp+104, 16

	// var stop Tcl_Time at bp+120, 16

	var objPtr uintptr
	var objv uintptr
	var s uintptr
	// var newString [24]int8 at bp+140, 24

	// alloc & free 100000 times
	crt.Xfprintf(tls, crt.Xstderr, ts+5162 /* "alloc & free 100..." */, 0)
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 3872 /* &.tcl_GetTime */))))(tls, bp+104 /* &start */)
	for i = 0; i < 100000; i++ {
		objPtr = ((*(*func(*crt.TLS, uint32) uintptr)(unsafe.Pointer((tclStubsPtr + 40 /* &.tcl_Alloc */))))(tls, (uint32(48))))
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, (objPtr))
	}
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 3872 /* &.tcl_GetTime */))))(tls, bp+120 /* &stop */)
	timePer = (float64((((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).sec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).sec) * int64(1000000)) + ((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).usec)))
	crt.Xfprintf(tls, crt.Xstderr, ts+5196 /* "   %.3f usec per..." */, crt.VaList(bp, (timePer/float64(100000))))

	// alloc 5000 times
	crt.Xfprintf(tls, crt.Xstderr, ts+5225 /* "alloc 5000 6 wor..." */, 0)
	objv = ((*(*func(*crt.TLS, uint32) uintptr)(unsafe.Pointer((tclStubsPtr + 40 /* &.tcl_Alloc */))))(tls, (uint32(uint64(5000) * 8))))
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 3872 /* &.tcl_GetTime */))))(tls, bp+104 /* &start */)
	for i = 0; i < 5000; i++ {
		*(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)) = ((*(*func(*crt.TLS, uint32) uintptr)(unsafe.Pointer((tclStubsPtr + 40 /* &.tcl_Alloc */))))(tls, (uint32(48))))
	}
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 3872 /* &.tcl_GetTime */))))(tls, bp+120 /* &stop */)
	timePer = (float64((((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).sec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).sec) * int64(1000000)) + ((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).usec)))
	crt.Xfprintf(tls, crt.Xstderr, ts+5250 /* "   %.3f usec per..." */, crt.VaList(bp+8, (timePer/float64(5000))))

	// free 5000 times
	crt.Xfprintf(tls, crt.Xstderr, ts+5274 /* "free 5000 6 word..." */, 0)
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 3872 /* &.tcl_GetTime */))))(tls, bp+104 /* &start */)
	for i = 0; i < 5000; i++ {
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, (*(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8))))
	}
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 3872 /* &.tcl_GetTime */))))(tls, bp+120 /* &stop */)
	timePer = (float64((((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).sec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).sec) * int64(1000000)) + ((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).usec)))
	crt.Xfprintf(tls, crt.Xstderr, ts+5298 /* "   %.3f usec per..." */, crt.VaList(bp+16, (timePer/float64(5000))))

	// Tcl_NewObj 5000 times
	crt.Xfprintf(tls, crt.Xstderr, ts+5321 /* "Tcl_NewObj 5000 ..." */, 0)
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 3872 /* &.tcl_GetTime */))))(tls, bp+104 /* &start */)
	for i = 0; i < 5000; i++ {
		*(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)) = (*(*func(*crt.TLS) uintptr)(unsafe.Pointer((tclStubsPtr + 456 /* &.tcl_NewObj */))))(tls)
	}
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 3872 /* &.tcl_GetTime */))))(tls, bp+120 /* &stop */)
	timePer = (float64((((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).sec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).sec) * int64(1000000)) + ((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).usec)))
	crt.Xfprintf(tls, crt.Xstderr, ts+5344 /* "   %.3f usec per..." */, crt.VaList(bp+24, (timePer/float64(5000))))

	// Tcl_DecrRefCount 5000 times
	crt.Xfprintf(tls, crt.Xstderr, ts+5373 /* "Tcl_DecrRefCount..." */, 0)
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 3872 /* &.tcl_GetTime */))))(tls, bp+104 /* &start */)
	for i = 0; i < 5000; i++ {
		objPtr = *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8))
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (objPtr)
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
			}
		}
	}
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 3872 /* &.tcl_GetTime */))))(tls, bp+120 /* &stop */)
	timePer = (float64((((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).sec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).sec) * int64(1000000)) + ((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).usec)))
	crt.Xfprintf(tls, crt.Xstderr, ts+5402 /* "   %.3f usec per..." */, crt.VaList(bp+32, (timePer/float64(5000))))
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, (objv))

	// TclGetString 100000 times
	crt.Xfprintf(tls, crt.Xstderr, ts+5437 /* "TclGetStringFrom..." */, 0)
	objPtr = (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, ts+5482 /* "12345" */, -1)
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 3872 /* &.tcl_GetTime */))))(tls, bp+104 /* &start */)
	for i = 0; i < 100000; i++ {
		if !((*Tcl_Obj)(unsafe.Pointer((objPtr))).bytes != 0) {
			(*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, (objPtr))
		}
	}
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 3872 /* &.tcl_GetTime */))))(tls, bp+120 /* &stop */)
	timePer = (float64((((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).sec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).sec) * int64(1000000)) + ((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).usec)))
	crt.Xfprintf(tls, crt.Xstderr, ts+5488, /* "   %.3f usec per..." */
		crt.VaList(bp+40, (timePer/float64(100000))))

	// Tcl_GetIntFromObj 100000 times
	crt.Xfprintf(tls, crt.Xstderr, ts+5537 /* "Tcl_GetIntFromOb..." */, 0)
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 3872 /* &.tcl_GetTime */))))(tls, bp+104 /* &start */)
	for i = 0; i < 100000; i++ {
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 320 /* &.tcl_GetIntFromObj */))))(tls, interp, objPtr, bp+136 /* &n */) != 0 {
			return 1
		}
	}
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 3872 /* &.tcl_GetTime */))))(tls, bp+120 /* &stop */)
	timePer = (float64((((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).sec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).sec) * int64(1000000)) + ((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).usec)))
	crt.Xfprintf(tls, crt.Xstderr, ts+5580, /* "   %.3f usec per..." */
		crt.VaList(bp+48, (timePer/float64(100000))))
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = (objPtr)
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
		}
	}

	// Tcl_GetInt 100000 times
	crt.Xfprintf(tls, crt.Xstderr, ts+5627 /* "Tcl_GetInt of \"1..." */, 0)
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 3872 /* &.tcl_GetTime */))))(tls, bp+104 /* &start */)
	for i = 0; i < 100000; i++ {
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, ts+5482 /* "12345" */, bp+136 /* &n */) != 0 {
			return 1
		}
	}
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 3872 /* &.tcl_GetTime */))))(tls, bp+120 /* &stop */)
	timePer = (float64((((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).sec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).sec) * int64(1000000)) + ((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).usec)))
	crt.Xfprintf(tls, crt.Xstderr, ts+5663, /* "   %.3f usec per..." */
		crt.VaList(bp+56, (timePer/float64(100000))))

	// sprintf 100000 times
	crt.Xfprintf(tls, crt.Xstderr, ts+5703 /* "sprintf of 12345..." */, 0)
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 3872 /* &.tcl_GetTime */))))(tls, bp+104 /* &start */)
	for i = 0; i < 100000; i++ {
		crt.Xsprintf(tls, bp+140 /* &newString */, ts+5734 /* "%d" */, crt.VaList(bp+64, 12345))
	}
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 3872 /* &.tcl_GetTime */))))(tls, bp+120 /* &stop */)
	timePer = (float64((((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).sec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).sec) * int64(1000000)) + ((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).usec)))
	crt.Xfprintf(tls, crt.Xstderr, ts+5737, /* "   %.3f usec per..." */
		crt.VaList(bp+72, (timePer/float64(100000))))

	// hashtable lookup 100000 times
	crt.Xfprintf(tls, crt.Xstderr, ts+5772 /* "hashtable lookup..." */, 0)
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 3872 /* &.tcl_GetTime */))))(tls, bp+104 /* &start */)
	for i = 0; i < 100000; i++ {
		(*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((((*Interp)(unsafe.Pointer(iPtr)).globalNsPtr + 160 /* &.cmdTable */) + 64 /* &.findProc */))))(tls, ((*Interp)(unsafe.Pointer(iPtr)).globalNsPtr + 160 /* &.cmdTable */), (ts + 273 /* "gettimes" */))
	}
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 3872 /* &.tcl_GetTime */))))(tls, bp+120 /* &stop */)
	timePer = (float64((((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).sec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).sec) * int64(1000000)) + ((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).usec)))
	crt.Xfprintf(tls, crt.Xstderr, ts+5817, /* "   %.3f usec per..." */
		crt.VaList(bp+80, (timePer/float64(100000))))

	// Tcl_SetVar 100000 times
	crt.Xfprintf(tls, crt.Xstderr, ts+5866 /* "Tcl_SetVar of \"1..." */, 0)
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 3872 /* &.tcl_GetTime */))))(tls, bp+104 /* &start */)
	for i = 0; i < 100000; i++ {
		s = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 1920 /* &.tcl_SetVar2 */))))(tls, interp, ts+5902 /* "a" */, (uintptr(0)), ts+5482 /* "12345" */, 0x200)
		if s == (uintptr(0)) {
			return 1
		}
	}
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 3872 /* &.tcl_GetTime */))))(tls, bp+120 /* &stop */)
	timePer = (float64((((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).sec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).sec) * int64(1000000)) + ((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).usec)))
	crt.Xfprintf(tls, crt.Xstderr, ts+5904, /* "   %.3f usec per..." */
		crt.VaList(bp+88, (timePer/float64(100000))))

	// Tcl_GetVar 100000 times
	crt.Xfprintf(tls, crt.Xstderr, ts+5949 /* "Tcl_GetVar of a=..." */, 0)
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 3872 /* &.tcl_GetTime */))))(tls, bp+104 /* &start */)
	for i = 0; i < 100000; i++ {
		s = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 1424 /* &.tcl_GetVar2 */))))(tls, interp, ts+5902 /* "a" */, (uintptr(0)), 0x200)
		if s == (uintptr(0)) {
			return 1
		}
	}
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 3872 /* &.tcl_GetTime */))))(tls, bp+120 /* &stop */)
	timePer = (float64((((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).sec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).sec) * int64(1000000)) + ((*Tcl_Time)(unsafe.Pointer(bp+120 /* &stop */)).usec - (*Tcl_Time)(unsafe.Pointer(bp+104 /* &start */)).usec)))
	crt.Xfprintf(tls, crt.Xstderr, ts+5988, /* "   %.3f usec per..." */
		crt.VaList(bp+96, (timePer/float64(100000))))

	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 1752 /* &.tcl_ResetResult */))))(tls, interp)
	return 0
}

//----------------------------------------------------------------------
//
// NoopCmd --
//
//	This procedure is just used to time the overhead involved in
//	parsing and invoking a command.
//
// Results:
//	None.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func NoopCmd(tls *crt.TLS, unused ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:4950:1: */
	return 0
}

//----------------------------------------------------------------------
//
// NoopObjCmd --
//
//	This object-based procedure is just used to time the overhead
//	involved in parsing and invoking a command.
//
// Results:
//	Returns the TCL_OK result code.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func NoopObjCmd(tls *crt.TLS, unused ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:4977:1: */
	return 0
}

//----------------------------------------------------------------------
//
// TestpurebytesobjObjCmd --
//
//	This object-based procedure constructs a pure bytes object
//	without type and with internal representation containing NULL's.
//
//	If no argument supplied it returns empty object with tclEmptyStringRep,
//	otherwise it returns this as pure bytes object with bytes value equal
//	string.
//
// Results:
//	Returns the TCL_OK result code.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestpurebytesobjObjCmd(tls *crt.TLS, unused ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:5008:1: */
	var objPtr uintptr

	if objc > 2 {
		(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+6031 /* "?string?" */)
		return 1
	}
	objPtr = (*(*func(*crt.TLS) uintptr)(unsafe.Pointer((tclStubsPtr + 456 /* &.tcl_NewObj */))))(tls)
	//
	//    objPtr->internalRep.twoPtrValue.ptr1 = NULL;
	//    objPtr->internalRep.twoPtrValue.ptr2 = NULL;
	//
	crt.Xmemset(tls, (objPtr + 32 /* &.internalRep */), 0, 16)
	if objc == 2 {
		var s uintptr = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
		(*Tcl_Obj)(unsafe.Pointer(objPtr)).length = (*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))).length
		(*Tcl_Obj)(unsafe.Pointer(objPtr)).bytes = ((*(*func(*crt.TLS, uint32) uintptr)(unsafe.Pointer((tclStubsPtr + 40 /* &.tcl_Alloc */))))(tls, (uint32((*Tcl_Obj)(unsafe.Pointer(objPtr)).length + 1))))
		crt.Xmemcpy(tls, (*Tcl_Obj)(unsafe.Pointer(objPtr)).bytes, s, uint64((*Tcl_Obj)(unsafe.Pointer(objPtr)).length))
		*(*int8)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(objPtr)).bytes + uintptr((*Tcl_Obj)(unsafe.Pointer(objPtr)).length))) = int8(0)
	}
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, objPtr)
	return 0
}

//----------------------------------------------------------------------
//
// TestbytestringObjCmd --
//
//	This object-based procedure constructs a string which can
//	possibly contain invalid UTF-8 bytes.
//
// Results:
//	Returns the TCL_OK result code.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestbytestringObjCmd(tls *crt.TLS, unused ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:5055:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var n int32 at bp, 4

	var p uintptr

	if objc != 2 {
		(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+6040 /* "bytearray" */)
		return 1
	}
	p = (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 280 /* &.tcl_GetByteArrayFromObj */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &n */)
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, p, *(*int32)(unsafe.Pointer(bp /* n */))))
	return 0
}

//----------------------------------------------------------------------
//
// TestsetCmd --
//
//	Implements the "testset{err,noerr}" cmds that are used when testing
//	Tcl_Set/GetVar C Api with/without TCL_LEAVE_ERR_MSG flag
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//     Variables may be set.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestsetCmd(tls *crt.TLS, data ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:5092:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var flags int32 = (int32((data)))
	var value uintptr

	if argc == 2 {
		(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, ts+6050 /* "before get" */, (uintptr(0)))
		value = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 1424 /* &.tcl_GetVar2 */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), (uintptr(0)), flags)
		if value == (uintptr(0)) {
			return 1
		}
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, value)
		return 0
	} else if argc == 3 {
		(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, ts+6061 /* "before set" */, (uintptr(0)))
		value = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 1920 /* &.tcl_SetVar2 */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), (uintptr(0)), *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), flags)
		if value == (uintptr(0)) {
			return 1
		}
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, value)
		return 0
	} else {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+1483, /* "wrong # args: sh..." */
			*(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)), ts+6072 /* " varName ?newVal..." */, (uintptr(0))))
		return 1
	}
	return int32(0)
}
func Testset2Cmd(tls *crt.TLS, data ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:5124:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var flags int32 = (int32((data)))
	var value uintptr

	if argc == 3 {
		(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, ts+6050 /* "before get" */, (uintptr(0)))
		value = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 1424 /* &.tcl_GetVar2 */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), flags)
		if value == (uintptr(0)) {
			return 1
		}
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, value)
		return 0
	} else if argc == 4 {
		(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, ts+6061 /* "before set" */, (uintptr(0)))
		value = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 1920 /* &.tcl_SetVar2 */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), flags)
		if value == (uintptr(0)) {
			return 1
		}
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, value)
		return 0
	} else {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+1483, /* "wrong # args: sh..." */
			*(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)), ts+6093 /* " varName elemNam..." */, (uintptr(0))))
		return 1
	}
	return int32(0)
}

//----------------------------------------------------------------------
//
// TestsaveresultCmd --
//
//	Implements the "testsaveresult" cmd that is used when testing the
//	Tcl_SaveResult, Tcl_RestoreResult, and Tcl_DiscardResult interfaces.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestsaveresultCmd(tls *crt.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:5175:1: */
	bp := tls.Alloc(272)
	defer tls.Free(272)

	var iPtr uintptr = interp
	// var discard int32 at bp+20, 4

	var result int32
	// var index int32 at bp+16, 4

	// var state Tcl_SavedResult at bp+24, 248

	var objPtr uintptr
	const ( /* tclTest.c:5188:5: */
		RESULT_APPEND  = 0
		RESULT_DYNAMIC = 1
		RESULT_FREE    = 2
		RESULT_OBJECT  = 3
		RESULT_SMALL   = 4
	)

	// Parse arguments

	if objc != 4 {
		(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+6123 /* "type script disc..." */)
		return 1
	}
	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 2448 /* &.tcl_GetIndexFromObjStruct */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), uintptr(unsafe.Pointer(&optionStrings2)), int32(8), ts+3361 /* "option" */, 0, bp+16 /* &index */) != 0 {
		return 1
	}
	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 272 /* &.tcl_GetBooleanFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+20 /* &discard */) != 0 {
		return 1
	}

	objPtr = (uintptr(0)) // Lint.
	switch uint32(*(*int32)(unsafe.Pointer(bp + 16 /* index */))) {
	case RESULT_SMALL:
		(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, ts+6143 /* "small result" */, (uintptr(1)))
		break
	case RESULT_APPEND:
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+6156 /* "append result" */, (uintptr(0))))
		break
	case RESULT_FREE:
		{
			var buf uintptr = ((*(*func(*crt.TLS, uint32) uintptr)(unsafe.Pointer((tclStubsPtr + 40 /* &.tcl_Alloc */))))(tls, (uint32(200))))

			crt.Xstrcpy(tls, buf, ts+6170 /* "free result" */)
			(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, buf, (uintptr(3)))
			break
		}
	case RESULT_DYNAMIC:
		(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, ts+6182 /* "dynamic result" */, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{TestsaveresultFree})))
		break
	case RESULT_OBJECT:
		objPtr = (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, ts+6197 /* "object result" */, -1)
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, objPtr)
		break
	}

	freeCount = 0
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2536 /* &.tcl_SaveResult */))))(tls, interp, bp+24 /* &state */)

	if (int32(uint32(*(*int32)(unsafe.Pointer(bp + 16 /* index */))))) == RESULT_OBJECT {
		result = (*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer((tclStubsPtr + 2360 /* &.tcl_EvalObjEx */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), 0)
	} else {
		result = (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 1048 /* &.tcl_Eval */))))(tls, interp, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))))
	}

	if *(*int32)(unsafe.Pointer(bp + 20 /* discard */)) != 0 {
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 2336 /* &.tcl_DiscardResult */))))(tls, bp+24 /* &state */)
	} else {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2528 /* &.tcl_RestoreResult */))))(tls, interp, bp+24 /* &state */)
		result = 0
	}

	switch uint32(*(*int32)(unsafe.Pointer(bp + 16 /* index */))) {
	case RESULT_DYNAMIC:
		{
			var present int32 = (crt.Bool32((*Interp)(unsafe.Pointer(iPtr)).freeProc == *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{TestsaveresultFree}))))
			var called int32 = freeCount

			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, func() uintptr {
				if called != 0 {
					return ts + 6211 /* "called" */
				}
				return ts + 6218 /* "notCalled" */
			}())
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, func() uintptr {
				if present != 0 {
					return ts + 6228 /* "present" */
				}
				return ts + 6236 /* "missing" */
			}())
			break
		}
	case RESULT_OBJECT:
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, func() uintptr {
			if (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp) == objPtr {
				return ts + 6244 /* "same" */
			}
			return ts + 6249 /* "different" */
		}())
		break
	default:
		break
	}
	return result
}

var optionStrings2 = [6]uintptr{
	ts + 2519 /* "append" */, ts + 6259 /* "dynamic" */, ts + 2538 /* "free" */, ts + 6267 /* "object" */, ts + 6274 /* "small" */, (uintptr(0)),
} /* tclTest.c:5185:23 */

//----------------------------------------------------------------------
//
// TestsaveresultFree --
//
//	Special purpose freeProc used by TestsaveresultCmd.
//
// Results:
//	None.
//
// Side effects:
//	Increments the freeCount.
//
//----------------------------------------------------------------------

func TestsaveresultFree(tls *crt.TLS, blockPtr uintptr) { /* tclTest.c:5284:1: */
	freeCount++
}

//----------------------------------------------------------------------
//
// TestmainthreadCmd  --
//
//	Implements the "testmainthread" cmd that is used to test the
//	'Tcl_GetCurrentThread' API.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestmainthreadCmd(tls *crt.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:5308:1: */
	if argc == 1 {
		var idObj uintptr = (*(*func(*crt.TLS, Tcl_WideInt) uintptr)(unsafe.Pointer((tclStubsPtr + 3920 /* &.tcl_NewWideIntObj */))))(tls, Tcl_WideInt((*(*func(*crt.TLS) Tcl_ThreadId)(unsafe.Pointer((tclStubsPtr + 2416 /* &.tcl_GetCurrentThread */))))(tls)))

		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, idObj)
		return 0
	} else {
		(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, ts+1397 /* "wrong # args" */, (uintptr(0)))
		return 1
	}
	return int32(0)
}

//----------------------------------------------------------------------
//
// MainLoop --
//
//	A main loop set by TestsetmainloopCmd below.
//
// Results:
//	None.
//
// Side effects:
//	Event handlers could do anything.
//
//----------------------------------------------------------------------

func MainLoop(tls *crt.TLS) { /* tclTest.c:5342:1: */
	for !(exitMainLoop != 0) {
		(*(*func(*crt.TLS, int32) int32)(unsafe.Pointer((tclStubsPtr + 936 /* &.tcl_DoOneEvent */))))(tls, 0)
	}
	crt.Xfprintf(tls, crt.Xstdout, ts+6280 /* "Exit MainLoop\n" */, 0)
	crt.Xfflush(tls, crt.Xstdout)
}

//----------------------------------------------------------------------
//
// TestsetmainloopCmd  --
//
//	Implements the "testsetmainloop" cmd that is used to test the
//	'Tcl_SetMainLoop' API.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestsetmainloopCmd(tls *crt.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:5369:1: */
	exitMainLoop = 0
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 2288 /* &.tcl_SetMainLoop */))))(tls, *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS) }{MainLoop})))
	return 0
}

//----------------------------------------------------------------------
//
// TestexitmainloopCmd  --
//
//	Implements the "testexitmainloop" cmd that is used to test the
//	'Tcl_SetMainLoop' API.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestexitmainloopCmd(tls *crt.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:5398:1: */
	exitMainLoop = 1
	return 0
}

//----------------------------------------------------------------------
//
// TestChannelCmd --
//
//	Implements the Tcl "testchannel" debugging command and its
//	subcommands. This is part of the testing environment.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestChannelCmd(tls *crt.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:5427:1: */
	bp := tls.Alloc(632)
	defer tls.Free(632)

	var cmdName uintptr // Sub command.
	var hTblPtr uintptr // Hash table of channels.
	// var hSearch Tcl_HashSearch at bp+608, 24
	// Search variable.
	var hPtr uintptr      // Search variable.
	var chanPtr uintptr   // The actual channel.
	var statePtr uintptr  // state info for channel
	var chan1 Tcl_Channel // The opaque type.
	var len size_t        // Length of subcommand string.
	var IOQueued int32    // How much IO is queued inside channel?
	// var buf [24]int8 at bp+584, 24
	// For sprintf.
	// var mode int32 at bp+560, 4
	// rw mode of the channel

	if argc < 2 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+1483 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+6295 /* " subcommand ?add..." */, (uintptr(0))))
		return 1
	}
	cmdName = *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8))
	len = crt.Xstrlen(tls, cmdName)

	chanPtr = (uintptr(0))

	if argc > 2 {
		if (int32(*(*int8)(unsafe.Pointer(cmdName + uintptr(0)))) == 's') && (crt.Xstrncmp(tls, cmdName, ts+6328 /* "splice" */, len) == 0) {
			// For splice access the pool of detached channels.
			// Locate channel, remove from the list.

			var nextPtrPtr uintptr
			var curPtr uintptr

			chan1 = (uintptr(0))
			nextPtrPtr = uintptr(unsafe.Pointer(&firstDetached))
			curPtr = firstDetached
		__1:
			if !(curPtr != (uintptr(0))) {
				goto __3
			}
			{

				if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), (*(*func(*crt.TLS, Tcl_Channel) uintptr)(unsafe.Pointer((tclStubsPtr + 1264 /* &.tcl_GetChannelName */))))(tls, (*TestChannel)(unsafe.Pointer(curPtr)).__chan)) == 0 {
					*(*uintptr)(unsafe.Pointer(nextPtrPtr)) = (*TestChannel)(unsafe.Pointer(curPtr)).nextPtr
					(*TestChannel)(unsafe.Pointer(curPtr)).nextPtr = (uintptr(0))
					chan1 = (*TestChannel)(unsafe.Pointer(curPtr)).__chan
					(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, (curPtr))
					goto __3
				}
			}
			goto __2
		__2:
			nextPtrPtr = (curPtr + 8 /* &.nextPtr */)
			curPtr = (*TestChannel)(unsafe.Pointer(curPtr)).nextPtr
			goto __1
			goto __3
		__3:
		} else {
			chan1 = (*(*func(*crt.TLS, uintptr, uintptr, uintptr) Tcl_Channel)(unsafe.Pointer((tclStubsPtr + 1224 /* &.tcl_GetChannel */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), bp+560 /* &mode */)
		}
		if chan1 == (uintptr(0)) {
			return 1
		}
		chanPtr = chan1
		statePtr = (*Channel)(unsafe.Pointer(chanPtr)).state
		chanPtr = (*ChannelState)(unsafe.Pointer(statePtr)).topChanPtr
		chan1 = chanPtr
	} else {
		// lint
		statePtr = (uintptr(0))
		chan1 = (uintptr(0))
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName + uintptr(0)))) == 's') && (crt.Xstrncmp(tls, cmdName, ts+6335 /* "setchannelerror" */, len) == 0) {

		*(*uintptr)(unsafe.Pointer(bp + 568 /* msg */)) = (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), -1)

		(*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(bp + 568 /* msg */))))).refCount++
		(*(*func(*crt.TLS, Tcl_Channel, uintptr))(unsafe.Pointer((tclStubsPtr + 4528 /* &.tcl_SetChannelError */))))(tls, chan1, *(*uintptr)(unsafe.Pointer(bp + 568 /* msg */)))
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*(*uintptr)(unsafe.Pointer(bp + 568 /* msg */)))
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
			}
		}

		(*(*func(*crt.TLS, Tcl_Channel, uintptr))(unsafe.Pointer((tclStubsPtr + 4536 /* &.tcl_GetChannelError */))))(tls, chan1, bp+568 /* &msg */)
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 568 /* msg */)))
		for ok1 := true; ok1; ok1 = 0 != 0 {
			var _objPtr uintptr = (*(*uintptr)(unsafe.Pointer(bp + 568 /* msg */)))
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
			}
		}
		return 0
	}
	if (int32(*(*int8)(unsafe.Pointer(cmdName + uintptr(0)))) == 's') && (crt.Xstrncmp(tls, cmdName, ts+6351 /* "setchannelerrori..." */, len) == 0) {

		*(*uintptr)(unsafe.Pointer(bp + 576 /* msg */)) = (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), -1)

		(*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(bp + 576 /* msg */))))).refCount++
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 4512 /* &.tcl_SetChannelErrorInterp */))))(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 576 /* msg */)))
		for ok2 := true; ok2; ok2 = 0 != 0 {
			var _objPtr uintptr = (*(*uintptr)(unsafe.Pointer(bp + 576 /* msg */)))
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
			}
		}

		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 4520 /* &.tcl_GetChannelErrorInterp */))))(tls, interp, bp+576 /* &msg */)
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 576 /* msg */)))
		for ok3 := true; ok3; ok3 = 0 != 0 {
			var _objPtr uintptr = (*(*uintptr)(unsafe.Pointer(bp + 576 /* msg */)))
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
			}
		}
		return 0
	}

	// "cut" is actually more a simplified detach facility as provided by the
	// Thread package. Without the safeguards of a regular command (no
	// checking that the command is truly cut'able, no mutexes for
	// thread-safety). Its complementary command is "splice", see below.

	if (int32(*(*int8)(unsafe.Pointer(cmdName + uintptr(0)))) == 'c') && (crt.Xstrncmp(tls, cmdName, ts+6373 /* "cut" */, len) == 0) {
		var det uintptr

		if argc != 3 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+32, ts+1483 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
				ts+6377 /* " cut channelName..." */, (uintptr(0))))
			return 1
		}

		(*(*func(*crt.TLS, uintptr, Tcl_Channel))(unsafe.Pointer((tclStubsPtr + 1696 /* &.tcl_RegisterChannel */))))(tls, (uintptr(0)), chan1) // prevent closing
		(*(*func(*crt.TLS, uintptr, Tcl_Channel) int32)(unsafe.Pointer((tclStubsPtr + 2032 /* &.tcl_UnregisterChannel */))))(tls, interp, chan1)

		(*(*func(*crt.TLS, Tcl_Channel))(unsafe.Pointer((tclStubsPtr + 3336 /* &.tcl_CutChannel */))))(tls, chan1)

		// Remember the channel in the pool of detached channels

		det = ((*(*func(*crt.TLS, uint32) uintptr)(unsafe.Pointer((tclStubsPtr + 40 /* &.tcl_Alloc */))))(tls, (uint32(16))))
		(*TestChannel)(unsafe.Pointer(det)).__chan = chan1
		(*TestChannel)(unsafe.Pointer(det)).nextPtr = firstDetached
		firstDetached = det

		return 0
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName + uintptr(0)))) == 'c') && (crt.Xstrncmp(tls, cmdName, ts+6395 /* "clearchannelhand..." */, len) == 0) {
		if argc != 3 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+64, ts+1483 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
				ts+6416 /* " clearchannelhan..." */, (uintptr(0))))
			return 1
		}
		(*(*func(*crt.TLS, Tcl_Channel))(unsafe.Pointer((tclStubsPtr + 3352 /* &.tcl_ClearChannelHandlers */))))(tls, chan1)
		return 0
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName + uintptr(0)))) == 'i') && (crt.Xstrncmp(tls, cmdName, ts+6451 /* "info" */, len) == 0) {
		if argc != 3 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+96, ts+1483 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
				ts+6456 /* " info channelNam..." */, (uintptr(0))))
			return 1
		}
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)))
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 3200 /* &.tcl_ChannelName */))))(tls, (*Channel)(unsafe.Pointer(chanPtr)).typePtr))
		if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 1)) != 0 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+6475 /* "read" */)
		} else {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+1482 /* "" */)
		}
		if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 2)) != 0 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+6480 /* "write" */)
		} else {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+1482 /* "" */)
		}
		if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 3)) != 0 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+6486 /* "nonblocking" */)
		} else {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+6498 /* "blocking" */)
		}
		if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 4)) != 0 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+6507 /* "line" */)
		} else if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 5)) != 0 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+6512 /* "none" */)
		} else {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+6517 /* "full" */)
		}
		if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 7)) != 0 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+6522 /* "async_flush" */)
		} else {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+1482 /* "" */)
		}
		if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 9)) != 0 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+6534 /* "eof" */)
		} else {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+1482 /* "" */)
		}
		if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 11)) != 0 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+6538 /* "blocked" */)
		} else {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+6546 /* "unblocked" */)
		}
		if (*ChannelState)(unsafe.Pointer(statePtr)).inputTranslation == TclEolTranslation(0) {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+6556 /* "auto" */)
			if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 12)) != 0 {
				(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+6561 /* "saw_cr" */)
			} else {
				(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+1482 /* "" */)
			}
		} else if (*ChannelState)(unsafe.Pointer(statePtr)).inputTranslation == TclEolTranslation(2) {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+6568 /* "lf" */)
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+1482 /* "" */)
		} else if (*ChannelState)(unsafe.Pointer(statePtr)).inputTranslation == TclEolTranslation(1) {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+6571 /* "cr" */)
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+1482 /* "" */)
		} else if (*ChannelState)(unsafe.Pointer(statePtr)).inputTranslation == TclEolTranslation(3) {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+6574 /* "crlf" */)
			if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 12)) != 0 {
				(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+6579 /* "queued_cr" */)
			} else {
				(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+1482 /* "" */)
			}
		}
		if (*ChannelState)(unsafe.Pointer(statePtr)).outputTranslation == TclEolTranslation(0) {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+6556 /* "auto" */)
		} else if (*ChannelState)(unsafe.Pointer(statePtr)).outputTranslation == TclEolTranslation(2) {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+6568 /* "lf" */)
		} else if (*ChannelState)(unsafe.Pointer(statePtr)).outputTranslation == TclEolTranslation(1) {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+6571 /* "cr" */)
		} else if (*ChannelState)(unsafe.Pointer(statePtr)).outputTranslation == TclEolTranslation(3) {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+6574 /* "crlf" */)
		}
		IOQueued = (*(*func(*crt.TLS, Tcl_Channel) int32)(unsafe.Pointer((tclStubsPtr + 1480 /* &.tcl_InputBuffered */))))(tls, chan1)
		(*(*func(*crt.TLS, uintptr, int64) int32)(unsafe.Pointer((tclIntStubsPtr + 208 /* &.tclFormatInt */))))(tls, bp+584 /* &buf */, int64(IOQueued))
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, bp+584 /* &buf */)

		IOQueued = (*(*func(*crt.TLS, Tcl_Channel) int32)(unsafe.Pointer((tclStubsPtr + 3848 /* &.tcl_OutputBuffered */))))(tls, chan1)
		(*(*func(*crt.TLS, uintptr, int64) int32)(unsafe.Pointer((tclIntStubsPtr + 208 /* &.tclFormatInt */))))(tls, bp+584 /* &buf */, int64(IOQueued))
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, bp+584 /* &buf */)

		(*(*func(*crt.TLS, uintptr, int64) int32)(unsafe.Pointer((tclIntStubsPtr + 208 /* &.tclFormatInt */))))(tls, bp+584 /* &buf */, int64(int32((*(*func(*crt.TLS, Tcl_Channel) Tcl_WideInt)(unsafe.Pointer((tclStubsPtr + 3952 /* &.tcl_Tell */))))(tls, chan1))))
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, bp+584 /* &buf */)

		(*(*func(*crt.TLS, uintptr, int64) int32)(unsafe.Pointer((tclIntStubsPtr + 208 /* &.tclFormatInt */))))(tls, bp+584 /* &buf */, int64((*ChannelState)(unsafe.Pointer(statePtr)).refCount))
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, bp+584 /* &buf */)

		return 0
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName + uintptr(0)))) == 'i') && (crt.Xstrncmp(tls, cmdName, ts+6589 /* "inputbuffered" */, len) == 0) {
		if argc != 3 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+128, ts+6603 /* "channel name req..." */, (uintptr(0))))
			return 1
		}
		IOQueued = (*(*func(*crt.TLS, Tcl_Channel) int32)(unsafe.Pointer((tclStubsPtr + 1480 /* &.tcl_InputBuffered */))))(tls, chan1)
		(*(*func(*crt.TLS, uintptr, int64) int32)(unsafe.Pointer((tclIntStubsPtr + 208 /* &.tclFormatInt */))))(tls, bp+584 /* &buf */, int64(IOQueued))
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+144, bp+584 /* &buf */, (uintptr(0))))
		return 0
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName + uintptr(0)))) == 'i') && (crt.Xstrncmp(tls, cmdName, ts+6625 /* "isshared" */, len) == 0) {
		if argc != 3 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+160, ts+6603 /* "channel name req..." */, (uintptr(0))))
			return 1
		}

		(*(*func(*crt.TLS, uintptr, int64) int32)(unsafe.Pointer((tclIntStubsPtr + 208 /* &.tclFormatInt */))))(tls, bp+584 /* &buf */, int64((*(*func(*crt.TLS, Tcl_Channel) int32)(unsafe.Pointer((tclStubsPtr + 3320 /* &.tcl_IsChannelShared */))))(tls, chan1)))
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+176, bp+584 /* &buf */, (uintptr(0))))
		return 0
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName + uintptr(0)))) == 'i') && (crt.Xstrncmp(tls, cmdName, ts+6634 /* "isstandard" */, len) == 0) {
		if argc != 3 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+192, ts+6603 /* "channel name req..." */, (uintptr(0))))
			return 1
		}

		(*(*func(*crt.TLS, uintptr, int64) int32)(unsafe.Pointer((tclIntStubsPtr + 208 /* &.tclFormatInt */))))(tls, bp+584 /* &buf */, int64((*(*func(*crt.TLS, Tcl_Channel) int32)(unsafe.Pointer((tclStubsPtr + 3528 /* &.tcl_IsStandardChannel */))))(tls, chan1)))
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+208, bp+584 /* &buf */, (uintptr(0))))
		return 0
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName + uintptr(0)))) == 'm') && (crt.Xstrncmp(tls, cmdName, ts+6645 /* "mode" */, len) == 0) {
		if argc != 3 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+224, ts+6603 /* "channel name req..." */, (uintptr(0))))
			return 1
		}

		if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 1)) != 0 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+6475 /* "read" */)
		} else {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+1482 /* "" */)
		}
		if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 2)) != 0 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+6480 /* "write" */)
		} else {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+1482 /* "" */)
		}
		return 0
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName + uintptr(0)))) == 'm') && (crt.Xstrncmp(tls, cmdName, ts+6650 /* "mthread" */, len) == 0) {
		if argc != 3 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+240, ts+6603 /* "channel name req..." */, (uintptr(0))))
			return 1
		}

		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, Tcl_WideInt) uintptr)(unsafe.Pointer((tclStubsPtr + 3920 /* &.tcl_NewWideIntObj */))))(tls,
			Tcl_WideInt((*(*func(*crt.TLS, Tcl_Channel) Tcl_ThreadId)(unsafe.Pointer((tclStubsPtr + 3480 /* &.tcl_GetChannelThread */))))(tls, chan1))))
		return 0
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName + uintptr(0)))) == 'n') && (crt.Xstrncmp(tls, cmdName, ts+1779 /* "name" */, len) == 0) {
		if argc != 3 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+256, ts+6603 /* "channel name req..." */, (uintptr(0))))
			return 1
		}
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+272, (*ChannelState)(unsafe.Pointer(statePtr)).channelName, (uintptr(0))))
		return 0
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName + uintptr(0)))) == 'o') && (crt.Xstrncmp(tls, cmdName, ts+6658 /* "open" */, len) == 0) {
		hTblPtr = (*(*func(*crt.TLS, uintptr, uintptr, uintptr) ClientData)(unsafe.Pointer((tclStubsPtr + 1216 /* &.tcl_GetAssocData */))))(tls, interp, ts+6663 /* "tclIO" */, (uintptr(0)))
		if hTblPtr == (uintptr(0)) {
			return 0
		}
		for hPtr = (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1176 /* &.tcl_FirstHashEntry */))))(tls, hTblPtr, bp+608 /* &hSearch */); hPtr != (uintptr(0)); hPtr = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1560 /* &.tcl_NextHashEntry */))))(tls, bp+608 /* &hSearch */) {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, (func() uintptr {
				if ((*Tcl_HashTable)(unsafe.Pointer((hTblPtr))).keyType == (1)) || ((*Tcl_HashTable)(unsafe.Pointer((hTblPtr))).keyType == (-1)) {
					return *(*uintptr)(unsafe.Pointer((hPtr) + 32 /* &.key */))
				}
				return (hPtr) + 32 /* &.key */
			}()))
		}
		return 0
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName + uintptr(0)))) == 'o') && (crt.Xstrncmp(tls, cmdName, ts+6669 /* "outputbuffered" */, len) == 0) {
		if argc != 3 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+288, ts+6603 /* "channel name req..." */, (uintptr(0))))
			return 1
		}

		IOQueued = (*(*func(*crt.TLS, Tcl_Channel) int32)(unsafe.Pointer((tclStubsPtr + 3848 /* &.tcl_OutputBuffered */))))(tls, chan1)
		(*(*func(*crt.TLS, uintptr, int64) int32)(unsafe.Pointer((tclIntStubsPtr + 208 /* &.tclFormatInt */))))(tls, bp+584 /* &buf */, int64(IOQueued))
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+304, bp+584 /* &buf */, (uintptr(0))))
		return 0
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName + uintptr(0)))) == 'q') && (crt.Xstrncmp(tls, cmdName, ts+6684 /* "queuedcr" */, len) == 0) {
		if argc != 3 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+320, ts+6603 /* "channel name req..." */, (uintptr(0))))
			return 1
		}

		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp,
			crt.VaList(bp+336, func() uintptr {
				if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 12)) != 0 {
					return ts + 6693 /* "1" */
				}
				return ts + 6695 /* "0" */
			}(), (uintptr(0))))
		return 0
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName + uintptr(0)))) == 'r') && (crt.Xstrncmp(tls, cmdName, ts+6697 /* "readable" */, len) == 0) {
		hTblPtr = (*(*func(*crt.TLS, uintptr, uintptr, uintptr) ClientData)(unsafe.Pointer((tclStubsPtr + 1216 /* &.tcl_GetAssocData */))))(tls, interp, ts+6663 /* "tclIO" */, (uintptr(0)))
		if hTblPtr == (uintptr(0)) {
			return 0
		}
		for hPtr = (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1176 /* &.tcl_FirstHashEntry */))))(tls, hTblPtr, bp+608 /* &hSearch */); hPtr != (uintptr(0)); hPtr = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1560 /* &.tcl_NextHashEntry */))))(tls, bp+608 /* &hSearch */) {
			chanPtr = ((*Tcl_HashEntry)(unsafe.Pointer((hPtr))).clientData)
			statePtr = (*Channel)(unsafe.Pointer(chanPtr)).state
			if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 1)) != 0 {
				(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, (func() uintptr {
					if ((*Tcl_HashTable)(unsafe.Pointer((hTblPtr))).keyType == (1)) || ((*Tcl_HashTable)(unsafe.Pointer((hTblPtr))).keyType == (-1)) {
						return *(*uintptr)(unsafe.Pointer((hPtr) + 32 /* &.key */))
					}
					return (hPtr) + 32 /* &.key */
				}()))
			}
		}
		return 0
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName + uintptr(0)))) == 'r') && (crt.Xstrncmp(tls, cmdName, ts+6706 /* "refcount" */, len) == 0) {
		if argc != 3 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+352, ts+6603 /* "channel name req..." */, (uintptr(0))))
			return 1
		}

		(*(*func(*crt.TLS, uintptr, int64) int32)(unsafe.Pointer((tclIntStubsPtr + 208 /* &.tclFormatInt */))))(tls, bp+584 /* &buf */, int64((*ChannelState)(unsafe.Pointer(statePtr)).refCount))
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+368, bp+584 /* &buf */, (uintptr(0))))
		return 0
	}

	// "splice" is actually more a simplified attach facility as provided by
	// the Thread package. Without the safeguards of a regular command (no
	// checking that the command is truly cut'able, no mutexes for
	// thread-safety). Its complementary command is "cut", see above.

	if (int32(*(*int8)(unsafe.Pointer(cmdName + uintptr(0)))) == 's') && (crt.Xstrncmp(tls, cmdName, ts+6328 /* "splice" */, len) == 0) {
		if argc != 3 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+384, ts+6603 /* "channel name req..." */, (uintptr(0))))
			return 1
		}

		(*(*func(*crt.TLS, Tcl_Channel))(unsafe.Pointer((tclStubsPtr + 3344 /* &.tcl_SpliceChannel */))))(tls, chan1)

		(*(*func(*crt.TLS, uintptr, Tcl_Channel))(unsafe.Pointer((tclStubsPtr + 1696 /* &.tcl_RegisterChannel */))))(tls, interp, chan1)
		(*(*func(*crt.TLS, uintptr, Tcl_Channel) int32)(unsafe.Pointer((tclStubsPtr + 2032 /* &.tcl_UnregisterChannel */))))(tls, (uintptr(0)), chan1)

		return 0
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName + uintptr(0)))) == 't') && (crt.Xstrncmp(tls, cmdName, ts+6715 /* "type" */, len) == 0) {
		if argc != 3 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+400, ts+6603 /* "channel name req..." */, (uintptr(0))))
			return 1
		}
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+416, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 3200 /* &.tcl_ChannelName */))))(tls, (*Channel)(unsafe.Pointer(chanPtr)).typePtr), (uintptr(0))))
		return 0
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName + uintptr(0)))) == 'w') && (crt.Xstrncmp(tls, cmdName, ts+6720 /* "writable" */, len) == 0) {
		hTblPtr = (*(*func(*crt.TLS, uintptr, uintptr, uintptr) ClientData)(unsafe.Pointer((tclStubsPtr + 1216 /* &.tcl_GetAssocData */))))(tls, interp, ts+6663 /* "tclIO" */, (uintptr(0)))
		if hTblPtr == (uintptr(0)) {
			return 0
		}
		for hPtr = (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1176 /* &.tcl_FirstHashEntry */))))(tls, hTblPtr, bp+608 /* &hSearch */); hPtr != (uintptr(0)); hPtr = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1560 /* &.tcl_NextHashEntry */))))(tls, bp+608 /* &hSearch */) {
			chanPtr = ((*Tcl_HashEntry)(unsafe.Pointer((hPtr))).clientData)
			statePtr = (*Channel)(unsafe.Pointer(chanPtr)).state
			if ((*ChannelState)(unsafe.Pointer(statePtr)).flags & (int32(1) << 2)) != 0 {
				(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, (func() uintptr {
					if ((*Tcl_HashTable)(unsafe.Pointer((hTblPtr))).keyType == (1)) || ((*Tcl_HashTable)(unsafe.Pointer((hTblPtr))).keyType == (-1)) {
						return *(*uintptr)(unsafe.Pointer((hPtr) + 32 /* &.key */))
					}
					return (hPtr) + 32 /* &.key */
				}()))
			}
		}
		return 0
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName + uintptr(0)))) == 't') && (crt.Xstrncmp(tls, cmdName, ts+6729 /* "transform" */, len) == 0) {
		// Syntax: transform channel -command command

		if argc != 5 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+432, ts+1483 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
				ts+6739 /* " transform chann..." */, (uintptr(0))))
			return 1
		}
		if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), ts+6774 /* "-command" */) != 0 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+464, ts+6783 /* "bad argument \"" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)),
				ts+6798 /* "\": should be \"-c..." */, (uintptr(0))))
			return 1
		}

		return (*(*func(*crt.TLS, uintptr, Tcl_Channel, uintptr) int32)(unsafe.Pointer((tclIntStubsPtr + 1304 /* &.tclChannelTransform */))))(tls, interp, chan1,
			(*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)), -1))
	}

	if (int32(*(*int8)(unsafe.Pointer(cmdName + uintptr(0)))) == 'u') && (crt.Xstrncmp(tls, cmdName, ts+6822 /* "unstack" */, len) == 0) {
		// Syntax: unstack channel

		if argc != 3 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+496, ts+1483 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
				ts+6830 /* " unstack channel..." */, (uintptr(0))))
			return 1
		}
		return (*(*func(*crt.TLS, uintptr, Tcl_Channel) int32)(unsafe.Pointer((tclStubsPtr + 2272 /* &.tcl_UnstackChannel */))))(tls, interp, chan1)
	}

	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+528, ts+1429 /* "bad option \"" */, cmdName,

		ts+6848 /* "\": should be cut..." */, (uintptr(0))))
	return 1
}

//----------------------------------------------------------------------
//
// TestChannelEventCmd --
//
//	This procedure implements the "testchannelevent" command. It is used
//	to test the Tcl channel event mechanism.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Creates, deletes and returns channel event handlers.
//
//----------------------------------------------------------------------

// ARGSUSED
func TestChannelEventCmd(tls *crt.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:5896:1: */
	bp := tls.Alloc(420)
	defer tls.Free(420)

	var resultListPtr uintptr
	var chanPtr uintptr
	var statePtr uintptr // state info for channel
	var esPtr uintptr
	var prevEsPtr uintptr
	var nextEsPtr uintptr
	var cmd uintptr
	// var index int32 at bp+416, 4

	var i int32
	var mask int32
	var len int32

	if (argc < 3) || (argc > 5) {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+1483 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+6963 /* " channelName cmd..." */, (uintptr(0))))
		return 1
	}
	chanPtr = (*(*func(*crt.TLS, uintptr, uintptr, uintptr) Tcl_Channel)(unsafe.Pointer((tclStubsPtr + 1224 /* &.tcl_GetChannel */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), (uintptr(0)))
	if chanPtr == (uintptr(0)) {
		return 1
	}
	statePtr = (*Channel)(unsafe.Pointer(chanPtr)).state

	cmd = *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8))
	len = int32(crt.Xstrlen(tls, cmd))
	if (int32(*(*int8)(unsafe.Pointer(cmd + uintptr(0)))) == 'a') && (crt.Xstrncmp(tls, cmd, ts+6995 /* "add" */, uint64(uint32(len))) == 0) {
		if argc != 5 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+32, ts+1483 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
				ts+6999 /* " channelName add..." */, (uintptr(0))))
			return 1
		}
		if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), ts+6697 /* "readable" */) == 0 {
			mask = (int32(1) << 1)
		} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), ts+6720 /* "writable" */) == 0 {
			mask = (int32(1) << 2)
		} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), ts+6512 /* "none" */) == 0 {
			mask = 0
		} else {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+64, ts+7034 /* "bad event name \"" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)),
				ts+7051 /* "\": must be reada..." */, (uintptr(0))))
			return 1
		}

		esPtr = ((*(*func(*crt.TLS, uint32) uintptr)(unsafe.Pointer((tclStubsPtr + 40 /* &.tcl_Alloc */))))(tls, (uint32(40))))
		(*EventScriptRecord)(unsafe.Pointer(esPtr)).nextPtr = (*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr
		(*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr = esPtr

		(*EventScriptRecord)(unsafe.Pointer(esPtr)).chanPtr = chanPtr
		(*EventScriptRecord)(unsafe.Pointer(esPtr)).interp = interp
		(*EventScriptRecord)(unsafe.Pointer(esPtr)).mask = mask
		(*EventScriptRecord)(unsafe.Pointer(esPtr)).scriptPtr = (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)), -1)
		(*Tcl_Obj)(unsafe.Pointer(((*EventScriptRecord)(unsafe.Pointer(esPtr)).scriptPtr))).refCount++

		(*(*func(*crt.TLS, Tcl_Channel, int32, uintptr, ClientData))(unsafe.Pointer((tclStubsPtr + 728 /* &.tcl_CreateChannelHandler */))))(tls, chanPtr, mask,
			((*TclIntStubs)(unsafe.Pointer(tclIntStubsPtr)).tclChannelEventScriptInvoker), esPtr)

		return 0
	}

	if (int32(*(*int8)(unsafe.Pointer(cmd + uintptr(0)))) == 'd') && (crt.Xstrncmp(tls, cmd, ts+1417 /* "delete" */, uint64(uint32(len))) == 0) {
		if argc != 4 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+96, ts+1483 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
				ts+7090 /* " channelName del..." */, (uintptr(0))))
			return 1
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), bp+416 /* &index */) == 1 {
			return 1
		}
		if *(*int32)(unsafe.Pointer(bp + 416 /* index */)) < 0 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+128, ts+7117 /* "bad event index:..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)),
				ts+7135 /* ": must be nonneg..." */, (uintptr(0))))
			return 1
		}
		i = 0
		esPtr = (*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr
	__1:
		if !((i < *(*int32)(unsafe.Pointer(bp + 416 /* index */))) && (esPtr != (uintptr(0)))) {
			goto __3
		}
		{
			// Empty loop body.
		}
		goto __2
	__2:
		i++
		esPtr = (*EventScriptRecord)(unsafe.Pointer(esPtr)).nextPtr
		goto __1
		goto __3
	__3:
		;
		if esPtr == (uintptr(0)) {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+160, ts+7157 /* "bad event index " */, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)),
				ts+7174 /* ": out of range" */, (uintptr(0))))
			return 1
		}
		if esPtr == (*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr {
			(*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr = (*EventScriptRecord)(unsafe.Pointer(esPtr)).nextPtr
		} else {
			for prevEsPtr = (*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr; (prevEsPtr != (uintptr(0))) && ((*EventScriptRecord)(unsafe.Pointer(prevEsPtr)).nextPtr != esPtr); prevEsPtr = (*EventScriptRecord)(unsafe.Pointer(prevEsPtr)).nextPtr {
			}
			if prevEsPtr == (uintptr(0)) {
				(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 32 /* &.tcl_Panic */))))(tls, ts+7189 /* "TestChannelEvent..." */, 0)
			}
			(*EventScriptRecord)(unsafe.Pointer(prevEsPtr)).nextPtr = (*EventScriptRecord)(unsafe.Pointer(esPtr)).nextPtr
		}
		(*(*func(*crt.TLS, Tcl_Channel, uintptr, ClientData))(unsafe.Pointer((tclStubsPtr + 824 /* &.tcl_DeleteChannelHandler */))))(tls, chanPtr,
			((*TclIntStubs)(unsafe.Pointer(tclIntStubsPtr)).tclChannelEventScriptInvoker), esPtr)
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = ((*EventScriptRecord)(unsafe.Pointer(esPtr)).scriptPtr)
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
			}
		}
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, (esPtr))

		return 0
	}

	if (int32(*(*int8)(unsafe.Pointer(cmd + uintptr(0)))) == 'l') && (crt.Xstrncmp(tls, cmd, ts+7236 /* "list" */, uint64(uint32(len))) == 0) {
		if argc != 3 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+192, ts+1483 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
				ts+7241 /* " channelName lis..." */, (uintptr(0))))
			return 1
		}
		resultListPtr = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp)
		for esPtr = (*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr; esPtr != (uintptr(0)); esPtr = (*EventScriptRecord)(unsafe.Pointer(esPtr)).nextPtr {
			if (*EventScriptRecord)(unsafe.Pointer(esPtr)).mask != 0 {
				(*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 368 /* &.tcl_ListObjAppendElement */))))(tls, interp, resultListPtr, (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls,
					func() uintptr {
						if (*EventScriptRecord)(unsafe.Pointer(esPtr)).mask == (int32(1) << 1) {
							return ts + 6697 /* "readable" */
						}
						return ts + 6720 /* "writable" */
					}(), -1))
			} else {
				(*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 368 /* &.tcl_ListObjAppendElement */))))(tls, interp, resultListPtr,
					(*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, ts+6512 /* "none" */, -1))
			}
			(*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 368 /* &.tcl_ListObjAppendElement */))))(tls, interp, resultListPtr, (*EventScriptRecord)(unsafe.Pointer(esPtr)).scriptPtr)
		}
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, resultListPtr)
		return 0
	}

	if (int32(*(*int8)(unsafe.Pointer(cmd + uintptr(0)))) == 'r') && (crt.Xstrncmp(tls, cmd, ts+7260 /* "removeall" */, uint64(uint32(len))) == 0) {
		if argc != 3 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+224, ts+1483 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
				ts+7270 /* " channelName rem..." */, (uintptr(0))))
			return 1
		}
		for esPtr = (*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr; esPtr != (uintptr(0)); esPtr = nextEsPtr {
			nextEsPtr = (*EventScriptRecord)(unsafe.Pointer(esPtr)).nextPtr
			(*(*func(*crt.TLS, Tcl_Channel, uintptr, ClientData))(unsafe.Pointer((tclStubsPtr + 824 /* &.tcl_DeleteChannelHandler */))))(tls, chanPtr,
				((*TclIntStubs)(unsafe.Pointer(tclIntStubsPtr)).tclChannelEventScriptInvoker), esPtr)
			for ok1 := true; ok1; ok1 = 0 != 0 {
				var _objPtr uintptr = ((*EventScriptRecord)(unsafe.Pointer(esPtr)).scriptPtr)
				if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
					(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
				}
			}
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, (esPtr))
		}
		(*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr = (uintptr(0))
		return 0
	}

	if (int32(*(*int8)(unsafe.Pointer(cmd + uintptr(0)))) == 's') && (crt.Xstrncmp(tls, cmd, ts+4166 /* "set" */, uint64(uint32(len))) == 0) {
		if argc != 5 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+256, ts+1483 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
				ts+7294 /* " channelName del..." */, (uintptr(0))))
			return 1
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), bp+416 /* &index */) == 1 {
			return 1
		}
		if *(*int32)(unsafe.Pointer(bp + 416 /* index */)) < 0 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+288, ts+7117 /* "bad event index:..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)),
				ts+7135 /* ": must be nonneg..." */, (uintptr(0))))
			return 1
		}
		i = 0
		esPtr = (*ChannelState)(unsafe.Pointer(statePtr)).scriptRecordPtr
	__4:
		if !((i < *(*int32)(unsafe.Pointer(bp + 416 /* index */))) && (esPtr != (uintptr(0)))) {
			goto __6
		}
		{
			// Empty loop body.
		}
		goto __5
	__5:
		i++
		esPtr = (*EventScriptRecord)(unsafe.Pointer(esPtr)).nextPtr
		goto __4
		goto __6
	__6:
		;
		if esPtr == (uintptr(0)) {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+320, ts+7157 /* "bad event index " */, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)),
				ts+7174 /* ": out of range" */, (uintptr(0))))
			return 1
		}

		if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)), ts+6697 /* "readable" */) == 0 {
			mask = (int32(1) << 1)
		} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)), ts+6720 /* "writable" */) == 0 {
			mask = (int32(1) << 2)
		} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)), ts+6512 /* "none" */) == 0 {
			mask = 0
		} else {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+352, ts+7034 /* "bad event name \"" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)),
				ts+7051 /* "\": must be reada..." */, (uintptr(0))))
			return 1
		}
		(*EventScriptRecord)(unsafe.Pointer(esPtr)).mask = mask
		(*(*func(*crt.TLS, Tcl_Channel, int32, uintptr, ClientData))(unsafe.Pointer((tclStubsPtr + 728 /* &.tcl_CreateChannelHandler */))))(tls, chanPtr, mask,
			((*TclIntStubs)(unsafe.Pointer(tclIntStubsPtr)).tclChannelEventScriptInvoker), esPtr)
		return 0
	}
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+384, ts+7327 /* "bad command " */, cmd,
		ts+7340 /* ", must be one of..." */, (uintptr(0))))
	return 1
}

//----------------------------------------------------------------------
//
// TestWrongNumArgsObjCmd --
//
//	Test the Tcl_WrongNumArgs function.
//
// Results:
//	Standard Tcl result.
//
// Side effects:
//	Sets interpreter result.
//
//----------------------------------------------------------------------

func TestWrongNumArgsObjCmd(tls *crt.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:6107:1: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var i int32 at bp, 4

	// var length int32 at bp+4, 4

	var msg uintptr

	if objc < 3 {
		// Don't use Tcl_WrongNumArgs here, as that is the function
		// we want to test!
		(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, ts+7394 /* "insufficient arg..." */, (uintptr(0)))
		return 1
	}

	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 320 /* &.tcl_GetIntFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &i */) != 0 {
		return 1
	}

	msg = (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 344 /* &.tcl_GetStringFromObj */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+4 /* &length */)
	if *(*int32)(unsafe.Pointer(bp + 4 /* length */)) == 0 {
		msg = (uintptr(0))
	}

	if *(*int32)(unsafe.Pointer(bp /* i */)) > (objc - 3) {
		// Asked for more arguments than were given.
		(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, ts+7394 /* "insufficient arg..." */, (uintptr(0)))
		return 1
	}

	(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, *(*int32)(unsafe.Pointer(bp /* i */)), (objv + uintptr(3)*8), msg)
	return 0
}

//----------------------------------------------------------------------
//
// TestGetIndexFromObjStructObjCmd --
//
//	Test the Tcl_GetIndexFromObjStruct function.
//
// Results:
//	Standard Tcl result.
//
// Side effects:
//	Sets interpreter result.
//
//----------------------------------------------------------------------

func TestGetIndexFromObjStructObjCmd(tls *crt.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:6163:1: */
	bp := tls.Alloc(208)
	defer tls.Free(208)

	*(*[8]uintptr)(unsafe.Pointer(bp + 72 /* ary */)) = [8]uintptr{
		ts + 5902 /* "a" */, ts + 7417 /* "b" */, ts + 7419 /* "c" */, ts + 7421 /* "d" */, ts + 2515 /* "e" */, ts + 2517 /* "f" */, (uintptr(0)), (uintptr(0)),
	}
	// var idx int32 at bp+136, 4

	// var target int32 at bp+140, 4

	if objc != 3 {
		(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+7423 /* "argument targetv..." */)
		return 1
	}
	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 2448 /* &.tcl_GetIndexFromObjStruct */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+72 /* &ary */, (int32(uint64(2)*8)),
		ts+7444 /* "dummy" */, 0, bp+136 /* &idx */) != 0 {
		return 1
	}
	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 320 /* &.tcl_GetIntFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+140 /* &target */) != 0 {
		return 1
	}
	if *(*int32)(unsafe.Pointer(bp + 136 /* idx */)) != *(*int32)(unsafe.Pointer(bp + 140 /* target */)) {
		// var buffer [64]int8 at bp+144, 64

		crt.Xsprintf(tls, bp+144 /* &buffer */, ts+5734 /* "%d" */, crt.VaList(bp, *(*int32)(unsafe.Pointer(bp + 136 /* idx */))))
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+8, ts+7450, /* "index value comp..." */
			bp+144 /* &buffer */, (uintptr(0))))
		crt.Xsprintf(tls, bp+144 /* &buffer */, ts+5734 /* "%d" */, crt.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 140 /* target */))))
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+40, ts+7486 /* " when " */, bp+144 /* &buffer */, ts+7493 /* " expected" */, (uintptr(0))))
		return 1
	}
	(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 3, objv, (uintptr(0)))
	return 0
}

//----------------------------------------------------------------------
//
// TestFilesystemObjCmd --
//
//	This procedure implements the "testfilesystem" command. It is used to
//	test Tcl_FSRegister, Tcl_FSUnregister, and can be used to test that
//	the pluggable filesystem works.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Inserts or removes a filesystem from Tcl's stack.
//
//----------------------------------------------------------------------

func TestFilesystemObjCmd(tls *crt.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:6217:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var res int32
	// var boolVal int32 at bp, 4

	var msg uintptr

	if objc != 2 {
		(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+7503 /* "boolean" */)
		return 1
	}
	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 272 /* &.tcl_GetBooleanFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &boolVal */) != 0 {
		return 1
	}
	if *(*int32)(unsafe.Pointer(bp /* boolVal */)) != 0 {
		res = (*(*func(*crt.TLS, ClientData, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 3800 /* &.tcl_FSRegister */))))(tls, interp, uintptr(unsafe.Pointer(&testReportingFilesystem)))
		if res == 0 {
			msg = ts + 7511 /* "registered" */
		} else {
			msg = ts + 7522 /* "failed" */
		}
	} else {
		res = (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 3808 /* &.tcl_FSUnregister */))))(tls, uintptr(unsafe.Pointer(&testReportingFilesystem)))
		if res == 0 {
			msg = ts + 7529 /* "unregistered" */
		} else {
			msg = ts + 7522 /* "failed" */
		}
	}
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, msg, -1))
	return res
}

func TestReportInFilesystem(tls *crt.TLS, pathPtr uintptr, clientDataPtr uintptr) int32 { /* tclTest.c:6245:1: */
	var newPathPtr uintptr

	if pathPtr == lastPathPtr {
		// Reject all files second time around
		return -1
	}

	// Try to claim all files first time around

	newPathPtr = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 248 /* &.tcl_DuplicateObj */))))(tls, pathPtr)
	lastPathPtr = newPathPtr
	(*Tcl_Obj)(unsafe.Pointer((newPathPtr))).refCount++
	if (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 3832 /* &.tcl_FSGetFileSystemForPath */))))(tls, newPathPtr) == (uintptr(0)) {
		// Nothing claimed it. Therefore we don't either
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (newPathPtr)
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
			}
		}
		lastPathPtr = (uintptr(0))
		return -1
	}
	lastPathPtr = (uintptr(0))
	*(*ClientData)(unsafe.Pointer(clientDataPtr)) = newPathPtr
	return 0
}

var lastPathPtr uintptr = (uintptr(0)) /* tclTest.c:6249:20 */

// Simple helper function to extract the native vfs representation of a path
// object, or NULL if no such representation exists.

func TestReportGetNativePath(tls *crt.TLS, pathPtr uintptr) uintptr { /* tclTest.c:6278:16: */
	return (*(*func(*crt.TLS, uintptr, uintptr) ClientData)(unsafe.Pointer((tclStubsPtr + 3736 /* &.tcl_FSGetInternalRep */))))(tls, pathPtr, uintptr(unsafe.Pointer(&testReportingFilesystem)))
}

func TestReportFreeInternalRep(tls *crt.TLS, clientData ClientData) { /* tclTest.c:6286:1: */
	var nativeRep uintptr = clientData

	if nativeRep != (uintptr(0)) {
		// Free the path
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (nativeRep)
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
			}
		}
	}
}

func TestReportDupInternalRep(tls *crt.TLS, clientData ClientData) ClientData { /* tclTest.c:6298:1: */
	var original uintptr = clientData

	(*Tcl_Obj)(unsafe.Pointer((original))).refCount++
	return clientData
}

func TestReport(tls *crt.TLS, cmd uintptr, path uintptr, arg2 uintptr) { /* tclTest.c:6308:1: */
	bp := tls.Alloc(216)
	defer tls.Free(216)

	var interp uintptr = (*(*func(*crt.TLS, uintptr) ClientData)(unsafe.Pointer((tclStubsPtr + 3816 /* &.tcl_FSData */))))(tls, uintptr(unsafe.Pointer(&testReportingFilesystem)))

	if interp == (uintptr(0)) {
	} else {
		// No idea why I decided to program this up using the old string-based
		// API, but there you go. We should convert it to objects.

		var savedResult uintptr
		// var ds Tcl_DString at bp, 216

		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 992 /* &.tcl_DStringInit */))))(tls, bp /* &ds */)
		(*(*func(*crt.TLS, uintptr, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 952 /* &.tcl_DStringAppend */))))(tls, bp /* &ds */, ts+7542 /* "lappend filesyst..." */, -1)
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 1016 /* &.tcl_DStringStartSublist */))))(tls, bp /* &ds */)
		(*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 960 /* &.tcl_DStringAppendElement */))))(tls, bp /* &ds */, cmd)
		if path != (uintptr(0)) {
			(*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 960 /* &.tcl_DStringAppendElement */))))(tls, bp /* &ds */, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, path))
		}
		if arg2 != (uintptr(0)) {
			(*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 960 /* &.tcl_DStringAppendElement */))))(tls, bp /* &ds */, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, arg2))
		}
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 968 /* &.tcl_DStringEndSublist */))))(tls, bp /* &ds */)
		savedResult = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp)
		(*Tcl_Obj)(unsafe.Pointer((savedResult))).refCount++
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS) uintptr)(unsafe.Pointer((tclStubsPtr + 456 /* &.tcl_NewObj */))))(tls))
		(*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 1048 /* &.tcl_Eval */))))(tls, interp, ((*Tcl_DString)(unsafe.Pointer((bp /* &ds */))).string))
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 976 /* &.tcl_DStringFree */))))(tls, bp /* &ds */)
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 1752 /* &.tcl_ResetResult */))))(tls, interp)
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, savedResult)
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (savedResult)
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
			}
		}
	}
}

func TestReportStat(tls *crt.TLS, path uintptr, buf uintptr) int32 { /* tclTest.c:6349:1: */
	TestReport(tls, ts+7568 /* "stat" */, path, (uintptr(0)))
	return (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 3648 /* &.tcl_FSStat */))))(tls, TestReportGetNativePath(tls, path), buf)
}

func TestReportLstat(tls *crt.TLS, path uintptr, buf uintptr) int32 { /* tclTest.c:6358:1: */
	TestReport(tls, ts+7573 /* "lstat" */, path, (uintptr(0)))
	return (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 3608 /* &.tcl_FSLstat */))))(tls, TestReportGetNativePath(tls, path), buf)
}

func TestReportAccess(tls *crt.TLS, path uintptr, mode int32) int32 { /* tclTest.c:6367:1: */
	TestReport(tls, ts+7579 /* "access" */, path, (uintptr(0)))
	return (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer((tclStubsPtr + 3656 /* &.tcl_FSAccess */))))(tls, TestReportGetNativePath(tls, path), mode)
}

func TestReportOpenFileChannel(tls *crt.TLS, interp uintptr, fileName uintptr, mode int32, permissions int32) Tcl_Channel { /* tclTest.c:6376:1: */
	TestReport(tls, ts+6658 /* "open" */, fileName, (uintptr(0)))
	return (*(*func(*crt.TLS, uintptr, uintptr, int32, int32) Tcl_Channel)(unsafe.Pointer((tclIntStubsPtr + 1680 /* &.tclpOpenFileChannel */))))(tls, interp, TestReportGetNativePath(tls, fileName),
		mode, permissions)
}

func TestReportMatchInDirectory(tls *crt.TLS, interp uintptr, resultPtr uintptr, dirPtr uintptr, pattern uintptr, types uintptr) int32 { /* tclTest.c:6390:1: */
	if (types != (uintptr(0))) && (((*Tcl_GlobTypeData)(unsafe.Pointer(types)).__type & (int32(1) << 7)) != 0) {
		TestReport(tls, ts+7586 /* "matchmounts" */, dirPtr, (uintptr(0)))
		return 0
	} else {
		TestReport(tls, ts+7598 /* "matchindirectory" */, dirPtr, (uintptr(0)))
		return (*(*func(*crt.TLS, uintptr, uintptr, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 3576 /* &.tcl_FSMatchInDirectory */))))(tls, interp, resultPtr,
			TestReportGetNativePath(tls, dirPtr), pattern, types)
	}
	return int32(0)
}

func TestReportChdir(tls *crt.TLS, dirName uintptr) int32 { /* tclTest.c:6409:1: */
	TestReport(tls, ts+7615 /* "chdir" */, dirName, (uintptr(0)))
	return (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 3680 /* &.tcl_FSChdir */))))(tls, TestReportGetNativePath(tls, dirName))
}

func TestReportLoadFile(tls *crt.TLS, interp uintptr, fileName uintptr, handlePtr uintptr, unloadProcPtr uintptr) int32 { /* tclTest.c:6417:1: */
	TestReport(tls, ts+7621 /* "loadfile" */, fileName, (uintptr(0)))
	return (*(*func(*crt.TLS, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 3568 /* &.tcl_FSLoadFile */))))(tls, interp, TestReportGetNativePath(tls, fileName), (uintptr(0)),
		(uintptr(0)), (uintptr(0)), (uintptr(0)), handlePtr, unloadProcPtr)
}

func TestReportLink(tls *crt.TLS, path uintptr, to uintptr, linkType int32) uintptr { /* tclTest.c:6434:16: */
	TestReport(tls, ts+7630 /* "link" */, path, to)
	return (*(*func(*crt.TLS, uintptr, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 3584 /* &.tcl_FSLink */))))(tls, TestReportGetNativePath(tls, path), to, linkType)
}

func TestReportRenameFile(tls *crt.TLS, src uintptr, dst uintptr) int32 { /* tclTest.c:6445:1: */
	TestReport(tls, ts+7635 /* "renamefile" */, src, dst)
	return (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 3600 /* &.tcl_FSRenameFile */))))(tls, TestReportGetNativePath(tls, src),
		TestReportGetNativePath(tls, dst))
}

func TestReportCopyFile(tls *crt.TLS, src uintptr, dst uintptr) int32 { /* tclTest.c:6457:1: */
	TestReport(tls, ts+7646 /* "copyfile" */, src, dst)
	return (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 3536 /* &.tcl_FSCopyFile */))))(tls, TestReportGetNativePath(tls, src),
		TestReportGetNativePath(tls, dst))
}

func TestReportDeleteFile(tls *crt.TLS, path uintptr) int32 { /* tclTest.c:6467:1: */
	TestReport(tls, ts+7655 /* "deletefile" */, path, (uintptr(0)))
	return (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 3560 /* &.tcl_FSDeleteFile */))))(tls, TestReportGetNativePath(tls, path))
}

func TestReportCreateDirectory(tls *crt.TLS, path uintptr) int32 { /* tclTest.c:6475:1: */
	TestReport(tls, ts+7666 /* "createdirectory" */, path, (uintptr(0)))
	return (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 3552 /* &.tcl_FSCreateDirectory */))))(tls, TestReportGetNativePath(tls, path))
}

func TestReportCopyDirectory(tls *crt.TLS, src uintptr, dst uintptr, errorPtr uintptr) int32 { /* tclTest.c:6483:1: */
	TestReport(tls, ts+7682 /* "copydirectory" */, src, dst)
	return (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 3544 /* &.tcl_FSCopyDirectory */))))(tls, TestReportGetNativePath(tls, src),
		TestReportGetNativePath(tls, dst), errorPtr)
}

func TestReportRemoveDirectory(tls *crt.TLS, path uintptr, recursive int32, errorPtr uintptr) int32 { /* tclTest.c:6496:1: */
	TestReport(tls, ts+7696 /* "removedirectory" */, path, (uintptr(0)))
	return (*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 3592 /* &.tcl_FSRemoveDirectory */))))(tls, TestReportGetNativePath(tls, path), recursive,
		errorPtr)
}

func TestReportFileAttrStrings(tls *crt.TLS, fileName uintptr, objPtrRef uintptr) uintptr { /* tclTest.c:6510:19: */
	TestReport(tls, ts+7712 /* "fileattributestr..." */, fileName, (uintptr(0)))
	return (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 3640 /* &.tcl_FSFileAttrStrings */))))(tls, TestReportGetNativePath(tls, fileName), objPtrRef)
}

func TestReportFileAttrsGet(tls *crt.TLS, interp uintptr, index int32, fileName uintptr, objPtrRef uintptr) int32 { /* tclTest.c:6520:1: */
	TestReport(tls, ts+7733 /* "fileattributesge..." */, fileName, (uintptr(0)))
	return (*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 3624 /* &.tcl_FSFileAttrsGet */))))(tls, interp, index,
		TestReportGetNativePath(tls, fileName), objPtrRef)
}

func TestReportFileAttrsSet(tls *crt.TLS, interp uintptr, index int32, fileName uintptr, objPtr uintptr) int32 { /* tclTest.c:6532:1: */
	TestReport(tls, ts+7751 /* "fileattributesse..." */, fileName, objPtr)
	return (*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 3632 /* &.tcl_FSFileAttrsSet */))))(tls, interp, index,
		TestReportGetNativePath(tls, fileName), objPtr)
}

func TestReportUtime(tls *crt.TLS, fileName uintptr, tval uintptr) int32 { /* tclTest.c:6544:1: */
	TestReport(tls, ts+7769 /* "utime" */, fileName, (uintptr(0)))
	return (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 3616 /* &.tcl_FSUtime */))))(tls, TestReportGetNativePath(tls, fileName), tval)
}

func TestReportNormalizePath(tls *crt.TLS, interp uintptr, pathPtr uintptr, nextCheckpoint int32) int32 { /* tclTest.c:6553:1: */
	TestReport(tls, ts+7775 /* "normalizepath" */, pathPtr, (uintptr(0)))
	return nextCheckpoint
}

func SimplePathInFilesystem(tls *crt.TLS, pathPtr uintptr, clientDataPtr uintptr) int32 { /* tclTest.c:6563:1: */
	var str uintptr = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, pathPtr)

	if crt.Xstrncmp(tls, str, ts+7789 /* "simplefs:/" */, uint64(10)) != 0 {
		return -1
	}
	return 0
}

// This is a slightly 'hacky' filesystem which is used just to test a few
// important features of the vfs code: (1) that you can load a shared library
// from a vfs, (2) that when copying files from one fs to another, the 'mtime'
// is preserved. (3) that recursive cross-filesystem directory copies have the
// correct behaviour with/without -force.
//
// It treats any file in 'simplefs:/' as a file, which it routes to the
// current directory. The real file it uses is whatever follows the trailing
// '/' (e.g. 'foo' in 'simplefs:/foo'), and that file exists or not according
// to what is in the native pwd.
//
// Please do not consider this filesystem a model of how things are to be
// done. It is quite the opposite!  But, it does allow us to test some
// important features.

func TestSimpleFilesystemObjCmd(tls *crt.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:6593:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var res int32
	// var boolVal int32 at bp, 4

	var msg uintptr

	if objc != 2 {
		(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+7503 /* "boolean" */)
		return 1
	}
	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 272 /* &.tcl_GetBooleanFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &boolVal */) != 0 {
		return 1
	}
	if *(*int32)(unsafe.Pointer(bp /* boolVal */)) != 0 {
		res = (*(*func(*crt.TLS, ClientData, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 3800 /* &.tcl_FSRegister */))))(tls, interp, uintptr(unsafe.Pointer(&simpleFilesystem)))
		if res == 0 {
			msg = ts + 7511 /* "registered" */
		} else {
			msg = ts + 7522 /* "failed" */
		}
	} else {
		res = (*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 3808 /* &.tcl_FSUnregister */))))(tls, uintptr(unsafe.Pointer(&simpleFilesystem)))
		if res == 0 {
			msg = ts + 7529 /* "unregistered" */
		} else {
			msg = ts + 7522 /* "failed" */
		}
	}
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, msg, -1))
	return res
}

// Treats a file name 'simplefs:/foo' by using the file 'foo' in the current
// (native) directory.

func SimpleRedirect(tls *crt.TLS, pathPtr uintptr) uintptr { /* tclTest.c:6625:16: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var len int32 at bp, 4

	var str uintptr
	var origPtr uintptr

	// We assume the same name in the current directory is ok.

	str = (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 344 /* &.tcl_GetStringFromObj */))))(tls, pathPtr, bp /* &len */)
	if (*(*int32)(unsafe.Pointer(bp /* len */)) < 10) || (crt.Xstrncmp(tls, str, ts+7789 /* "simplefs:/" */, uint64(10)) != 0) {
		// Probably shouldn't ever reach here
		(*Tcl_Obj)(unsafe.Pointer((pathPtr))).refCount++
		return pathPtr
	}
	origPtr = (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, (str + uintptr(10)), -1)
	(*Tcl_Obj)(unsafe.Pointer((origPtr))).refCount++
	return origPtr
}

func SimpleMatchInDirectory(tls *crt.TLS, interp uintptr, resultPtr uintptr, dirPtr uintptr, pattern uintptr, types uintptr) int32 { /* tclTest.c:6649:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var res int32
	var origPtr uintptr
	var resPtr uintptr

	// We only provide a new volume, therefore no mounts at all
	if (types != (uintptr(0))) && (((*Tcl_GlobTypeData)(unsafe.Pointer(types)).__type & (int32(1) << 7)) != 0) {
		return 0
	}

	// We assume the same name in the current directory is ok.
	resPtr = (*(*func(*crt.TLS) uintptr)(unsafe.Pointer((tclStubsPtr + 456 /* &.tcl_NewObj */))))(tls)
	(*Tcl_Obj)(unsafe.Pointer((resPtr))).refCount++
	origPtr = SimpleRedirect(tls, dirPtr)
	res = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 3576 /* &.tcl_FSMatchInDirectory */))))(tls, interp, resPtr, origPtr, pattern, types)
	if res == 0 {
		// var gLength int32 at bp, 4

		var j int32
		(*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 392 /* &.tcl_ListObjLength */))))(tls, (uintptr(0)), resPtr, bp /* &gLength */)
		for j = 0; j < *(*int32)(unsafe.Pointer(bp /* gLength */)); j++ {
			// var gElt uintptr at bp+8, 8

			var nElt uintptr
			(*(*func(*crt.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 384 /* &.tcl_ListObjIndex */))))(tls, (uintptr(0)), resPtr, j, bp+8 /* &gElt */)
			nElt = (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, ts+7789 /* "simplefs:/" */, 10)
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2304 /* &.tcl_AppendObjToObj */))))(tls, nElt, *(*uintptr)(unsafe.Pointer(bp + 8 /* gElt */)))
			(*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 368 /* &.tcl_ListObjAppendElement */))))(tls, (uintptr(0)), resultPtr, nElt)
		}
	}
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = (origPtr)
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
		}
	}
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = (resPtr)
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
		}
	}
	return res
}

func SimpleOpenFileChannel(tls *crt.TLS, interp uintptr, pathPtr uintptr, mode int32, permissions int32) Tcl_Channel { /* tclTest.c:6691:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var tempPtr uintptr
	var chan1 Tcl_Channel

	if (mode != 0) && !((mode & 00) != 0) {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+7800 /* "read-only" */, (uintptr(0))))
		return (uintptr(0))
	}

	tempPtr = SimpleRedirect(tls, pathPtr)
	chan1 = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32) Tcl_Channel)(unsafe.Pointer((tclStubsPtr + 3664 /* &.tcl_FSOpenFileChannel */))))(tls, interp, tempPtr, ts+7810 /* "r" */, permissions)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = (tempPtr)
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
		}
	}
	return chan1
}

func SimpleAccess(tls *crt.TLS, pathPtr uintptr, mode int32) int32 { /* tclTest.c:6714:1: */
	var tempPtr uintptr = SimpleRedirect(tls, pathPtr)
	var res int32 = (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer((tclStubsPtr + 3656 /* &.tcl_FSAccess */))))(tls, tempPtr, mode)

	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = (tempPtr)
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
		}
	}
	return res
}

func SimpleStat(tls *crt.TLS, pathPtr uintptr, bufPtr uintptr) int32 { /* tclTest.c:6726:1: */
	var tempPtr uintptr = SimpleRedirect(tls, pathPtr)
	var res int32 = (*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 3648 /* &.tcl_FSStat */))))(tls, tempPtr, bufPtr)

	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = (tempPtr)
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
		}
	}
	return res
}

func SimpleListVolumes(tls *crt.TLS) uintptr { /* tclTest.c:6737:16: */
	// Add one new volume
	var retVal uintptr

	retVal = (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, ts+7789 /* "simplefs:/" */, -1)
	(*Tcl_Obj)(unsafe.Pointer((retVal))).refCount++
	return retVal
}

// Used to check correct string-length determining in Tcl_NumUtfChars

func TestNumUtfCharsCmd(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:6753:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if objc > 1 {
		*(*int32)(unsafe.Pointer(bp /* len */)) = -1

		if objc > 2 {
			(*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 320 /* &.tcl_GetIntFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp /* &len */)
		}
		*(*int32)(unsafe.Pointer(bp /* len */)) = (*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer((tclStubsPtr + 2512 /* &.tcl_NumUtfChars */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), *(*int32)(unsafe.Pointer(bp /* len */)))
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, *(*int32)(unsafe.Pointer(bp /* len */))))
	}
	return 0
}

// Used to check correct operation of Tcl_UtfFindFirst

func TestFindFirstCmd(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:6776:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if objc > 1 {
		*(*int32)(unsafe.Pointer(bp /* len */)) = -1

		if objc > 2 {
			(*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 320 /* &.tcl_GetIntFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp /* &len */)
		}
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 2640 /* &.tcl_UtfFindFirst */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), *(*int32)(unsafe.Pointer(bp /* len */))), -1))
	}
	return 0
}

// Used to check correct operation of Tcl_UtfFindLast

func TestFindLastCmd(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:6798:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if objc > 1 {
		*(*int32)(unsafe.Pointer(bp /* len */)) = -1

		if objc > 2 {
			(*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 320 /* &.tcl_GetIntFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp /* &len */)
		}
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 2648 /* &.tcl_UtfFindLast */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))), *(*int32)(unsafe.Pointer(bp /* len */))), -1))
	}
	return 0
}

// Used to do basic checks of the TCL_HASH_KEY_SYSTEM_HASH flag

func TestHashSystemHashCmd(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:6876:1: */
	bp := tls.Alloc(164)
	defer tls.Free(164)

	// var hash Tcl_HashTable at bp+72, 88

	var hPtr uintptr
	var i int32
	// var isNew int32 at bp+160, 4

	*(*int32)(unsafe.Pointer(bp + 64 /* limit */)) = 100

	if (objc > 1) && ((*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 320 /* &.tcl_GetIntFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+64 /* &limit */) != 0) {
		return 1
	}

	(*(*func(*crt.TLS, uintptr, int32, uintptr))(unsafe.Pointer((tclStubsPtr + 3400 /* &.tcl_InitCustomHashTable */))))(tls, bp+72 /* &hash */, (-2), uintptr(unsafe.Pointer(&hkType)))

	if (*Tcl_HashTable)(unsafe.Pointer(bp+72 /* &hash */)).numEntries != 0 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+7812 /* "non-zero initial..." */, (uintptr(0))))
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 888 /* &.tcl_DeleteHashTable */))))(tls, bp+72 /* &hash */)
		return 1
	}

	for i = 0; i < *(*int32)(unsafe.Pointer(bp + 64 /* limit */)); i++ {
		hPtr = (*(*func(*crt.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer(((bp + 72 /* &hash */) + 72 /* &.createProc */))))(tls, bp+72 /* &hash */, (uintptr((intptr_t(i)))), bp+160 /* &isNew */)
		if !(*(*int32)(unsafe.Pointer(bp + 160 /* isNew */)) != 0) {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, i))
			(*(*func(*crt.TLS, uintptr, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 144 /* &.tcl_AppendToObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp), ts+7834 /* " creation proble..." */, -1)
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 888 /* &.tcl_DeleteHashTable */))))(tls, bp+72 /* &hash */)
			return 1
		}
		(*Tcl_HashEntry)(unsafe.Pointer((hPtr))).clientData = (uintptr((intptr_t(i + 42))))
	}

	if (*Tcl_HashTable)(unsafe.Pointer(bp+72 /* &hash */)).numEntries != *(*int32)(unsafe.Pointer(bp + 64 /* limit */)) {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+16, ts+7852 /* "unexpected maxim..." */, (uintptr(0))))
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 888 /* &.tcl_DeleteHashTable */))))(tls, bp+72 /* &hash */)
		return 1
	}

	for i = 0; i < *(*int32)(unsafe.Pointer(bp + 64 /* limit */)); i++ {
		hPtr = (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(((bp + 72 /* &hash */) + 64 /* &.findProc */))))(tls, bp+72 /* &hash */, (uintptr((intptr_t(i)))))
		if hPtr == (uintptr(0)) {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, i))
			(*(*func(*crt.TLS, uintptr, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 144 /* &.tcl_AppendToObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp), ts+7876 /* " lookup problem" */, -1)
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 888 /* &.tcl_DeleteHashTable */))))(tls, bp+72 /* &hash */)
			return 1
		}
		if (int32(((*Tcl_HashEntry)(unsafe.Pointer((hPtr))).clientData))) != (i + 42) {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, i))
			(*(*func(*crt.TLS, uintptr, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 144 /* &.tcl_AppendToObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp), ts+7892 /* " value problem" */, -1)
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 888 /* &.tcl_DeleteHashTable */))))(tls, bp+72 /* &hash */)
			return 1
		}
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 880 /* &.tcl_DeleteHashEntry */))))(tls, hPtr)
	}

	if (*Tcl_HashTable)(unsafe.Pointer(bp+72 /* &hash */)).numEntries != 0 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+32, ts+7907 /* "non-zero final s..." */, (uintptr(0))))
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 888 /* &.tcl_DeleteHashTable */))))(tls, bp+72 /* &hash */)
		return 1
	}

	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 888 /* &.tcl_DeleteHashTable */))))(tls, bp+72 /* &hash */)
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+48, ts+7927 /* "OK" */, (uintptr(0))))
	return 0
}

var hkType = Tcl_HashKeyType{
	1, 0x2,
	(uintptr(0)), (uintptr(0)), (uintptr(0)), (uintptr(0)),
} /* tclTest.c:6882:34 */

// Used for testing Tcl_GetInt which is no longer used directly by the
// core very much.
func TestgetintCmd(tls *crt.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:6952:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if argc < 2 {
		(*(*func(*crt.TLS, uintptr, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1872 /* &.tcl_SetResult */))))(tls, interp, ts+1397 /* "wrong # args" */, (uintptr(0)))
		return 1
	} else {
		// var val int32 at bp, 4

		var i int32
		var total int32 = 0

		for i = 1; i < argc; i++ {
			if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), bp /* &val */) != 0 {
				return 1
			}
			total = total + (*(*int32)(unsafe.Pointer(bp /* val */)))
		}
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, total))
		return 0
	}
	return int32(0)
}

func NREUnwind_callback(tls *crt.TLS, data uintptr, interp uintptr, result int32) int32 { /* tclTest.c:6976:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var none int32 at bp, 4

	if *(*ClientData)(unsafe.Pointer(data + uintptr(0)*8)) == (crt.UintptrFromInt64((int64(-1)))) {
		(*(*func(*crt.TLS, uintptr, uintptr, ClientData, ClientData, ClientData, ClientData))(unsafe.Pointer((tclStubsPtr + 4712 /* &.tcl_NRAddCallback */))))(tls, interp, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr, int32) int32
		}{NREUnwind_callback})), bp /* &none */, (crt.UintptrFromInt64((int64(-1)))),
			(crt.UintptrFromInt64((int64(-1)))), (uintptr(0)))
	} else if *(*ClientData)(unsafe.Pointer(data + uintptr(1)*8)) == (crt.UintptrFromInt64((int64(-1)))) {
		(*(*func(*crt.TLS, uintptr, uintptr, ClientData, ClientData, ClientData, ClientData))(unsafe.Pointer((tclStubsPtr + 4712 /* &.tcl_NRAddCallback */))))(tls, interp, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr, int32) int32
		}{NREUnwind_callback})), *(*ClientData)(unsafe.Pointer(data + uintptr(0)*8)), bp, /* &none */
			(crt.UintptrFromInt64((int64(-1)))), (uintptr(0)))
	} else if *(*ClientData)(unsafe.Pointer(data + uintptr(2)*8)) == (crt.UintptrFromInt64((int64(-1)))) {
		(*(*func(*crt.TLS, uintptr, uintptr, ClientData, ClientData, ClientData, ClientData))(unsafe.Pointer((tclStubsPtr + 4712 /* &.tcl_NRAddCallback */))))(tls, interp, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr, int32) int32
		}{NREUnwind_callback})), *(*ClientData)(unsafe.Pointer(data + uintptr(0)*8)), *(*ClientData)(unsafe.Pointer(data + uintptr(1)*8)),
			bp /* &none */, (uintptr(0)))
	} else {
		// var idata [3]uintptr at bp+8, 24

		*(*uintptr)(unsafe.Pointer(bp + 8 /* &idata */ + uintptr(0)*8)) = (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, (int32((int64(*(*ClientData)(unsafe.Pointer(data + uintptr(1)*8))) - int64(*(*ClientData)(unsafe.Pointer(data + uintptr(0)*8)))) / 1)))
		*(*uintptr)(unsafe.Pointer(bp + 8 /* &idata */ + uintptr(1)*8)) = (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, (int32((int64(*(*ClientData)(unsafe.Pointer(data + uintptr(2)*8))) - int64(*(*ClientData)(unsafe.Pointer(data + uintptr(0)*8)))) / 1)))
		*(*uintptr)(unsafe.Pointer(bp + 8 /* &idata */ + uintptr(2)*8)) = (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, (int32((int64(bp /* &none */) - int64(*(*ClientData)(unsafe.Pointer(data + uintptr(0)*8)))) / 1)))
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, int32, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 440 /* &.tcl_NewListObj */))))(tls, 3, bp+8 /* &idata */))
	}
	return 0
}

func TestNREUnwind(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:7003:1: */
	// Insure that callbacks effectively run at the proper level during the
	// unwinding of the NRE stack.

	(*(*func(*crt.TLS, uintptr, uintptr, ClientData, ClientData, ClientData, ClientData))(unsafe.Pointer((tclStubsPtr + 4712 /* &.tcl_NRAddCallback */))))(tls, interp, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, int32) int32
	}{NREUnwind_callback})), (crt.UintptrFromInt64((int64(-1)))), (crt.UintptrFromInt64((int64(-1)))),
		(crt.UintptrFromInt64((int64(-1)))), (uintptr(0)))
	return 0
}

func TestNRELevels(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:7021:1: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var iPtr uintptr = interp
	// var depth ptrdiff_t at bp, 8

	// var levels [6]uintptr at bp+8, 48

	var i int32 = 0
	var cbPtr uintptr = (*ExecEnv1)(unsafe.Pointer((*Interp)(unsafe.Pointer(iPtr)).execEnvPtr)).callbackPtr

	if refDepth == (uintptr(0)) {
		refDepth = bp /* &depth */
	}

	*(*ptrdiff_t)(unsafe.Pointer(bp /* depth */)) = ((int64(refDepth) - int64(bp /* &depth */)) / 8)

	*(*uintptr)(unsafe.Pointer(bp + 8 /* &levels */ + uintptr(0)*8)) = (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, int32(*(*ptrdiff_t)(unsafe.Pointer(bp /* depth */))))
	*(*uintptr)(unsafe.Pointer(bp + 8 /* &levels */ + uintptr(1)*8)) = (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, (*Interp)(unsafe.Pointer(iPtr)).numLevels)
	*(*uintptr)(unsafe.Pointer(bp + 8 /* &levels */ + uintptr(2)*8)) = (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, (*CmdFrame)(unsafe.Pointer((*Interp)(unsafe.Pointer(iPtr)).cmdFramePtr)).level)
	*(*uintptr)(unsafe.Pointer(bp + 8 /* &levels */ + uintptr(3)*8)) = (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, (*CallFrame)(unsafe.Pointer((*Interp)(unsafe.Pointer(iPtr)).varFramePtr)).level)
	*(*uintptr)(unsafe.Pointer(bp + 8 /* &levels */ + uintptr(4)*8)) = (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, (int32(int64(((*ExecStack)(unsafe.Pointer((*ExecEnv1)(unsafe.Pointer((*Interp)(unsafe.Pointer(iPtr)).execEnvPtr)).execStackPtr)).tosPtr -
		((*ExecEnv1)(unsafe.Pointer((*Interp)(unsafe.Pointer(iPtr)).execEnvPtr)).execStackPtr + 40 /* &.stackWords */)) / 8))))

	for cbPtr != 0 {
		i++
		cbPtr = (*NRE_callback)(unsafe.Pointer(cbPtr)).nextPtr
	}
	*(*uintptr)(unsafe.Pointer(bp + 8 /* &levels */ + uintptr(5)*8)) = (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, i)

	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, int32, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 440 /* &.tcl_NewListObj */))))(tls, 6, bp+8 /* &levels */))
	return 0
}

var refDepth uintptr = (uintptr(0)) /* tclTest.c:7028:22 */

//----------------------------------------------------------------------
//
// TestconcatobjCmd --
//
//	This procedure implements the "testconcatobj" command. It is used
//	to test that Tcl_ConcatObj does indeed return a fresh Tcl_Obj in all
//	cases and thet it never corrupts its arguments. In other words, that
//	[Bug 1447328] was fixed properly.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestconcatobjCmd(tls *crt.TLS, dummy ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclTest.c:7077:1: */
	bp := tls.Alloc(588)
	defer tls.Free(588)

	var list1Ptr uintptr
	var list2Ptr uintptr
	var emptyPtr uintptr
	var concatPtr uintptr
	var tmpPtr uintptr
	var result int32 = 0
	// var len int32 at bp+544, 4

	// var objv [3]uintptr at bp+552, 24

	// Set the start of the error message as obj result; it will be cleared at
	// the end if no errors were found.

	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp,
		(*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, ts+7930 /* "Tcl_ConcatObj is..." */, -1))

	emptyPtr = (*(*func(*crt.TLS) uintptr)(unsafe.Pointer((tclStubsPtr + 456 /* &.tcl_NewObj */))))(tls)

	list1Ptr = (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, ts+7955 /* "foo bar sum" */, -1)
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 392 /* &.tcl_ListObjLength */))))(tls, (uintptr(0)), list1Ptr, bp+544 /* &len */)
	if (*Tcl_Obj)(unsafe.Pointer(list1Ptr)).bytes != (uintptr(0)) {
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, ((*Tcl_Obj)(unsafe.Pointer(list1Ptr)).bytes))
		(*Tcl_Obj)(unsafe.Pointer(list1Ptr)).bytes = (uintptr(0))
	}

	list2Ptr = (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, ts+7967 /* "eeny meeny" */, -1)
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 392 /* &.tcl_ListObjLength */))))(tls, (uintptr(0)), list2Ptr, bp+544 /* &len */)
	if (*Tcl_Obj)(unsafe.Pointer(list2Ptr)).bytes != (uintptr(0)) {
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, ((*Tcl_Obj)(unsafe.Pointer(list2Ptr)).bytes))
		(*Tcl_Obj)(unsafe.Pointer(list2Ptr)).bytes = (uintptr(0))
	}

	// Verify that concat'ing a list obj with one or more empty strings does
	// return a fresh Tcl_Obj (see also [Bug 2055782]).

	tmpPtr = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 248 /* &.tcl_DuplicateObj */))))(tls, list1Ptr)

	*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv */ + uintptr(0)*8)) = tmpPtr
	*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv */ + uintptr(1)*8)) = emptyPtr
	concatPtr = (*(*func(*crt.TLS, int32, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 152 /* &.tcl_ConcatObj */))))(tls, 2, bp+552 /* &objv */)
	if (*Tcl_Obj)(unsafe.Pointer(concatPtr)).refCount != 0 {
		result = 1
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp,
			crt.VaList(bp, ts+7978 /* "\n\t* (a) concatOb..." */, (uintptr(0))))
	}
	if concatPtr == tmpPtr {
		result = 1
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+16, ts+8021, /* "\n\t* (a) concatOb..." */
			(uintptr(0))))
		switch (*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount {
		case 0:
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+32, ts+8057 /* "(no new refCount..." */, (uintptr(0))))
			break
			fallthrough
		case 1:
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+48, ts+8075 /* "(refCount added)" */, (uintptr(0))))
			break
			fallthrough
		default:
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+64, ts+8092 /* "(more than one r..." */, (uintptr(0))))
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 32 /* &.tcl_Panic */))))(tls, ts+8124 /* "extremely unsafe..." */, 0)
		}
		tmpPtr = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 248 /* &.tcl_DuplicateObj */))))(tls, list1Ptr)
		*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv */ + uintptr(0)*8)) = tmpPtr
	}
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = (concatPtr)
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
		}
	}

	(*Tcl_Obj)(unsafe.Pointer((tmpPtr))).refCount++
	concatPtr = (*(*func(*crt.TLS, int32, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 152 /* &.tcl_ConcatObj */))))(tls, 2, bp+552 /* &objv */)
	if (*Tcl_Obj)(unsafe.Pointer(concatPtr)).refCount != 0 {
		result = 1
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp,
			crt.VaList(bp+80, ts+8170 /* "\n\t* (b) concatOb..." */, (uintptr(0))))
	}
	if concatPtr == tmpPtr {
		result = 1
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+96, ts+8213, /* "\n\t* (b) concatOb..." */
			(uintptr(0))))
		switch (*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount {
		case 0:
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+112, ts+8249 /* "(refCount remove..." */, (uintptr(0))))
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 32 /* &.tcl_Panic */))))(tls, ts+8124 /* "extremely unsafe..." */, 0)
			break
			fallthrough
		case 1:
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+128, ts+8057 /* "(no new refCount..." */, (uintptr(0))))
			break
			fallthrough
		case 2:
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+144, ts+8075 /* "(refCount added)" */, (uintptr(0))))
			for ok1 := true; ok1; ok1 = 0 != 0 {
				var _objPtr uintptr = (tmpPtr)
				if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
					(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
				}
			}
			break
			fallthrough
		default:
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+160, ts+8092 /* "(more than one r..." */, (uintptr(0))))
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 32 /* &.tcl_Panic */))))(tls, ts+8124 /* "extremely unsafe..." */, 0)
		}
		tmpPtr = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 248 /* &.tcl_DuplicateObj */))))(tls, list1Ptr)
		*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv */ + uintptr(0)*8)) = tmpPtr
	}
	for ok2 := true; ok2; ok2 = 0 != 0 {
		var _objPtr uintptr = (concatPtr)
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
		}
	}

	*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv */ + uintptr(0)*8)) = emptyPtr
	*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv */ + uintptr(1)*8)) = tmpPtr
	*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv */ + uintptr(2)*8)) = emptyPtr
	concatPtr = (*(*func(*crt.TLS, int32, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 152 /* &.tcl_ConcatObj */))))(tls, 3, bp+552 /* &objv */)
	if (*Tcl_Obj)(unsafe.Pointer(concatPtr)).refCount != 0 {
		result = 1
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp,
			crt.VaList(bp+176, ts+8269 /* "\n\t* (c) concatOb..." */, (uintptr(0))))
	}
	if concatPtr == tmpPtr {
		result = 1
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+192, ts+8312, /* "\n\t* (c) concatOb..." */
			(uintptr(0))))
		switch (*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount {
		case 0:
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+208, ts+8057 /* "(no new refCount..." */, (uintptr(0))))
			break
			fallthrough
		case 1:
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+224, ts+8075 /* "(refCount added)" */, (uintptr(0))))
			break
			fallthrough
		default:
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+240, ts+8092 /* "(more than one r..." */, (uintptr(0))))
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 32 /* &.tcl_Panic */))))(tls, ts+8124 /* "extremely unsafe..." */, 0)
		}
		tmpPtr = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 248 /* &.tcl_DuplicateObj */))))(tls, list1Ptr)
		*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv */ + uintptr(1)*8)) = tmpPtr
	}
	for ok3 := true; ok3; ok3 = 0 != 0 {
		var _objPtr uintptr = (concatPtr)
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
		}
	}

	(*Tcl_Obj)(unsafe.Pointer((tmpPtr))).refCount++
	concatPtr = (*(*func(*crt.TLS, int32, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 152 /* &.tcl_ConcatObj */))))(tls, 3, bp+552 /* &objv */)
	if (*Tcl_Obj)(unsafe.Pointer(concatPtr)).refCount != 0 {
		result = 1
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp,
			crt.VaList(bp+256, ts+8348 /* "\n\t* (d) concatOb..." */, (uintptr(0))))
	}
	if concatPtr == tmpPtr {
		result = 1
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+272, ts+8391, /* "\n\t* (d) concatOb..." */
			(uintptr(0))))
		switch (*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount {
		case 0:
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+288, ts+8249 /* "(refCount remove..." */, (uintptr(0))))
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 32 /* &.tcl_Panic */))))(tls, ts+8124 /* "extremely unsafe..." */, 0)
			break
			fallthrough
		case 1:
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+304, ts+8057 /* "(no new refCount..." */, (uintptr(0))))
			break
			fallthrough
		case 2:
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+320, ts+8075 /* "(refCount added)" */, (uintptr(0))))
			for ok4 := true; ok4; ok4 = 0 != 0 {
				var _objPtr uintptr = (tmpPtr)
				if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
					(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
				}
			}
			break
			fallthrough
		default:
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+336, ts+8092 /* "(more than one r..." */, (uintptr(0))))
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 32 /* &.tcl_Panic */))))(tls, ts+8124 /* "extremely unsafe..." */, 0)
		}
		tmpPtr = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 248 /* &.tcl_DuplicateObj */))))(tls, list1Ptr)
		*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv */ + uintptr(1)*8)) = tmpPtr
	}
	for ok5 := true; ok5; ok5 = 0 != 0 {
		var _objPtr uintptr = (concatPtr)
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
		}
	}

	// Verify that an unshared list is not corrupted when concat'ing things to
	// it.

	*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv */ + uintptr(0)*8)) = tmpPtr
	*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv */ + uintptr(1)*8)) = list2Ptr
	concatPtr = (*(*func(*crt.TLS, int32, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 152 /* &.tcl_ConcatObj */))))(tls, 2, bp+552 /* &objv */)
	if (*Tcl_Obj)(unsafe.Pointer(concatPtr)).refCount != 0 {
		result = 1
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp,
			crt.VaList(bp+352, ts+8427 /* "\n\t* (e) concatOb..." */, (uintptr(0))))
	}
	if concatPtr == tmpPtr {
		// var len int32 at bp+576, 4

		result = 1
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+368, ts+8470, /* "\n\t* (e) concatOb..." */
			(uintptr(0))))

		(*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 392 /* &.tcl_ListObjLength */))))(tls, (uintptr(0)), concatPtr, bp+576 /* &len */)
		switch (*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount {
		case 3:
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+384, ts+8506 /* "(failed to conca..." */, (uintptr(0))))
			break
			fallthrough
		default:
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+400, ts+8525 /* "(corrupted input..." */, (uintptr(0))))
		}
		if (*Tcl_Obj)(unsafe.Pointer((tmpPtr))).refCount > 1 {
			for ok6 := true; ok6; ok6 = 0 != 0 {
				var _objPtr uintptr = (tmpPtr)
				if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
					(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
				}
			}
		}
		tmpPtr = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 248 /* &.tcl_DuplicateObj */))))(tls, list1Ptr)
		*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv */ + uintptr(0)*8)) = tmpPtr
	}
	for ok7 := true; ok7; ok7 = 0 != 0 {
		var _objPtr uintptr = (concatPtr)
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
		}
	}

	*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv */ + uintptr(0)*8)) = tmpPtr
	*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv */ + uintptr(1)*8)) = list2Ptr
	(*Tcl_Obj)(unsafe.Pointer((tmpPtr))).refCount++
	concatPtr = (*(*func(*crt.TLS, int32, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 152 /* &.tcl_ConcatObj */))))(tls, 2, bp+552 /* &objv */)
	if (*Tcl_Obj)(unsafe.Pointer(concatPtr)).refCount != 0 {
		result = 1
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp,
			crt.VaList(bp+416, ts+8544 /* "\n\t* (f) concatOb..." */, (uintptr(0))))
	}
	if concatPtr == tmpPtr {
		// var len int32 at bp+580, 4

		result = 1
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+432, ts+8587, /* "\n\t* (f) concatOb..." */
			(uintptr(0))))

		(*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 392 /* &.tcl_ListObjLength */))))(tls, (uintptr(0)), concatPtr, bp+580 /* &len */)
		switch (*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount {
		case 3:
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+448, ts+8506 /* "(failed to conca..." */, (uintptr(0))))
			break
			fallthrough
		default:
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+464, ts+8525 /* "(corrupted input..." */, (uintptr(0))))
		}
		if (*Tcl_Obj)(unsafe.Pointer((tmpPtr))).refCount > 1 {
			for ok8 := true; ok8; ok8 = 0 != 0 {
				var _objPtr uintptr = (tmpPtr)
				if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
					(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
				}
			}
		}
		tmpPtr = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 248 /* &.tcl_DuplicateObj */))))(tls, list1Ptr)
		*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv */ + uintptr(0)*8)) = tmpPtr
	}
	for ok9 := true; ok9; ok9 = 0 != 0 {
		var _objPtr uintptr = (concatPtr)
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
		}
	}

	*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv */ + uintptr(0)*8)) = tmpPtr
	*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv */ + uintptr(1)*8)) = list2Ptr
	(*Tcl_Obj)(unsafe.Pointer((tmpPtr))).refCount++
	(*Tcl_Obj)(unsafe.Pointer((tmpPtr))).refCount++
	concatPtr = (*(*func(*crt.TLS, int32, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 152 /* &.tcl_ConcatObj */))))(tls, 2, bp+552 /* &objv */)
	if (*Tcl_Obj)(unsafe.Pointer(concatPtr)).refCount != 0 {
		result = 1
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp,
			crt.VaList(bp+480, ts+8623 /* "\n\t* (g) concatOb..." */, (uintptr(0))))
	}
	if concatPtr == tmpPtr {
		// var len int32 at bp+584, 4

		result = 1
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+496, ts+8666, /* "\n\t* (g) concatOb..." */
			(uintptr(0))))

		(*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 392 /* &.tcl_ListObjLength */))))(tls, (uintptr(0)), concatPtr, bp+584 /* &len */)
		switch (*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount {
		case 3:
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+512, ts+8506 /* "(failed to conca..." */, (uintptr(0))))
			break
			fallthrough
		default:
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+528, ts+8525 /* "(corrupted input..." */, (uintptr(0))))
		}
		for ok10 := true; ok10; ok10 = 0 != 0 {
			var _objPtr uintptr = (tmpPtr)
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
			}
		}
		if (*Tcl_Obj)(unsafe.Pointer((tmpPtr))).refCount > 1 {
			for ok11 := true; ok11; ok11 = 0 != 0 {
				var _objPtr uintptr = (tmpPtr)
				if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
					(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
				}
			}
		}
		tmpPtr = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 248 /* &.tcl_DuplicateObj */))))(tls, list1Ptr)
		*(*uintptr)(unsafe.Pointer(bp + 552 /* &objv */ + uintptr(0)*8)) = tmpPtr
	}
	for ok12 := true; ok12; ok12 = 0 != 0 {
		var _objPtr uintptr = (concatPtr)
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
		}
	}

	// Clean everything up. Note that we don't actually know how many
	// references there are to tmpPtr here; in the no-error case, it should be
	// five... [Bug 2895367]

	for ok13 := true; ok13; ok13 = 0 != 0 {
		var _objPtr uintptr = (list1Ptr)
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
		}
	}
	for ok14 := true; ok14; ok14 = 0 != 0 {
		var _objPtr uintptr = (list2Ptr)
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
		}
	}
	for ok15 := true; ok15; ok15 = 0 != 0 {
		var _objPtr uintptr = (emptyPtr)
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
		}
	}
	for (*Tcl_Obj)(unsafe.Pointer(tmpPtr)).refCount > 1 {
		for ok16 := true; ok16; ok16 = 0 != 0 {
			var _objPtr uintptr = (tmpPtr)
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
			}
		}
	}
	for ok17 := true; ok17; ok17 = 0 != 0 {
		var _objPtr uintptr = (tmpPtr)
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
		}
	}

	if result == 0 {
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 1752 /* &.tcl_ResetResult */))))(tls, interp)
	}
	return result
}

//----------------------------------------------------------------------
//
// TestparseargsCmd --
//
//	This procedure implements the "testparseargs" command. It is used to
//	test that Tcl_ParseArgsObjv does indeed return the right number of
//	arguments. In other words, that [Bug 3413857] was fixed properly.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestparseargsCmd(tls *crt.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:7380:1: */
	bp := tls.Alloc(232)
	defer tls.Free(232)

	*(*int32)(unsafe.Pointer(bp + 192 /* count */)) = objc
	// var remObjv uintptr at bp+200, 8

	// var result [3]uintptr at bp+208, 24

	*(*[4]Tcl_ArgvInfo)(unsafe.Pointer(bp /* argTable */)) = [4]Tcl_ArgvInfo{
		{15, ts + 8702 /* "-bool" */, (uintptr((int64(1)))), uintptr(unsafe.Pointer(&foo)), ts + 8708 /* "booltest" */, (uintptr(0))},
		{18, ts + 4824 /* "--" */, (uintptr(0)), (uintptr(0)), ts + 8717 /* "Marks the end of..." */, (uintptr(0))}, {22, ts + 8746 /* "-help" */, (uintptr(0)), (uintptr(0)), ts + 8752 /* "Print summary of..." */, (uintptr(0))}, {23, (uintptr(0)), (uintptr(0)), (uintptr(0)), (uintptr(0)), (uintptr(0))},
	}

	foo = 0
	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 4848 /* &.tcl_ParseArgsObjv */))))(tls, interp, bp /* &argTable */, bp+192 /* &count */, objv, bp+200 /* &remObjv */) != 0 {
		return 1
	}
	*(*uintptr)(unsafe.Pointer(bp + 208 /* &result */ + uintptr(0)*8)) = (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, foo)
	*(*uintptr)(unsafe.Pointer(bp + 208 /* &result */ + uintptr(1)*8)) = (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, *(*int32)(unsafe.Pointer(bp + 192 /* count */)))
	*(*uintptr)(unsafe.Pointer(bp + 208 /* &result */ + uintptr(2)*8)) = (*(*func(*crt.TLS, int32, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 440 /* &.tcl_NewListObj */))))(tls, *(*int32)(unsafe.Pointer(bp + 192 /* count */)), *(*uintptr)(unsafe.Pointer(bp + 200 /* remObjv */)))
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, int32, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 440 /* &.tcl_NewListObj */))))(tls, 3, bp+208 /* &result */))
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, (*(*uintptr)(unsafe.Pointer(bp + 200 /* remObjv */))))
	return 0
}

var foo int32 = 0 /* tclTest.c:7386:16 */

// *
// Test harness for command and variable resolvers.

func InterpCmdResolver(tls *crt.TLS, interp uintptr, name uintptr, context uintptr, flags int32, rPtr uintptr) int32 { /* tclTest.c:7411:1: */
	var iPtr uintptr = interp
	var varFramePtr uintptr = (*Interp)(unsafe.Pointer(iPtr)).varFramePtr
	var procPtr uintptr
	if ((*CallFrame)(unsafe.Pointer(varFramePtr)).isProcCallFrame & 0x1) != 0 {
		procPtr = (*CallFrame)(unsafe.Pointer(varFramePtr)).procPtr
	} else {
		procPtr = (uintptr(0))
	}
	var callerNsPtr uintptr = (*CallFrame)(unsafe.Pointer(varFramePtr)).nsPtr
	var resolvedCmdPtr Tcl_Command = (uintptr(0))

	// Just do something special on a cmd literal "z" in two cases:
	//  A)  when the caller is a proc "x", and the proc is either in "::" or in "::ns2".
	//  B) the caller's namespace is "ctx1" or "ctx2"
	if (int32(*(*int8)(unsafe.Pointer(name + uintptr(0)))) == 'z') && (int32(*(*int8)(unsafe.Pointer(name + uintptr(1)))) == 0) {
		var ns2NsPtr uintptr = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32) uintptr)(unsafe.Pointer((tclIntStubsPtr + 952 /* &.tcl_FindNamespace */))))(tls, interp, ts+8800 /* "::ns2" */, (uintptr(0)), 0)

		if (procPtr != (uintptr(0))) &&
			(((*Command1)(unsafe.Pointer((*Proc)(unsafe.Pointer(procPtr)).cmdPtr)).nsPtr == (*Interp)(unsafe.Pointer(iPtr)).globalNsPtr) ||
				((ns2NsPtr != (uintptr(0))) && ((*Command1)(unsafe.Pointer((*Proc)(unsafe.Pointer(procPtr)).cmdPtr)).nsPtr == ns2NsPtr))) {
			// Case A)
			//
			//    - The context, in which this resolver becomes active, is
			//      determined by the name of the caller proc, which has to be
			//      named "x".
			//
			//    - To determine the name of the caller proc, the proc is taken
			//      from the topmost stack frame.
			//
			//    - Note that the context is NOT provided during byte-code
			//      compilation (e.g. in TclProcCompileProc)
			//
			//   When these conditions hold, this function resolves the
			//   passed-in cmd literal into a cmd "y", which is taken from the
			//   the global namespace (for simplicity).

			var callingCmdName uintptr = (*(*func(*crt.TLS, uintptr, Tcl_Command) uintptr)(unsafe.Pointer((tclStubsPtr + 1296 /* &.tcl_GetCommandName */))))(tls, interp, (*Proc)(unsafe.Pointer(procPtr)).cmdPtr)

			if (int32(*(*int8)(unsafe.Pointer(callingCmdName + uintptr(0)))) == 'x') && (int32(*(*int8)(unsafe.Pointer(callingCmdName + uintptr(1)))) == 0) {
				resolvedCmdPtr = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32) Tcl_Command)(unsafe.Pointer((tclIntStubsPtr + 944 /* &.tcl_FindCommand */))))(tls, interp, ts+8806 /* "y" */, (uintptr(0)), 1)
			}
		} else if callerNsPtr != (uintptr(0)) {
			// Case B)
			//
			//    - The context, in which this resolver becomes active, is
			//      determined by the name of the parent namespace, which has
			//      to be named "ctx1" or "ctx2".
			//
			//    - To determine the name of the parent namesace, it is taken
			//      from the 2nd highest stack frame.
			//
			//    - Note that the context can be provided during byte-code
			//      compilation (e.g. in TclProcCompileProc)
			//
			//   When these conditions hold, this function resolves the
			//   passed-in cmd literal into a cmd "y" or "Y" depending on the
			//   context. The resolved procs are taken from the the global
			//   namespace (for simplicity).

			var parentFramePtr uintptr = (*CallFrame)(unsafe.Pointer(varFramePtr)).callerPtr
			var context uintptr
			if parentFramePtr != (uintptr(0)) {
				context = (*Namespace)(unsafe.Pointer((*CallFrame)(unsafe.Pointer(parentFramePtr)).nsPtr)).name
			} else {
				context = ts + 8808 /* "(NULL)" */
			}

			if ((crt.Xstrcmp(tls, context, ts+8815 /* "ctx1" */) == 0) && (int32(*(*int8)(unsafe.Pointer(name + uintptr(0)))) == 'z')) && (int32(*(*int8)(unsafe.Pointer(name + uintptr(1)))) == 0) {
				resolvedCmdPtr = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32) Tcl_Command)(unsafe.Pointer((tclIntStubsPtr + 944 /* &.tcl_FindCommand */))))(tls, interp, ts+8806 /* "y" */, (uintptr(0)), 1)
			} else if ((crt.Xstrcmp(tls, context, ts+8820 /* "ctx2" */) == 0) && (int32(*(*int8)(unsafe.Pointer(name + uintptr(0)))) == 'z')) && (int32(*(*int8)(unsafe.Pointer(name + uintptr(1)))) == 0) {
				resolvedCmdPtr = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32) Tcl_Command)(unsafe.Pointer((tclIntStubsPtr + 944 /* &.tcl_FindCommand */))))(tls, interp, ts+8825 /* "Y" */, (uintptr(0)), 1)
			}
		}

		if resolvedCmdPtr != (uintptr(0)) {
			*(*Tcl_Command)(unsafe.Pointer(rPtr)) = resolvedCmdPtr
			return 0
		}
	}
	return 4
}

func InterpVarResolver(tls *crt.TLS, interp uintptr, name uintptr, context uintptr, flags int32, rPtr uintptr) int32 { /* tclTest.c:7504:1: */
	// Don't resolve the variable; use standard rules.

	return 4
}

type MyResolvedVarInfo1 = struct {
	vInfo   Tcl_ResolvedVarInfo
	__var   Tcl_Var
	nameObj uintptr
}

type MyResolvedVarInfo = MyResolvedVarInfo1 /* tclTest.c:7522:3 */

func HashVarFree(tls *crt.TLS, var1 Tcl_Var) { /* tclTest.c:7525:1: */
	if (*VarInHash)(unsafe.Pointer((var1))).refCount < 2 {
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, (var1))
	} else {
		(*VarInHash)(unsafe.Pointer((var1))).refCount--
	}
}

func MyCompiledVarFree(tls *crt.TLS, vInfoPtr uintptr) { /* tclTest.c:7536:1: */
	var resVarInfo uintptr = vInfoPtr

	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = ((*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).nameObj)
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
		}
	}
	if (*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).__var != 0 {
		HashVarFree(tls, (*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).__var)
	}
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, (vInfoPtr))
}

func MyCompiledVarFetch(tls *crt.TLS, interp uintptr, vinfoPtr uintptr) Tcl_Var { /* tclTest.c:7552:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var resVarInfo uintptr = vinfoPtr
	var var1 Tcl_Var = (*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).__var
	// var isNewVar int32 at bp, 4

	var iPtr uintptr = interp
	var hPtr uintptr

	if var1 != (uintptr(0)) {
		if !(((*Var)(unsafe.Pointer((var1))).flags & 0x8) != 0) {
			// The cached variable is valid, return it.

			return var1
		}

		// The variable is not valid anymore. Clean it up.

		HashVarFree(tls, var1)
	}

	hPtr = (*(*func(*crt.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer((((*Interp)(unsafe.Pointer(iPtr)).globalNsPtr + 248 /* &.varTable */) + 72 /* &.createProc */))))(tls, ((*Interp)(unsafe.Pointer(iPtr)).globalNsPtr + 248 /* &.varTable */), ((*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).nameObj), bp /* &isNewVar */)
	if hPtr != 0 {
		var1 = (hPtr - uintptr((int32(((uintptr(0)) + 24 /* &.entry */)))))
	} else {
		var1 = (uintptr(0))
	}
	(*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).__var = var1

	// Increment the reference counter to avoid ckfree() of the variable in
	// Tcl's FreeVarEntry(); for cleanup, we provide our own HashVarFree();

	(*VarInHash)(unsafe.Pointer((var1))).refCount++
	return var1
}

func InterpCompiledVarResolver(tls *crt.TLS, interp uintptr, name uintptr, length int32, context uintptr, rPtr uintptr) int32 { /* tclTest.c:7597:1: */
	if int32(*(*int8)(unsafe.Pointer(name))) == 'T' {
		var resVarInfo uintptr = ((*(*func(*crt.TLS, uint32) uintptr)(unsafe.Pointer((tclStubsPtr + 40 /* &.tcl_Alloc */))))(tls, (uint32(32))))

		(*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).vInfo.fetchProc = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr) Tcl_Var
		}{MyCompiledVarFetch}))
		(*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).vInfo.deleteProc = *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, uintptr) }{MyCompiledVarFree}))
		(*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).__var = (uintptr(0))
		(*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).nameObj = (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, name, -1)
		(*Tcl_Obj)(unsafe.Pointer(((*MyResolvedVarInfo)(unsafe.Pointer(resVarInfo)).nameObj))).refCount++
		*(*uintptr)(unsafe.Pointer(rPtr)) = (resVarInfo /* &.vInfo */)
		return 0
	}
	return 4
}

func TestInterpResolverCmd(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTest.c:7619:1: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var idx int32 at bp+32, 4

	if (objc < 2) || (objc > 3) {
		(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+8827 /* "up|down ?interp?" */)
		return 1
	}
	if objc == 3 {
		interp = (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1392 /* &.tcl_GetSlave */))))(tls, interp, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))))
		if interp == (uintptr(0)) {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+8844 /* "provided interpr..." */, (uintptr(0))))
			return 1
		}
	}
	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 2448 /* &.tcl_GetIndexFromObjStruct */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), uintptr(unsafe.Pointer(&table)), int32(8), ts+8875 /* "operation" */, 1, bp+32 /* &idx */) != 0 {
		return 1
	}
	switch *(*int32)(unsafe.Pointer(bp + 32 /* idx */)) {
	case 1: // up
		(*(*func(*crt.TLS, uintptr, uintptr, uintptr, uintptr, uintptr))(unsafe.Pointer((tclIntStubsPtr + 904 /* &.tcl_AddInterpResolvers */))))(tls, interp, ts+8885 /* "testInterpResolv..." */, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
		}{InterpCmdResolver})),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
			}{InterpVarResolver})), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*crt.TLS, uintptr, uintptr, int32, uintptr, uintptr) int32
			}{InterpCompiledVarResolver})))
		break
	case 0: //down
		if !((*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((tclIntStubsPtr + 1056 /* &.tcl_RemoveInterpResolvers */))))(tls, interp, ts+8885 /* "testInterpResolv..." */) != 0) {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+16, ts+8904, /* "could not remove..." */
				(uintptr(0))))
			return 1
		}
	}
	return 0
}

var table = [3]uintptr{
	ts + 8941 /* "down" */, ts + 8946 /* "up" */, (uintptr(0)),
} /* tclTest.c:7625:23 */

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// tab-width: 8
// indent-tabs-mode: nil
// End:

// Inline function declarations:

// Slot 69 is reserved
// Slot 70 is reserved
// Slot 71 is reserved
// Slot 72 is reserved
// Slot 77 is reserved
// Slot 79 is reserved

// !END!: Do not edit above this line.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// tclInt.h --
//
//	Declarations of things used internally by the Tcl interpreter.
//
// Copyright (c) 1987-1993 The Regents of the University of California.
// Copyright (c) 1993-1997 Lucent Technologies.
// Copyright (c) 1994-1998 Sun Microsystems, Inc.
// Copyright (c) 1998-1999 by Scriptics Corporation.
// Copyright (c) 2001, 2002 by Kevin B. Kenny.  All rights reserved.
// Copyright (c) 2007 Daniel A. Steffen <das@users.sourceforge.net>
// Copyright (c) 2006-2008 by Joe Mistachkin.  All rights reserved.
// Copyright (c) 2008 by Miguel Sofer. All rights reserved.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// super class file for PK algos

// default ... include all MPI

// RSA only (does not support DH/DSA/ECC)
// #define SC_RSA_1
// #define SC_RSA_1_WITH_TESTS

// For reference.... On an Athlon64 optimizing for speed...
//
//   LTM's mpi.o with all functions [striped] is 142KiB in size.
//

// Works for RSA only, mpi.o is 68KiB
// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// super class file for PK algos

// default ... include all MPI

// RSA only (does not support DH/DSA/ECC)
// #define SC_RSA_1
// #define SC_RSA_1_WITH_TESTS

// For reference.... On an Athlon64 optimizing for speed...
//
//   LTM's mpi.o with all functions [striped] is 142KiB in size.
//

// Works for RSA only, mpi.o is 68KiB
// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// super class file for PK algos

// default ... include all MPI

// RSA only (does not support DH/DSA/ECC)
// #define SC_RSA_1
// #define SC_RSA_1_WITH_TESTS

// For reference.... On an Athlon64 optimizing for speed...
//
//   LTM's mpi.o with all functions [striped] is 142KiB in size.
//

// Works for RSA only, mpi.o is 68KiB
// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// tclStringRep.h --
//
//	This file contains the definition of the Unicode string internal
//	representation and macros to access it.
//
//	A Unicode string is an internationalized string. Conceptually, a
//	Unicode string is an array of 16-bit quantities organized as a
//	sequence of properly formed UTF-8 characters. There is a one-to-one
//	map between Unicode and UTF characters. Because Unicode characters
//	have a fixed width, operations such as indexing operate on Unicode
//	data. The String object is optimized for the case where each UTF char
//	in a string is only one byte. In this case, we store the value of
//	numChars, but we don't store the Unicode data (unless Tcl_GetUnicode
//	is explicitly called).
//
//	The String object type stores one or both formats. The default
//	behavior is to store UTF. Once Unicode is calculated by a function, it
//	is stored in the internal rep for future access (without an additional
//	O(n) cost).
//
//	To allow many appends to be done to an object without constantly
//	reallocating the space for the string or Unicode representation, we
//	allocate double the space for the string or Unicode and use the
//	internal representation to keep track of how much space is used vs.
//	allocated.
//
// Copyright (c) 1995-1997 Sun Microsystems, Inc.
// Copyright (c) 1999 by Scriptics Corporation.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// The following structure is the internal rep for a String object. It keeps
// track of how much memory has been used and how much has been allocated for
// the Unicode and UTF string to enable growing and shrinking of the UTF and
// Unicode reps of the String object with fewer mallocs. To optimize string
// length and indexing operations, this structure also stores the number of
// characters (same of UTF and Unicode!) once that value has been computed.
//
// Under normal configurations, what Tcl calls "Unicode" is actually UTF-16
// restricted to the Basic Multilingual Plane (i.e. U+00000 to U+0FFFF). This
// can be officially modified by altering the definition of Tcl_UniChar in
// tcl.h, but do not do that unless you are sure what you're doing!

type String1 = struct {
	numChars   int32
	allocated  int32
	maxChars   int32
	hasUnicode int32
	unicode    [1]Tcl_UniChar
	_          [2]byte
}

// Inline function declarations:

// Slot 69 is reserved
// Slot 70 is reserved
// Slot 71 is reserved
// Slot 72 is reserved
// Slot 77 is reserved
// Slot 79 is reserved

// !END!: Do not edit above this line.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// tclInt.h --
//
//	Declarations of things used internally by the Tcl interpreter.
//
// Copyright (c) 1987-1993 The Regents of the University of California.
// Copyright (c) 1993-1997 Lucent Technologies.
// Copyright (c) 1994-1998 Sun Microsystems, Inc.
// Copyright (c) 1998-1999 by Scriptics Corporation.
// Copyright (c) 2001, 2002 by Kevin B. Kenny.  All rights reserved.
// Copyright (c) 2007 Daniel A. Steffen <das@users.sourceforge.net>
// Copyright (c) 2006-2008 by Joe Mistachkin.  All rights reserved.
// Copyright (c) 2008 by Miguel Sofer. All rights reserved.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// super class file for PK algos

// default ... include all MPI

// RSA only (does not support DH/DSA/ECC)
// #define SC_RSA_1
// #define SC_RSA_1_WITH_TESTS

// For reference.... On an Athlon64 optimizing for speed...
//
//   LTM's mpi.o with all functions [striped] is 142KiB in size.
//

// Works for RSA only, mpi.o is 68KiB
// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// super class file for PK algos

// default ... include all MPI

// RSA only (does not support DH/DSA/ECC)
// #define SC_RSA_1
// #define SC_RSA_1_WITH_TESTS

// For reference.... On an Athlon64 optimizing for speed...
//
//   LTM's mpi.o with all functions [striped] is 142KiB in size.
//

// Works for RSA only, mpi.o is 68KiB
// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// super class file for PK algos

// default ... include all MPI

// RSA only (does not support DH/DSA/ECC)
// #define SC_RSA_1
// #define SC_RSA_1_WITH_TESTS

// For reference.... On an Athlon64 optimizing for speed...
//
//   LTM's mpi.o with all functions [striped] is 142KiB in size.
//

// Works for RSA only, mpi.o is 68KiB
// LibTomMath, multiple-precision integer library -- Tom St Denis
// SPDX-License-Identifier: Unlicense

// tclStringRep.h --
//
//	This file contains the definition of the Unicode string internal
//	representation and macros to access it.
//
//	A Unicode string is an internationalized string. Conceptually, a
//	Unicode string is an array of 16-bit quantities organized as a
//	sequence of properly formed UTF-8 characters. There is a one-to-one
//	map between Unicode and UTF characters. Because Unicode characters
//	have a fixed width, operations such as indexing operate on Unicode
//	data. The String object is optimized for the case where each UTF char
//	in a string is only one byte. In this case, we store the value of
//	numChars, but we don't store the Unicode data (unless Tcl_GetUnicode
//	is explicitly called).
//
//	The String object type stores one or both formats. The default
//	behavior is to store UTF. Once Unicode is calculated by a function, it
//	is stored in the internal rep for future access (without an additional
//	O(n) cost).
//
//	To allow many appends to be done to an object without constantly
//	reallocating the space for the string or Unicode representation, we
//	allocate double the space for the string or Unicode and use the
//	internal representation to keep track of how much space is used vs.
//	allocated.
//
// Copyright (c) 1995-1997 Sun Microsystems, Inc.
// Copyright (c) 1999 by Scriptics Corporation.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// The following structure is the internal rep for a String object. It keeps
// track of how much memory has been used and how much has been allocated for
// the Unicode and UTF string to enable growing and shrinking of the UTF and
// Unicode reps of the String object with fewer mallocs. To optimize string
// length and indexing operations, this structure also stores the number of
// characters (same of UTF and Unicode!) once that value has been computed.
//
// Under normal configurations, what Tcl calls "Unicode" is actually UTF-16
// restricted to the Basic Multilingual Plane (i.e. U+00000 to U+0FFFF). This
// can be officially modified by altering the definition of Tcl_UniChar in
// tcl.h, but do not do that unless you are sure what you're doing!

type String = String1 /* tclStringRep.h:65:3 */

func VarPtrDeleteProc(tls *crt.TLS, clientData ClientData, interp uintptr) { /* tclTestObj.c:54:13: */
	var i int32
	var varPtr uintptr = clientData
	for i = 0; i < 20; i++ {
		if *(*uintptr)(unsafe.Pointer(varPtr + uintptr(i)*8)) != 0 {
			for ok := true; ok; ok = 0 != 0 {
				var _objPtr uintptr = (*(*uintptr)(unsafe.Pointer(varPtr + uintptr(i)*8)))
				if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
					(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
				}
			}
		}
	}
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 816 /* &.tcl_DeleteAssocData */))))(tls, interp, ts+8949 /* "TCLOBJTEST_VARPT..." */)
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, (varPtr))
}

func GetVarPtr(tls *crt.TLS, interp uintptr) uintptr { /* tclTestObj.c:65:16: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var proc uintptr at bp, 8

	return (*(*func(*crt.TLS, uintptr, uintptr, uintptr) ClientData)(unsafe.Pointer((tclStubsPtr + 1216 /* &.tcl_GetAssocData */))))(tls, interp, ts+8949 /* "TCLOBJTEST_VARPT..." */, bp /* &proc */)
}

//----------------------------------------------------------------------
//
// TclObjTest_Init --
//
//	This function creates additional commands that are used to test the
//	Tcl object support.
//
// Results:
//	Returns a standard Tcl completion code, and leaves an error
//	message in the interp's result if an error occurs.
//
// Side effects:
//	Creates and registers several new testing commands.
//
//----------------------------------------------------------------------

func TclObjTest_Init(tls *crt.TLS, interp uintptr) int32 { /* tclTestObj.c:91:1: */
	var i int32
	// An array of Tcl_Obj pointers used in the commands that operate on or get
	// the values of Tcl object-valued variables. varPtr[i] is the i-th variable's
	// Tcl_Obj *.
	var varPtr uintptr

	varPtr = ((*(*func(*crt.TLS, uint32) uintptr)(unsafe.Pointer((tclStubsPtr + 40 /* &.tcl_Alloc */))))(tls, (uint32(uint64(20) * 8))))
	if !(varPtr != 0) {
		return 1
	}
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData))(unsafe.Pointer((tclStubsPtr + 1800 /* &.tcl_SetAssocData */))))(tls, interp, ts+8949 /* "TCLOBJTEST_VARPT..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr)
	}{VarPtrDeleteProc})), varPtr)
	for i = 0; i < 20; i++ {
		*(*uintptr)(unsafe.Pointer(varPtr + uintptr(i)*8)) = (uintptr(0))
	}

	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+8967 /* "testbignumobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestbignumobjCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+8981 /* "testbooleanobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestbooleanobjCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+8996 /* "testdoubleobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestdoubleobjCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+9010 /* "testintobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestintobjCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+9021 /* "testindexobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestindexobjCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+9034 /* "testlistobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestlistobjCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+9046 /* "testobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestobjCmd})), (uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+9054 /* "teststringobj" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TeststringobjCmd})),
		(uintptr(0)), (uintptr(0)))
	return 0
}

//----------------------------------------------------------------------
//
// TestbignumobjCmd --
//
//	This function implements the "testbignumobj" command.  It is used
//	to exercise the bignum Tcl object type implementation.
//
// Results:
//	Returns a standard Tcl object result.
//
// Side effects:
//	Creates and frees bignum objects; converts objects to have bignum
//	type.
//
//----------------------------------------------------------------------

func TestbignumobjCmd(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestObj.c:148:1: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	*(*[7]uintptr)(unsafe.Pointer(bp /* subcmds */)) = [7]uintptr{
		ts + 4166 /* "set" */, ts + 1535 /* "get" */, ts + 9068 /* "mult10" */, ts + 9075 /* "div10" */, ts + 9081 /* "iseven" */, ts + 9088 /* "radixsize" */, (uintptr(0)),
	}
	const ( /* tclTestObj.c:157:5: */
		BIGNUM_SET       = 0
		BIGNUM_GET       = 1
		BIGNUM_MULT10    = 2
		BIGNUM_DIV10     = 3
		BIGNUM_ISEVEN    = 4
		BIGNUM_RADIXSIZE = 5
	)
	// var index int32 at bp+56, 4

	// var varIndex int32 at bp+60, 4

	var string uintptr
	// var bignumValue mp_int at bp+64, 24

	// var newValue mp_int at bp+88, 24

	var varPtr uintptr

	if objc < 3 {
		(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+9098 /* "option ?arg ...?" */)
		return 1
	}
	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 2448 /* &.tcl_GetIndexFromObjStruct */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp /* &subcmds */, int32(8), ts+3361 /* "option" */, 0, bp+56 /* &index */) != 0 {
		return 1
	}
	string = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if GetVariableIndex(tls, interp, string, bp+60 /* &varIndex */) != 0 {
		return 1
	}
	varPtr = GetVarPtr(tls, interp)

	switch *(*int32)(unsafe.Pointer(bp + 56 /* index */)) {
	case BIGNUM_SET:
		if objc != 4 {
			(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 2, objv, ts+9115 /* "var value" */)
			return 1
		}
		string = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
		if (*(*func(*crt.TLS, uintptr) mp_err)(unsafe.Pointer((tclTomMathStubsPtr + 184 /* &.tclBN_mp_init */))))(tls, bp+64 /* &bignumValue */) != 0 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp,
				(*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, ts+9125 /* "error in mp_init" */, -1))
			return 1
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, int32) mp_err)(unsafe.Pointer((tclTomMathStubsPtr + 304 /* &.tclBN_mp_read_radix */))))(tls, bp+64 /* &bignumValue */, string, 10) != 0 {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclTomMathStubsPtr + 64 /* &.tclBN_mp_clear */))))(tls, bp+64 /* &bignumValue */)
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp,
				(*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, ts+9142 /* "error in mp_read..." */, -1))
			return 1
		}

		// If the object currently bound to the variable with index varIndex
		// has ref count 1 (i.e. the object is unshared) we can modify that
		// object directly.  Otherwise, if RC>1 (i.e. the object is shared),
		// we must create a new object to modify/set and decrement the old
		// formerly-shared object's ref count. This is "copy on write".

		if (*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8)) != (uintptr(0))) && !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8))))).refCount > 1) {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 4472 /* &.tcl_SetBignumObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8)), bp+64 /* &bignumValue */)
		} else {
			SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)), (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 4456 /* &.tcl_NewBignumObj */))))(tls, bp+64 /* &bignumValue */))
		}
		break

	case BIGNUM_GET:
		if objc != 3 {
			(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 2, objv, ts+9165 /* "varIndex" */)
			return 1
		}
		if CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 60 /* varIndex */))) != 0 {
			return 1
		}
		break

	case BIGNUM_MULT10:
		if objc != 3 {
			(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 2, objv, ts+9165 /* "varIndex" */)
			return 1
		}
		if CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 60 /* varIndex */))) != 0 {
			return 1
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 4480 /* &.tcl_GetBignumFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8)),
			bp+64 /* &bignumValue */) != 0 {
			return 1
		}
		if ((*(*func(*crt.TLS, uintptr) mp_err)(unsafe.Pointer((tclTomMathStubsPtr + 184 /* &.tclBN_mp_init */))))(tls, bp+88 /* &newValue */) != 0) ||
			((*(*func(*crt.TLS, uintptr, mp_digit, uintptr) mp_err)(unsafe.Pointer((tclTomMathStubsPtr + 256 /* &.tclBN_mp_mul_d */))))(tls, bp+64 /* &bignumValue */, uint32(10), bp+88 /* &newValue */) != 0) {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclTomMathStubsPtr + 64 /* &.tclBN_mp_clear */))))(tls, bp+64 /* &bignumValue */)
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclTomMathStubsPtr + 64 /* &.tclBN_mp_clear */))))(tls, bp+88 /* &newValue */)
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp,
				(*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, ts+9174 /* "error in mp_mul_..." */, -1))
			return 1
		}
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclTomMathStubsPtr + 64 /* &.tclBN_mp_clear */))))(tls, bp+64 /* &bignumValue */)
		if !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8))))).refCount > 1) {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 4472 /* &.tcl_SetBignumObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8)), bp+88 /* &newValue */)
		} else {
			SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)), (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 4456 /* &.tcl_NewBignumObj */))))(tls, bp+88 /* &newValue */))
		}
		break

	case BIGNUM_DIV10:
		if objc != 3 {
			(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 2, objv, ts+9165 /* "varIndex" */)
			return 1
		}
		if CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 60 /* varIndex */))) != 0 {
			return 1
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 4480 /* &.tcl_GetBignumFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8)),
			bp+64 /* &bignumValue */) != 0 {
			return 1
		}
		if ((*(*func(*crt.TLS, uintptr) mp_err)(unsafe.Pointer((tclTomMathStubsPtr + 184 /* &.tclBN_mp_init */))))(tls, bp+88 /* &newValue */) != 0) ||
			((*(*func(*crt.TLS, uintptr, mp_digit, uintptr, uintptr) mp_err)(unsafe.Pointer((tclTomMathStubsPtr + 128 /* &.tclBN_mp_div_d */))))(tls, bp+64 /* &bignumValue */, uint32(10), bp+88 /* &newValue */, (uintptr(0))) != 0) {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclTomMathStubsPtr + 64 /* &.tclBN_mp_clear */))))(tls, bp+64 /* &bignumValue */)
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclTomMathStubsPtr + 64 /* &.tclBN_mp_clear */))))(tls, bp+88 /* &newValue */)
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp,
				(*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, ts+9192 /* "error in mp_div_..." */, -1))
			return 1
		}
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclTomMathStubsPtr + 64 /* &.tclBN_mp_clear */))))(tls, bp+64 /* &bignumValue */)
		if !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8))))).refCount > 1) {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 4472 /* &.tcl_SetBignumObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8)), bp+88 /* &newValue */)
		} else {
			SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)), (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 4456 /* &.tcl_NewBignumObj */))))(tls, bp+88 /* &newValue */))
		}
		break

	case BIGNUM_ISEVEN:
		if objc != 3 {
			(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 2, objv, ts+9165 /* "varIndex" */)
			return 1
		}
		if CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 60 /* varIndex */))) != 0 {
			return 1
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 4480 /* &.tcl_GetBignumFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8)),
			bp+64 /* &bignumValue */) != 0 {
			return 1
		}
		if !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8))))).refCount > 1) {
			(*(*func(*crt.TLS, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 504 /* &.tcl_SetIntObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8)), crt.BoolInt32(!(func() int32 {
				if ((*mp_int)(unsafe.Pointer((bp + 64 /* &bignumValue */))).used != 0) && ((*(*mp_digit)(unsafe.Pointer((*mp_int)(unsafe.Pointer((bp + 64 /* &bignumValue */))).dp + uintptr(0)*4)) & mp_digit(1)) == mp_digit(1)) {
					return 1
				}
				return 0
			}() != 0)))
		} else {
			SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)), (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, crt.BoolInt32(!(func() int32 {
				if ((*mp_int)(unsafe.Pointer((bp + 64 /* &bignumValue */))).used != 0) && ((*(*mp_digit)(unsafe.Pointer((*mp_int)(unsafe.Pointer((bp + 64 /* &bignumValue */))).dp + uintptr(0)*4)) & mp_digit(1)) == mp_digit(1)) {
					return 1
				}
				return 0
			}() != 0))))
		}
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclTomMathStubsPtr + 64 /* &.tclBN_mp_clear */))))(tls, bp+64 /* &bignumValue */)
		break

	case BIGNUM_RADIXSIZE:
		if objc != 3 {
			(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 2, objv, ts+9165 /* "varIndex" */)
			return 1
		}
		if CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 60 /* varIndex */))) != 0 {
			return 1
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 4480 /* &.tcl_GetBignumFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8)),
			bp+64 /* &bignumValue */) != 0 {
			return 1
		}
		if (*(*func(*crt.TLS, uintptr, int32, uintptr) mp_err)(unsafe.Pointer((tclTomMathStubsPtr + 296 /* &.tclBN_mp_radix_size */))))(tls, bp+64 /* &bignumValue */, 10, bp+56 /* &index */) != 0 {
			return 1
		}
		if !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8))))).refCount > 1) {
			(*(*func(*crt.TLS, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 504 /* &.tcl_SetIntObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8)), *(*int32)(unsafe.Pointer(bp + 56 /* index */)))
		} else {
			SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)), (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, *(*int32)(unsafe.Pointer(bp + 56 /* index */))))
		}
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclTomMathStubsPtr + 64 /* &.tclBN_mp_clear */))))(tls, bp+64 /* &bignumValue */)
		break
	}

	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* varIndex */)))*8)))
	return 0
}

//----------------------------------------------------------------------
//
// TestbooleanobjCmd --
//
//	This function implements the "testbooleanobj" command.  It is used to
//	test the boolean Tcl object type implementation.
//
// Results:
//	A standard Tcl object result.
//
// Side effects:
//	Creates and frees boolean objects, and also converts objects to
//	have boolean type.
//
//----------------------------------------------------------------------

func TestbooleanobjCmd(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestObj.c:347:1: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var varIndex int32 at bp+32, 4

	// var boolValue int32 at bp+36, 4

	var index uintptr
	var subCmd uintptr
	var varPtr uintptr

	if !(objc < 3) {
		goto __1
	}
wrongNumArgs:
	(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+9210 /* "option arg ?arg ..." */)
	return 1
__1:
	;

	index = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if !(GetVariableIndex(tls, interp, index, bp+32 /* &varIndex */) != 0) {
		goto __2
	}
	return 1
__2:
	;

	varPtr = GetVarPtr(tls, interp)

	subCmd = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	if !(crt.Xstrcmp(tls, subCmd, ts+4166 /* "set" */) == 0) {
		goto __3
	}
	if !(objc != 4) {
		goto __5
	}
	goto wrongNumArgs
__5:
	;
	if !((*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 272 /* &.tcl_GetBooleanFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+36 /* &boolValue */) != 0) {
		goto __6
	}
	return 1
__6:
	;

	// If the object currently bound to the variable with index varIndex
	// has ref count 1 (i.e. the object is unshared) we can modify that
	// object directly. Otherwise, if RC>1 (i.e. the object is shared),
	// we must create a new object to modify/set and decrement the old
	// formerly-shared object's ref count. This is "copy on write".

	if !((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)) != (uintptr(0))) && !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8))))).refCount > 1)) {
		goto __7
	}
	(*(*func(*crt.TLS, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 504 /* &.tcl_SetIntObj */))))(tls, (*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8))), (crt.Bool32((*(*int32)(unsafe.Pointer(bp + 36 /* boolValue */))) != 0)))
	goto __8
__7:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, (crt.Bool32((*(*int32)(unsafe.Pointer(bp + 36 /* boolValue */))) != 0))))
__8:
	;
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __4
__3:
	if !(crt.Xstrcmp(tls, subCmd, ts+1535 /* "get" */) == 0) {
		goto __9
	}
	if !(objc != 3) {
		goto __11
	}
	goto wrongNumArgs
__11:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */))) != 0) {
		goto __12
	}
	return 1
__12:
	;
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __10
__9:
	if !(crt.Xstrcmp(tls, subCmd, ts+9231 /* "not" */) == 0) {
		goto __13
	}
	if !(objc != 3) {
		goto __15
	}
	goto wrongNumArgs
__15:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */))) != 0) {
		goto __16
	}
	return 1
__16:
	;
	if !((*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 272 /* &.tcl_GetBooleanFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)),
		bp+36 /* &boolValue */) != 0) {
		goto __17
	}
	return 1
__17:
	;
	if !(!((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8))))).refCount > 1)) {
		goto __18
	}
	(*(*func(*crt.TLS, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 504 /* &.tcl_SetIntObj */))))(tls, (*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8))), (crt.Bool32((crt.BoolInt32(!(*(*int32)(unsafe.Pointer(bp + 36 /* boolValue */)) != 0))) != 0)))
	goto __19
__18:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, (crt.Bool32((crt.BoolInt32(!(*(*int32)(unsafe.Pointer(bp + 36 /* boolValue */)) != 0))) != 0))))
__19:
	;
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __14
__13:
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 136 /* &.tcl_AppendStringsToObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp),
		crt.VaList(bp, ts+1429 /* "bad option \"" */, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))),
			ts+9235 /* "\": must be set, ..." */, (uintptr(0))))
	return 1
__14:
	;
__10:
	;
__4:
	;
	return 0
}

//----------------------------------------------------------------------
//
// TestdoubleobjCmd --
//
//	This function implements the "testdoubleobj" command.  It is used to
//	test the double-precision floating point Tcl object type
//	implementation.
//
// Results:
//	A standard Tcl object result.
//
// Side effects:
//	Creates and frees double objects, and also converts objects to
//	have double type.
//
//----------------------------------------------------------------------

func TestdoubleobjCmd(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestObj.c:447:1: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// var varIndex int32 at bp+32, 4

	// var doubleValue float64 at bp+40, 8

	var index uintptr
	var subCmd uintptr
	var string uintptr
	var varPtr uintptr

	if !(objc < 3) {
		goto __1
	}
wrongNumArgs:
	(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+9210 /* "option arg ?arg ..." */)
	return 1
__1:
	;

	varPtr = GetVarPtr(tls, interp)

	index = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if !(GetVariableIndex(tls, interp, index, bp+32 /* &varIndex */) != 0) {
		goto __2
	}
	return 1
__2:
	;

	subCmd = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	if !(crt.Xstrcmp(tls, subCmd, ts+4166 /* "set" */) == 0) {
		goto __3
	}
	if !(objc != 4) {
		goto __5
	}
	goto wrongNumArgs
__5:
	;
	string = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
	if !((*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 288 /* &.tcl_GetDouble */))))(tls, interp, string, bp+40 /* &doubleValue */) != 0) {
		goto __6
	}
	return 1
__6:
	;

	// If the object currently bound to the variable with index varIndex
	// has ref count 1 (i.e. the object is unshared) we can modify that
	// object directly. Otherwise, if RC>1 (i.e. the object is shared), we
	// must create a new object to modify/set and decrement the old
	// formerly-shared object's ref count. This is "copy on write".

	if !((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)) != (uintptr(0))) && !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8))))).refCount > 1)) {
		goto __7
	}
	(*(*func(*crt.TLS, uintptr, float64))(unsafe.Pointer((tclStubsPtr + 496 /* &.tcl_SetDoubleObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), *(*float64)(unsafe.Pointer(bp + 40 /* doubleValue */)))
	goto __8
__7:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*(*func(*crt.TLS, float64) uintptr)(unsafe.Pointer((tclStubsPtr + 424 /* &.tcl_NewDoubleObj */))))(tls, *(*float64)(unsafe.Pointer(bp + 40 /* doubleValue */))))
__8:
	;
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __4
__3:
	if !(crt.Xstrcmp(tls, subCmd, ts+1535 /* "get" */) == 0) {
		goto __9
	}
	if !(objc != 3) {
		goto __11
	}
	goto wrongNumArgs
__11:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */))) != 0) {
		goto __12
	}
	return 1
__12:
	;
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __10
__9:
	if !(crt.Xstrcmp(tls, subCmd, ts+9068 /* "mult10" */) == 0) {
		goto __13
	}
	if !(objc != 3) {
		goto __15
	}
	goto wrongNumArgs
__15:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */))) != 0) {
		goto __16
	}
	return 1
__16:
	;
	if !((*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 296 /* &.tcl_GetDoubleFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)),
		bp+40 /* &doubleValue */) != 0) {
		goto __17
	}
	return 1
__17:
	;
	if !(!((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8))))).refCount > 1)) {
		goto __18
	}
	(*(*func(*crt.TLS, uintptr, float64))(unsafe.Pointer((tclStubsPtr + 496 /* &.tcl_SetDoubleObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), (*(*float64)(unsafe.Pointer(bp + 40 /* doubleValue */)) * 10.0))
	goto __19
__18:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*(*func(*crt.TLS, float64) uintptr)(unsafe.Pointer((tclStubsPtr + 424 /* &.tcl_NewDoubleObj */))))(tls, (*(*float64)(unsafe.Pointer(bp + 40 /* doubleValue */))*10.0)))
__19:
	;
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __14
__13:
	if !(crt.Xstrcmp(tls, subCmd, ts+9075 /* "div10" */) == 0) {
		goto __20
	}
	if !(objc != 3) {
		goto __22
	}
	goto wrongNumArgs
__22:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */))) != 0) {
		goto __23
	}
	return 1
__23:
	;
	if !((*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 296 /* &.tcl_GetDoubleFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)),
		bp+40 /* &doubleValue */) != 0) {
		goto __24
	}
	return 1
__24:
	;
	if !(!((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8))))).refCount > 1)) {
		goto __25
	}
	(*(*func(*crt.TLS, uintptr, float64))(unsafe.Pointer((tclStubsPtr + 496 /* &.tcl_SetDoubleObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), (*(*float64)(unsafe.Pointer(bp + 40 /* doubleValue */)) / 10.0))
	goto __26
__25:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*(*func(*crt.TLS, float64) uintptr)(unsafe.Pointer((tclStubsPtr + 424 /* &.tcl_NewDoubleObj */))))(tls, (*(*float64)(unsafe.Pointer(bp + 40 /* doubleValue */))/10.0)))
__26:
	;
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __21
__20:
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 136 /* &.tcl_AppendStringsToObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp),
		crt.VaList(bp, ts+1429 /* "bad option \"" */, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))),
			ts+9263 /* "\": must be set, ..." */, (uintptr(0))))
	return 1
__21:
	;
__14:
	;
__10:
	;
__4:
	;
	return 0
}

//----------------------------------------------------------------------
//
// TestindexobjCmd --
//
//	This function implements the "testindexobj" command. It is used to
//	test the index Tcl object type implementation.
//
// Results:
//	A standard Tcl object result.
//
// Side effects:
//	Creates and frees int objects, and also converts objects to
//	have int type.
//
//----------------------------------------------------------------------

func TestindexobjCmd(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestObj.c:565:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var allowAbbrev int32 at bp+12, 4

	// var index int32 at bp+4, 4

	// var index2 int32 at bp, 4

	// var setError int32 at bp+8, 4

	var i int32
	var result int32
	var argv uintptr
	var indexRep uintptr

	if (objc == 3) && (crt.Xstrcmp(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))),
		ts+9301 /* "check" */) == 0) {
		// This code checks to be sure that the results of Tcl_GetIndexFromObj
		// are properly cached in the object and returned on subsequent
		// lookups.

		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 320 /* &.tcl_GetIntFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp /* &index2 */) != 0 {
			return 1
		}

		(*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 2448 /* &.tcl_GetIndexFromObjStruct */))))(tls, (uintptr(0)), *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), uintptr(unsafe.Pointer(&tablePtr)), int32(8), ts+9307 /* "token" */, 0, bp+4 /* &index */)
		indexRep = (*struct {
			ptr1 uintptr
			ptr2 uintptr
		})(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)) + 32 /* &.internalRep */)).ptr1
		(*IndexRep)(unsafe.Pointer(indexRep)).index = *(*int32)(unsafe.Pointer(bp /* index2 */))
		result = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 2448 /* &.tcl_GetIndexFromObjStruct */))))(tls, (uintptr(0)), *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), uintptr(unsafe.Pointer(&tablePtr)), int32(8), ts+9307 /* "token" */, 0, bp+4 /* &index */)
		if result == 0 {
			(*(*func(*crt.TLS, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 504 /* &.tcl_SetIntObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp), *(*int32)(unsafe.Pointer(bp + 4 /* index */)))
		}
		return result
	}

	if objc < 5 {
		(*(*func(*crt.TLS, uintptr, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 144 /* &.tcl_AppendToObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp), ts+1397 /* "wrong # args" */, -1)
		return 1
	}

	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 272 /* &.tcl_GetBooleanFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+8 /* &setError */) != 0 {
		return 1
	}
	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 272 /* &.tcl_GetBooleanFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)), bp+12 /* &allowAbbrev */) != 0 {
		return 1
	}

	argv = ((*(*func(*crt.TLS, uint32) uintptr)(unsafe.Pointer((tclStubsPtr + 40 /* &.tcl_Alloc */))))(tls, (uint32((uint64(objc - 3)) * 8))))
	for i = 4; i < objc; i++ {
		*(*uintptr)(unsafe.Pointer(argv + uintptr((i-4))*8)) = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)))
	}
	*(*uintptr)(unsafe.Pointer(argv + uintptr((objc-4))*8)) = (uintptr(0))

	// Tcl_GetIndexFromObj assumes that the table is statically-allocated so
	// that its address is different for each index object. If we accidently
	// allocate a table at the same address as that cached in the index
	// object, clear out the object's cached state.

	if ((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))).typePtr != (uintptr(0))) &&
		!(crt.Xstrcmp(tls, ts+9313 /* "index" */, (*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))).typePtr)).name) != 0) {
		indexRep = (*struct {
			ptr1 uintptr
			ptr2 uintptr
		})(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)) + 32 /* &.internalRep */)).ptr1
		if (*IndexRep)(unsafe.Pointer(indexRep)).tablePtr == argv {
			if (*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8))))).typePtr != (uintptr(0)) {
				if (*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8))))).typePtr)).freeIntRepProc != (uintptr(0)) {
					(*(*func(*crt.TLS, uintptr))(unsafe.Pointer(((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8))))).typePtr + 8 /* &.freeIntRepProc */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
				}
				(*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8))))).typePtr = (uintptr(0))
			}
		}
	}

	result = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 2448 /* &.tcl_GetIndexFromObjStruct */))))(tls, (func() uintptr {
		if *(*int32)(unsafe.Pointer(bp + 8 /* setError */)) != 0 {
			return interp
		}
		return (uintptr(0))
	}()), *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), argv, int32(8), ts+9307 /* "token" */, (func() int32 {
		if *(*int32)(unsafe.Pointer(bp + 12 /* allowAbbrev */)) != 0 {
			return 0
		}
		return 1
	}()), bp+4 /* &index */)
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 48 /* &.tcl_Free */))))(tls, (argv))
	if result == 0 {
		(*(*func(*crt.TLS, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 504 /* &.tcl_SetIntObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp), *(*int32)(unsafe.Pointer(bp + 4 /* index */)))
	}
	return result
}

// Keep this structure declaration in sync with tclIndexObj.c
type IndexRep = struct {
	tablePtr uintptr
	offset   int32
	index    int32
}

var tablePtr = [4]uintptr{ts + 5902 /* "a" */, ts + 7417 /* "b" */, ts + 9301 /* "check" */, (uintptr(0))} /* tclTestObj.c:573:23 */

//----------------------------------------------------------------------
//
// TestintobjCmd --
//
//	This function implements the "testintobj" command. It is used to
//	test the int Tcl object type implementation.
//
// Results:
//	A standard Tcl object result.
//
// Side effects:
//	Creates and frees int objects, and also converts objects to
//	have int type.
//
//----------------------------------------------------------------------

func TestintobjCmd(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestObj.c:668:1: */
	bp := tls.Alloc(52)
	defer tls.Free(52)

	// var intValue int32 at bp+48, 4

	// var varIndex int32 at bp+32, 4

	// var i int32 at bp+36, 4

	// var longValue int64 at bp+40, 8

	var index uintptr
	var subCmd uintptr
	var string uintptr
	var varPtr uintptr
	var maxLong int64

	if !(objc < 3) {
		goto __1
	}
wrongNumArgs:
	(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+9210 /* "option arg ?arg ..." */)
	return 1
__1:
	;

	varPtr = GetVarPtr(tls, interp)
	index = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if !(GetVariableIndex(tls, interp, index, bp+32 /* &varIndex */) != 0) {
		goto __2
	}
	return 1
__2:
	;

	subCmd = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	if !(crt.Xstrcmp(tls, subCmd, ts+4166 /* "set" */) == 0) {
		goto __3
	}
	if !(objc != 4) {
		goto __5
	}
	goto wrongNumArgs
__5:
	;
	string = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
	if !((*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, string, bp+36 /* &i */) != 0) {
		goto __6
	}
	return 1
__6:
	;
	*(*int32)(unsafe.Pointer(bp + 48 /* intValue */)) = *(*int32)(unsafe.Pointer(bp + 36 /* i */))

	// If the object currently bound to the variable with index varIndex
	// has ref count 1 (i.e. the object is unshared) we can modify that
	// object directly. Otherwise, if RC>1 (i.e. the object is shared), we
	// must create a new object to modify/set and decrement the old
	// formerly-shared object's ref count. This is "copy on write".

	if !((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)) != (uintptr(0))) && !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8))))).refCount > 1)) {
		goto __7
	}
	(*(*func(*crt.TLS, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 504 /* &.tcl_SetIntObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), *(*int32)(unsafe.Pointer(bp + 48 /* intValue */)))
	goto __8
__7:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, *(*int32)(unsafe.Pointer(bp + 48 /* intValue */))))
__8:
	;
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __4
__3:
	if !(crt.Xstrcmp(tls, subCmd, ts+9319 /* "set2" */) == 0) {
		goto __9
	} // doesn't set result
	if !(objc != 4) {
		goto __11
	}
	goto wrongNumArgs
__11:
	;
	string = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
	if !((*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, string, bp+36 /* &i */) != 0) {
		goto __12
	}
	return 1
__12:
	;
	*(*int32)(unsafe.Pointer(bp + 48 /* intValue */)) = *(*int32)(unsafe.Pointer(bp + 36 /* i */))
	if !((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)) != (uintptr(0))) && !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8))))).refCount > 1)) {
		goto __13
	}
	(*(*func(*crt.TLS, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 504 /* &.tcl_SetIntObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), *(*int32)(unsafe.Pointer(bp + 48 /* intValue */)))
	goto __14
__13:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, *(*int32)(unsafe.Pointer(bp + 48 /* intValue */))))
__14:
	;
	goto __10
__9:
	if !(crt.Xstrcmp(tls, subCmd, ts+9324 /* "setlong" */) == 0) {
		goto __15
	}
	if !(objc != 4) {
		goto __17
	}
	goto wrongNumArgs
__17:
	;
	string = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
	if !((*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, string, bp+36 /* &i */) != 0) {
		goto __18
	}
	return 1
__18:
	;
	*(*int32)(unsafe.Pointer(bp + 48 /* intValue */)) = *(*int32)(unsafe.Pointer(bp + 36 /* i */))
	if !((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)) != (uintptr(0))) && !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8))))).refCount > 1)) {
		goto __19
	}
	(*(*func(*crt.TLS, uintptr, int64))(unsafe.Pointer((tclStubsPtr + 520 /* &.tcl_SetLongObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), int64(*(*int32)(unsafe.Pointer(bp + 48 /* intValue */))))
	goto __20
__19:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*(*func(*crt.TLS, int64) uintptr)(unsafe.Pointer((tclStubsPtr + 448 /* &.tcl_NewLongObj */))))(tls, int64(*(*int32)(unsafe.Pointer(bp + 48 /* intValue */)))))
__20:
	;
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __16
__15:
	if !(crt.Xstrcmp(tls, subCmd, ts+9332 /* "setmaxlong" */) == 0) {
		goto __21
	}
	maxLong = 0x7fffffffffffffff
	if !(objc != 3) {
		goto __23
	}
	goto wrongNumArgs
__23:
	;
	if !((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)) != (uintptr(0))) && !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8))))).refCount > 1)) {
		goto __24
	}
	(*(*func(*crt.TLS, uintptr, int64))(unsafe.Pointer((tclStubsPtr + 520 /* &.tcl_SetLongObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), maxLong)
	goto __25
__24:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*(*func(*crt.TLS, int64) uintptr)(unsafe.Pointer((tclStubsPtr + 448 /* &.tcl_NewLongObj */))))(tls, maxLong))
__25:
	;
	goto __22
__21:
	if !(crt.Xstrcmp(tls, subCmd, ts+9343 /* "ismaxlong" */) == 0) {
		goto __26
	}
	if !(objc != 3) {
		goto __28
	}
	goto wrongNumArgs
__28:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */))) != 0) {
		goto __29
	}
	return 1
__29:
	;
	if !((*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 328 /* &.tcl_GetLongFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), bp+40 /* &longValue */) != 0) {
		goto __30
	}
	return 1
__30:
	;
	(*(*func(*crt.TLS, uintptr, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 144 /* &.tcl_AppendToObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp),
		(func() uintptr {
			if *(*int64)(unsafe.Pointer(bp + 40 /* longValue */)) == 0x7fffffffffffffff {
				return ts + 6693 /* "1" */
			}
			return ts + 6695 /* "0" */
		}()), -1)
	goto __27
__26:
	if !(crt.Xstrcmp(tls, subCmd, ts+1535 /* "get" */) == 0) {
		goto __31
	}
	if !(objc != 3) {
		goto __33
	}
	goto wrongNumArgs
__33:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */))) != 0) {
		goto __34
	}
	return 1
__34:
	;
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __32
__31:
	if !(crt.Xstrcmp(tls, subCmd, ts+9353 /* "get2" */) == 0) {
		goto __35
	}
	if !(objc != 3) {
		goto __37
	}
	goto wrongNumArgs
__37:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */))) != 0) {
		goto __38
	}
	return 1
__38:
	;
	string = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	(*(*func(*crt.TLS, uintptr, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 144 /* &.tcl_AppendToObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp), string, -1)
	goto __36
__35:
	if !(crt.Xstrcmp(tls, subCmd, ts+9358 /* "inttoobigtest" */) == 0) {
		goto __39
	}
	// If long ints have more bits than ints on this platform, verify that
	// Tcl_GetIntFromObj returns an error if the long int held in an
	// integer object's internal representation is too large to fit in an
	// int.

	if !(objc != 3) {
		goto __41
	}
	goto wrongNumArgs
__41:
	;
	if !((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)) != (uintptr(0))) && !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8))))).refCount > 1)) {
		goto __42
	}
	(*(*func(*crt.TLS, uintptr, int64))(unsafe.Pointer((tclStubsPtr + 520 /* &.tcl_SetLongObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), 0x7fffffffffffffff)
	goto __43
__42:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*(*func(*crt.TLS, int64) uintptr)(unsafe.Pointer((tclStubsPtr + 448 /* &.tcl_NewLongObj */))))(tls, 0x7fffffffffffffff))
__43:
	;
	if !((*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 320 /* &.tcl_GetIntFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), bp+36 /* &i */) != 0) {
		goto __44
	}
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 1752 /* &.tcl_ResetResult */))))(tls, interp)
	(*(*func(*crt.TLS, uintptr, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 144 /* &.tcl_AppendToObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp), ts+6693 /* "1" */, -1)
	return 0
__44:
	;
	(*(*func(*crt.TLS, uintptr, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 144 /* &.tcl_AppendToObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp), ts+6695 /* "0" */, -1)
	goto __40
__39:
	if !(crt.Xstrcmp(tls, subCmd, ts+9068 /* "mult10" */) == 0) {
		goto __45
	}
	if !(objc != 3) {
		goto __47
	}
	goto wrongNumArgs
__47:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */))) != 0) {
		goto __48
	}
	return 1
__48:
	;
	if !((*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 320 /* &.tcl_GetIntFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)),
		bp+48 /* &intValue */) != 0) {
		goto __49
	}
	return 1
__49:
	;
	if !(!((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8))))).refCount > 1)) {
		goto __50
	}
	(*(*func(*crt.TLS, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 504 /* &.tcl_SetIntObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), (*(*int32)(unsafe.Pointer(bp + 48 /* intValue */)) * 10))
	goto __51
__50:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, (*(*int32)(unsafe.Pointer(bp + 48 /* intValue */))*10)))
__51:
	;
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __46
__45:
	if !(crt.Xstrcmp(tls, subCmd, ts+9075 /* "div10" */) == 0) {
		goto __52
	}
	if !(objc != 3) {
		goto __54
	}
	goto wrongNumArgs
__54:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */))) != 0) {
		goto __55
	}
	return 1
__55:
	;
	if !((*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 320 /* &.tcl_GetIntFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)),
		bp+48 /* &intValue */) != 0) {
		goto __56
	}
	return 1
__56:
	;
	if !(!((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8))))).refCount > 1)) {
		goto __57
	}
	(*(*func(*crt.TLS, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 504 /* &.tcl_SetIntObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)), (*(*int32)(unsafe.Pointer(bp + 48 /* intValue */)) / 10))
	goto __58
__57:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)), (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, (*(*int32)(unsafe.Pointer(bp + 48 /* intValue */))/10)))
__58:
	;
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 32 /* varIndex */)))*8)))
	goto __53
__52:
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 136 /* &.tcl_AppendStringsToObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp),
		crt.VaList(bp, ts+1429 /* "bad option \"" */, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))),
			ts+9372 /* "\": must be set, ..." */, (uintptr(0))))
	return 1
__53:
	;
__46:
	;
__40:
	;
__36:
	;
__32:
	;
__27:
	;
__22:
	;
__16:
	;
__10:
	;
__4:
	;
	return 0
}

//-----------------------------------------------------------------------------
//
// TestlistobjCmd --
//
//	This function implements the 'testlistobj' command. It is used to
//	test a few possible corner cases in list object manipulation from
//	C code that cannot occur at the Tcl level.
//
// Results:
//	A standard Tcl object result.
//
// Side effects:
//	Creates, manipulates and frees list objects.
//
//-----------------------------------------------------------------------------

func TestlistobjCmd(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestObj.c:872:1: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// Subcommands supported by this command
	*(*[3]uintptr)(unsafe.Pointer(bp + 8 /* subcommands */)) = [3]uintptr{
		ts + 4166, /* "set" */
		ts + 1535, /* "get" */
		ts + 9416, /* "replace" */
	}
	const ( /* tclTestObj.c:884:5: */
		LISTOBJ_SET     = 0
		LISTOBJ_GET     = 1
		LISTOBJ_REPLACE = 2
	)
	var index uintptr // Argument giving the variable number
	// var varIndex int32 at bp, 4
	// Variable number converted to binary
	// var cmdIndex int32 at bp+32, 4
	// Ordinal number of the subcommand
	// var first int32 at bp+36, 4
	// First index in the list
	// var count int32 at bp+40, 4
	// Count of elements in a list
	var varPtr uintptr

	if objc < 3 {
		(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+9424 /* "option arg ?arg...." */)
		return 1
	}
	varPtr = GetVarPtr(tls, interp)
	index = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if GetVariableIndex(tls, interp, index, bp /* &varIndex */) != 0 {
		return 1
	}
	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 2448 /* &.tcl_GetIndexFromObjStruct */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+8 /* &subcommands */, int32(8), ts+4596 /* "command" */, 0, bp+32 /* &cmdIndex */) != 0 {
		return 1
	}
	switch *(*int32)(unsafe.Pointer(bp + 32 /* cmdIndex */)) {
	case LISTOBJ_SET:
		if (*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp /* varIndex */)))*8)) != (uintptr(0))) && !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp /* varIndex */)))*8))))).refCount > 1) {
			(*(*func(*crt.TLS, uintptr, int32, uintptr))(unsafe.Pointer((tclStubsPtr + 512 /* &.tcl_SetListObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp /* varIndex */)))*8)), (objc - 3), (objv + uintptr(3)*8))
		} else {
			SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp /* varIndex */)), (*(*func(*crt.TLS, int32, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 440 /* &.tcl_NewListObj */))))(tls, (objc-3), (objv+uintptr(3)*8)))
		}
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp /* varIndex */)))*8)))
		break

	case LISTOBJ_GET:
		if objc != 3 {
			(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 2, objv, ts+9165 /* "varIndex" */)
			return 1
		}
		if CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp /* varIndex */))) != 0 {
			return 1
		}
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp /* varIndex */)))*8)))
		break

	case LISTOBJ_REPLACE:
		if objc < 5 {
			(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 2, objv,
				ts+9444 /* "varIndex start c..." */)
			return 1
		}
		if ((*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 320 /* &.tcl_GetIntFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+36 /* &first */) != 0) ||
			((*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 320 /* &.tcl_GetIntFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8)), bp+40 /* &count */) != 0) {
			return 1
		}
		if (*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp /* varIndex */)))*8))))).refCount > 1 {
			SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp /* varIndex */)), (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 248 /* &.tcl_DuplicateObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp /* varIndex */)))*8))))
		}
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 1752 /* &.tcl_ResetResult */))))(tls, interp)
		return (*(*func(*crt.TLS, uintptr, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 400 /* &.tcl_ListObjReplace */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp /* varIndex */)))*8)), *(*int32)(unsafe.Pointer(bp + 36 /* first */)), *(*int32)(unsafe.Pointer(bp + 40 /* count */)),
			(objc - 5), (objv + uintptr(5)*8))
	}
	return 0
}

//----------------------------------------------------------------------
//
// TestobjCmd --
//
//	This function implements the "testobj" command. It is used to test
//	the type-independent portions of the Tcl object type implementation.
//
// Results:
//	A standard Tcl object result.
//
// Side effects:
//	Creates and frees objects.
//
//----------------------------------------------------------------------

func TestobjCmd(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestObj.c:969:1: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	// var varIndex int32 at bp+64, 4

	// var destIndex int32 at bp+68, 4

	var i int32
	var index uintptr
	var subCmd uintptr
	var string uintptr
	var targetType uintptr
	var varPtr uintptr
	var listObjPtr uintptr
	// var elemObjPtr uintptr at bp+72, 8

	var typeName uintptr
	var _objPtr uintptr
	var typeName1 uintptr

	if !(objc < 2) {
		goto __1
	}
wrongNumArgs:
	(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+9210 /* "option arg ?arg ..." */)
	return 1
__1:
	;

	varPtr = GetVarPtr(tls, interp)
	subCmd = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)))
	if !(crt.Xstrcmp(tls, subCmd, ts+9478 /* "assign" */) == 0) {
		goto __2
	}
	if !(objc != 4) {
		goto __4
	}
	goto wrongNumArgs
__4:
	;
	index = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if !(GetVariableIndex(tls, interp, index, bp+64 /* &varIndex */) != 0) {
		goto __5
	}
	return 1
__5:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 64 /* varIndex */))) != 0) {
		goto __6
	}
	return 1
__6:
	;
	string = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
	if !(GetVariableIndex(tls, interp, string, bp+68 /* &destIndex */) != 0) {
		goto __7
	}
	return 1
__7:
	;
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 68 /* destIndex */)), *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)))*8)))
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 68 /* destIndex */)))*8)))
	goto __3
__2:
	if !(crt.Xstrcmp(tls, subCmd, ts+9485 /* "bug3598580" */) == 0) {
		goto __8
	}
	if !(objc != 2) {
		goto __10
	}
	goto wrongNumArgs
__10:
	;
	*(*uintptr)(unsafe.Pointer(bp + 72 /* elemObjPtr */)) = (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, 123)
	listObjPtr = (*(*func(*crt.TLS, int32, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 440 /* &.tcl_NewListObj */))))(tls, 1, bp+72 /* &elemObjPtr */)
	// Replace the single list element through itself, nonsense but legal.
	(*(*func(*crt.TLS, uintptr, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 400 /* &.tcl_ListObjReplace */))))(tls, interp, listObjPtr, 0, 1, 1, bp+72 /* &elemObjPtr */)
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, listObjPtr)
	return 0
	goto __9
__8:
	if !(crt.Xstrcmp(tls, subCmd, ts+9496 /* "convert" */) == 0) {
		goto __11
	}

	if !(objc != 4) {
		goto __13
	}
	goto wrongNumArgs
__13:
	;
	index = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if !(GetVariableIndex(tls, interp, index, bp+64 /* &varIndex */) != 0) {
		goto __14
	}
	return 1
__14:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 64 /* varIndex */))) != 0) {
		goto __15
	}
	return 1
__15:
	;
	typeName = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
	if !((crt.AssignUintptr(&targetType, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 336 /* &.tcl_GetObjType */))))(tls, typeName))) == (uintptr(0))) {
		goto __16
	}
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 136 /* &.tcl_AppendStringsToObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp),
		crt.VaList(bp, ts+9504 /* "no type " */, typeName, ts+9513 /* " found" */, (uintptr(0))))
	return 1
__16:
	;
	if !((*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 160 /* &.tcl_ConvertToType */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)))*8)), targetType) !=
		0) {
		goto __17
	}
	return 1
__17:
	;
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)))*8)))
	goto __12
__11:
	if !(crt.Xstrcmp(tls, subCmd, ts+9520 /* "duplicate" */) == 0) {
		goto __18
	}
	if !(objc != 4) {
		goto __20
	}
	goto wrongNumArgs
__20:
	;
	index = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if !(GetVariableIndex(tls, interp, index, bp+64 /* &varIndex */) != 0) {
		goto __21
	}
	return 1
__21:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 64 /* varIndex */))) != 0) {
		goto __22
	}
	return 1
__22:
	;
	string = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
	if !(GetVariableIndex(tls, interp, string, bp+68 /* &destIndex */) != 0) {
		goto __23
	}
	return 1
__23:
	;
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 68 /* destIndex */)), (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 248 /* &.tcl_DuplicateObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)))*8))))
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 68 /* destIndex */)))*8)))
	goto __19
__18:
	if !(crt.Xstrcmp(tls, subCmd, ts+9530 /* "freeallvars" */) == 0) {
		goto __24
	}
	if !(objc != 2) {
		goto __26
	}
	goto wrongNumArgs
__26:
	;
	i = 0
__27:
	if !(i < 20) {
		goto __29
	}
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(i)*8)) != (uintptr(0))) {
		goto __30
	}
__31:
	_objPtr = (*(*uintptr)(unsafe.Pointer(varPtr + uintptr(i)*8)))
	if !(crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1) {
		goto __34
	}
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
__34:
	;
	goto __32
__32:
	if 0 != 0 {
		goto __31
	}
	goto __33
__33:
	;
	*(*uintptr)(unsafe.Pointer(varPtr + uintptr(i)*8)) = (uintptr(0))
__30:
	;
	goto __28
__28:
	i++
	goto __27
	goto __29
__29:
	;
	goto __25
__24:
	if !(crt.Xstrcmp(tls, subCmd, ts+9542 /* "invalidateString..." */) == 0) {
		goto __35
	}
	if !(objc != 3) {
		goto __37
	}
	goto wrongNumArgs
__37:
	;
	index = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if !(GetVariableIndex(tls, interp, index, bp+64 /* &varIndex */) != 0) {
		goto __38
	}
	return 1
__38:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 64 /* varIndex */))) != 0) {
		goto __39
	}
	return 1
__39:
	;
	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 352 /* &.tcl_InvalidateStringRep */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)))*8)))
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)))*8)))
	goto __36
__35:
	if !(crt.Xstrcmp(tls, subCmd, ts+9562 /* "newobj" */) == 0) {
		goto __40
	}
	if !(objc != 3) {
		goto __42
	}
	goto wrongNumArgs
__42:
	;
	index = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if !(GetVariableIndex(tls, interp, index, bp+64 /* &varIndex */) != 0) {
		goto __43
	}
	return 1
__43:
	;
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)), (*(*func(*crt.TLS) uintptr)(unsafe.Pointer((tclStubsPtr + 456 /* &.tcl_NewObj */))))(tls))
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)))*8)))
	goto __41
__40:
	if !(crt.Xstrcmp(tls, subCmd, ts+9569 /* "objtype" */) == 0) {
		goto __44
	}

	// Return an object containing the name of the argument's type of
	// internal rep. If none exists, return "none".

	if !(objc != 3) {
		goto __46
	}
	goto wrongNumArgs
__46:
	;
	if !((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))).typePtr == (uintptr(0))) {
		goto __47
	}
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, ts+6512 /* "none" */, -1))
	goto __48
__47:
	typeName1 = (*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))).typePtr)).name
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, typeName1, -1))
__48:
	;
	goto __45
__44:
	if !(crt.Xstrcmp(tls, subCmd, ts+6706 /* "refcount" */) == 0) {
		goto __49
	}
	if !(objc != 3) {
		goto __51
	}
	goto wrongNumArgs
__51:
	;
	index = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if !(GetVariableIndex(tls, interp, index, bp+64 /* &varIndex */) != 0) {
		goto __52
	}
	return 1
__52:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 64 /* varIndex */))) != 0) {
		goto __53
	}
	return 1
__53:
	;
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, (*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)))*8)))).refCount))
	goto __50
__49:
	if !(crt.Xstrcmp(tls, subCmd, ts+6715 /* "type" */) == 0) {
		goto __54
	}
	if !(objc != 3) {
		goto __56
	}
	goto wrongNumArgs
__56:
	;
	index = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if !(GetVariableIndex(tls, interp, index, bp+64 /* &varIndex */) != 0) {
		goto __57
	}
	return 1
__57:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 64 /* varIndex */))) != 0) {
		goto __58
	}
	return 1
__58:
	;
	if !((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)))*8)))).typePtr == (uintptr(0))) {
		goto __59
	} // a string!
	(*(*func(*crt.TLS, uintptr, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 144 /* &.tcl_AppendToObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp), ts+4108 /* "string" */, -1)
	goto __60
__59:
	(*(*func(*crt.TLS, uintptr, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 144 /* &.tcl_AppendToObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp),
		(*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* varIndex */)))*8)))).typePtr)).name, -1)
__60:
	;
	goto __55
__54:
	if !(crt.Xstrcmp(tls, subCmd, ts+9577 /* "types" */) == 0) {
		goto __61
	}
	if !(objc != 2) {
		goto __63
	}
	goto wrongNumArgs
__63:
	;
	if !((*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 128 /* &.tcl_AppendAllObjTypes */))))(tls, interp,
		(*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp)) != 0) {
		goto __64
	}
	return 1
__64:
	;
	goto __62
__61:
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 136 /* &.tcl_AppendStringsToObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp),
		crt.VaList(bp+32, ts+1429 /* "bad option \"" */, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))),

			ts+9583 /* "\": must be assig..." */, (uintptr(0))))
	return 1
__62:
	;
__55:
	;
__50:
	;
__45:
	;
__41:
	;
__36:
	;
__25:
	;
__19:
	;
__12:
	;
__9:
	;
__3:
	;
	return 0
}

//----------------------------------------------------------------------
//
// TeststringobjCmd --
//
//	This function implements the "teststringobj" command. It is used to
//	test the string Tcl object type implementation.
//
// Results:
//	A standard Tcl object result.
//
// Side effects:
//	Creates and frees string objects, and also converts objects to
//	have string type.
//
//----------------------------------------------------------------------

func TeststringobjCmd(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestObj.c:1173:1: */
	bp := tls.Alloc(212)
	defer tls.Free(212)

	var unicode uintptr
	// var varIndex int32 at bp+96, 4

	// var option int32 at bp+100, 4

	// var i int32 at bp+208, 4

	// var length int32 at bp+104, 4

	var index uintptr
	var string uintptr
	// var strings [12]uintptr at bp+112, 96

	var strPtr uintptr
	var varPtr uintptr

	if !(objc < 3) {
		goto __1
	}
wrongNumArgs:
	(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+9210 /* "option arg ?arg ..." */)
	return 1
__1:
	;

	varPtr = GetVarPtr(tls, interp)
	index = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8)))
	if !(GetVariableIndex(tls, interp, index, bp+96 /* &varIndex */) != 0) {
		goto __2
	}
	return 1
__2:
	;

	if !((*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 2448 /* &.tcl_GetIndexFromObjStruct */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), uintptr(unsafe.Pointer(&options2)), int32(8), ts+3361 /* "option" */, 0, bp+100 /* &option */) !=
		0) {
		goto __3
	}
	return 1
__3:
	;
	switch *(*int32)(unsafe.Pointer(bp + 100 /* option */)) {
	case 0:
		goto __5
	case 1:
		goto __6
	case 2:
		goto __7
	case 3:
		goto __8
	case 4:
		goto __9
	case 5:
		goto __10
	case 6:
		goto __11
	case 7:
		goto __12
	case 8:
		goto __13
	case 9:
		goto __14
	case 10:
		goto __15
	case 11:
		goto __16
	case 12:
		goto __17
	}
	goto __4
__5: // append
	if !(objc != 5) {
		goto __18
	}
	goto wrongNumArgs
__18:
	;
	if !((*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 320 /* &.tcl_GetIntFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(4)*8)), bp+104 /* &length */) != 0) {
		goto __19
	}
	return 1
__19:
	;
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)) == (uintptr(0))) {
		goto __20
	}
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), (*(*func(*crt.TLS) uintptr)(unsafe.Pointer((tclStubsPtr + 456 /* &.tcl_NewObj */))))(tls))
__20:
	;

	// If the object bound to variable "varIndex" is shared, we must
	// "copy on write" and append to a copy of the object.

	if !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8))))).refCount > 1) {
		goto __21
	}
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 248 /* &.tcl_DuplicateObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8))))
__21:
	;
	string = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
	(*(*func(*crt.TLS, uintptr, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 144 /* &.tcl_AppendToObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)), string, *(*int32)(unsafe.Pointer(bp + 104 /* length */)))
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)))
	goto __4
__6: // appendstrings
	if !(objc > (11 + 3)) {
		goto __22
	}
	goto wrongNumArgs
__22:
	;
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)) == (uintptr(0))) {
		goto __23
	}
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), (*(*func(*crt.TLS) uintptr)(unsafe.Pointer((tclStubsPtr + 456 /* &.tcl_NewObj */))))(tls))
__23:
	;

	// If the object bound to variable "varIndex" is shared, we must
	// "copy on write" and append to a copy of the object.

	if !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8))))).refCount > 1) {
		goto __24
	}
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 248 /* &.tcl_DuplicateObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8))))
__24:
	;
	*(*int32)(unsafe.Pointer(bp + 208 /* i */)) = 3
__25:
	if !(*(*int32)(unsafe.Pointer(bp + 208 /* i */)) < objc) {
		goto __27
	}
	*(*uintptr)(unsafe.Pointer(bp + 112 /* &strings */ + uintptr((*(*int32)(unsafe.Pointer(bp + 208 /* i */))-3))*8)) = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(*(*int32)(unsafe.Pointer(bp + 208 /* i */)))*8)))
	goto __26
__26:
	*(*int32)(unsafe.Pointer(bp + 208 /* i */))++
	goto __25
	goto __27
__27:
	;
__28:
	if !(*(*int32)(unsafe.Pointer(bp + 208 /* i */)) < (12 + 3)) {
		goto __30
	}
	*(*uintptr)(unsafe.Pointer(bp + 112 /* &strings */ + uintptr((*(*int32)(unsafe.Pointer(bp + 208 /* i */))-3))*8)) = (uintptr(0))
	goto __29
__29:
	*(*int32)(unsafe.Pointer(bp + 208 /* i */))++
	goto __28
	goto __30
__30:
	;
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 136 /* &.tcl_AppendStringsToObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)), crt.VaList(bp, *(*uintptr)(unsafe.Pointer(bp + 112 /* &strings */ + uintptr(0)*8)), *(*uintptr)(unsafe.Pointer(bp + 112 /* &strings */ + uintptr(1)*8)),
		*(*uintptr)(unsafe.Pointer(bp + 112 /* &strings */ + uintptr(2)*8)), *(*uintptr)(unsafe.Pointer(bp + 112 /* &strings */ + uintptr(3)*8)), *(*uintptr)(unsafe.Pointer(bp + 112 /* &strings */ + uintptr(4)*8)), *(*uintptr)(unsafe.Pointer(bp + 112 /* &strings */ + uintptr(5)*8)),
		*(*uintptr)(unsafe.Pointer(bp + 112 /* &strings */ + uintptr(6)*8)), *(*uintptr)(unsafe.Pointer(bp + 112 /* &strings */ + uintptr(7)*8)), *(*uintptr)(unsafe.Pointer(bp + 112 /* &strings */ + uintptr(8)*8)), *(*uintptr)(unsafe.Pointer(bp + 112 /* &strings */ + uintptr(9)*8)),
		*(*uintptr)(unsafe.Pointer(bp + 112 /* &strings */ + uintptr(10)*8)), *(*uintptr)(unsafe.Pointer(bp + 112 /* &strings */ + uintptr(11)*8))))
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)))
	goto __4
__7: // get
	if !(objc != 3) {
		goto __31
	}
	goto wrongNumArgs
__31:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */))) != 0) {
		goto __32
	}
	return 1
__32:
	;
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)))
	goto __4
__8: // get2
	if !(objc != 3) {
		goto __33
	}
	goto wrongNumArgs
__33:
	;
	if !(CheckIfVarUnset(tls, interp, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */))) != 0) {
		goto __34
	}
	return 1
__34:
	;
	string = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)))
	(*(*func(*crt.TLS, uintptr, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 144 /* &.tcl_AppendToObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp), string, -1)
	goto __4
__9: // length
	if !(objc != 3) {
		goto __35
	}
	goto wrongNumArgs
__35:
	;
	(*(*func(*crt.TLS, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 504 /* &.tcl_SetIntObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp), func() int32 {
		if *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)) != (uintptr(0)) {
			return (*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)))).length
		}
		return -1
	}())
	goto __4
__10: // length2
	if !(objc != 3) {
		goto __36
	}
	goto wrongNumArgs
__36:
	;
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)) != (uintptr(0))) {
		goto __37
	}
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 160 /* &.tcl_ConvertToType */))))(tls, (uintptr(0)), *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)),
		(*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 336 /* &.tcl_GetObjType */))))(tls, ts+4108 /* "string" */))
	strPtr = (*struct {
		ptr1 uintptr
		ptr2 uintptr
	})(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)) + 32 /* &.internalRep */)).ptr1
	*(*int32)(unsafe.Pointer(bp + 104 /* length */)) = (*String)(unsafe.Pointer(strPtr)).allocated
	goto __38
__37:
	*(*int32)(unsafe.Pointer(bp + 104 /* length */)) = -1
__38:
	;
	(*(*func(*crt.TLS, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 504 /* &.tcl_SetIntObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp), *(*int32)(unsafe.Pointer(bp + 104 /* length */)))
	goto __4
__11: // set
	if !(objc != 4) {
		goto __39
	}
	goto wrongNumArgs
__39:
	;

	// If the object currently bound to the variable with index
	// varIndex has ref count 1 (i.e. the object is unshared) we can
	// modify that object directly. Otherwise, if RC>1 (i.e. the
	// object is shared), we must create a new object to modify/set
	// and decrement the old formerly-shared object's ref count. This
	// is "copy on write".

	string = (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 344 /* &.tcl_GetStringFromObj */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+104 /* &length */)
	if !((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)) != (uintptr(0))) &&
		!((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8))))).refCount > 1)) {
		goto __40
	}
	(*(*func(*crt.TLS, uintptr, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 536 /* &.tcl_SetStringObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)), string, *(*int32)(unsafe.Pointer(bp + 104 /* length */)))
	goto __41
__40:
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls, string, *(*int32)(unsafe.Pointer(bp + 104 /* length */))))
__41:
	;
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)))
	goto __4
__12: // set2
	if !(objc != 4) {
		goto __42
	}
	goto wrongNumArgs
__42:
	;
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
	goto __4
__13: // setlength
	if !(objc != 4) {
		goto __43
	}
	goto wrongNumArgs
__43:
	;
	if !((*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 320 /* &.tcl_GetIntFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+104 /* &length */) != 0) {
		goto __44
	}
	return 1
__44:
	;
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)) != (uintptr(0))) {
		goto __45
	}
	(*(*func(*crt.TLS, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 528 /* &.tcl_SetObjLength */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)), *(*int32)(unsafe.Pointer(bp + 104 /* length */)))
__45:
	;
	goto __4
__14: // maxchars
	if !(objc != 3) {
		goto __46
	}
	goto wrongNumArgs
__46:
	;
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)) != (uintptr(0))) {
		goto __47
	}
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 160 /* &.tcl_ConvertToType */))))(tls, (uintptr(0)), *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)),
		(*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 336 /* &.tcl_GetObjType */))))(tls, ts+4108 /* "string" */))
	strPtr = (*struct {
		ptr1 uintptr
		ptr2 uintptr
	})(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)) + 32 /* &.internalRep */)).ptr1
	*(*int32)(unsafe.Pointer(bp + 104 /* length */)) = (*String)(unsafe.Pointer(strPtr)).maxChars
	goto __48
__47:
	*(*int32)(unsafe.Pointer(bp + 104 /* length */)) = -1
__48:
	;
	(*(*func(*crt.TLS, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 504 /* &.tcl_SetIntObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp), *(*int32)(unsafe.Pointer(bp + 104 /* length */)))
	goto __4
__15: // getunicode
	if !(objc != 3) {
		goto __49
	}
	goto wrongNumArgs
__49:
	;
	(*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 3488 /* &.tcl_GetUnicodeFromObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)), (uintptr(0)))
	goto __4
__16: // appendself
	if !(objc != 4) {
		goto __50
	}
	goto wrongNumArgs
__50:
	;
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)) == (uintptr(0))) {
		goto __51
	}
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), (*(*func(*crt.TLS) uintptr)(unsafe.Pointer((tclStubsPtr + 456 /* &.tcl_NewObj */))))(tls))
__51:
	;

	// If the object bound to variable "varIndex" is shared, we must
	// "copy on write" and append to a copy of the object.

	if !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8))))).refCount > 1) {
		goto __52
	}
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 248 /* &.tcl_DuplicateObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8))))
__52:
	;

	string = (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 344 /* &.tcl_GetStringFromObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)), bp+104 /* &length */)

	if !((*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 320 /* &.tcl_GetIntFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+208 /* &i */) != 0) {
		goto __53
	}
	return 1
__53:
	;
	if !((*(*int32)(unsafe.Pointer(bp + 208 /* i */)) < 0) || (*(*int32)(unsafe.Pointer(bp + 208 /* i */)) > *(*int32)(unsafe.Pointer(bp + 104 /* length */)))) {
		goto __54
	}
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls,
		ts+9687 /* "index value out ..." */, -1))
	return 1
__54:
	;

	(*(*func(*crt.TLS, uintptr, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 144 /* &.tcl_AppendToObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)), (string + uintptr(*(*int32)(unsafe.Pointer(bp + 208 /* i */)))), (*(*int32)(unsafe.Pointer(bp + 104 /* length */)) - *(*int32)(unsafe.Pointer(bp + 208 /* i */))))
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)))
	goto __4
__17: // appendself2
	if !(objc != 4) {
		goto __55
	}
	goto wrongNumArgs
__55:
	;
	if !(*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)) == (uintptr(0))) {
		goto __56
	}
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), (*(*func(*crt.TLS) uintptr)(unsafe.Pointer((tclStubsPtr + 456 /* &.tcl_NewObj */))))(tls))
__56:
	;

	// If the object bound to variable "varIndex" is shared, we must
	// "copy on write" and append to a copy of the object.

	if !((*Tcl_Obj)(unsafe.Pointer((*(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8))))).refCount > 1) {
		goto __57
	}
	SetVarToObj(tls, varPtr, *(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)), (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 248 /* &.tcl_DuplicateObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8))))
__57:
	;

	unicode = (*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 3488 /* &.tcl_GetUnicodeFromObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)), bp+104 /* &length */)

	if !((*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 320 /* &.tcl_GetIntFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)), bp+208 /* &i */) != 0) {
		goto __58
	}
	return 1
__58:
	;
	if !((*(*int32)(unsafe.Pointer(bp + 208 /* i */)) < 0) || (*(*int32)(unsafe.Pointer(bp + 208 /* i */)) > *(*int32)(unsafe.Pointer(bp + 104 /* length */)))) {
		goto __59
	}
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, uintptr, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 464 /* &.tcl_NewStringObj */))))(tls,
		ts+9687 /* "index value out ..." */, -1))
	return 1
__59:
	;

	(*(*func(*crt.TLS, uintptr, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 3088 /* &.tcl_AppendUnicodeToObj */))))(tls, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)), (unicode + uintptr(*(*int32)(unsafe.Pointer(bp + 208 /* i */)))*2), (*(*int32)(unsafe.Pointer(bp + 104 /* length */)) - *(*int32)(unsafe.Pointer(bp + 208 /* i */))))
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, *(*uintptr)(unsafe.Pointer(varPtr + uintptr(*(*int32)(unsafe.Pointer(bp + 96 /* varIndex */)))*8)))
	goto __4
__4:
	;

	return 0
}

var options2 = [14]uintptr{
	ts + 2519 /* "append" */, ts + 9712 /* "appendstrings" */, ts + 1535 /* "get" */, ts + 9353 /* "get2" */, ts + 3259 /* "length" */, ts + 9726, /* "length2" */
	ts + 4166 /* "set" */, ts + 9319 /* "set2" */, ts + 9734 /* "setlength" */, ts + 9744 /* "maxchars" */, ts + 9753, /* "getunicode" */
	ts + 9764 /* "appendself" */, ts + 9775 /* "appendself2" */, (uintptr(0)),
} /* tclTestObj.c:1185:23 */

//----------------------------------------------------------------------
//
// SetVarToObj --
//
//	Utility routine to assign a Tcl_Obj* to a test variable. The
//	Tcl_Obj* can be NULL.
//
// Results:
//	None.
//
// Side effects:
//	This routine handles ref counting details for assignment: i.e. the old
//	value's ref count must be decremented (if not NULL) and the new one
//	incremented (also if not NULL).
//
//----------------------------------------------------------------------

func SetVarToObj(tls *crt.TLS, varPtr uintptr, varIndex int32, objPtr uintptr) { /* tclTestObj.c:1446:1: */
	if *(*uintptr)(unsafe.Pointer(varPtr + uintptr(varIndex)*8)) != (uintptr(0)) {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*(*uintptr)(unsafe.Pointer(varPtr + uintptr(varIndex)*8)))
			if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
				(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
			}
		}
	}
	*(*uintptr)(unsafe.Pointer(varPtr + uintptr(varIndex)*8)) = objPtr
	if objPtr != (uintptr(0)) {
		(*Tcl_Obj)(unsafe.Pointer((objPtr))).refCount++
	}
}

//----------------------------------------------------------------------
//
// GetVariableIndex --
//
//	Utility routine to get a test variable index from the command line.
//
// Results:
//	A standard Tcl object result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func GetVariableIndex(tls *crt.TLS, interp uintptr, string uintptr, indexPtr uintptr) int32 { /* tclTestObj.c:1477:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var index int32 at bp, 4

	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, string, bp /* &index */) != 0 {
		return 1
	}
	if (*(*int32)(unsafe.Pointer(bp /* index */)) < 0) || (*(*int32)(unsafe.Pointer(bp /* index */)) >= 20) {
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 1752 /* &.tcl_ResetResult */))))(tls, interp)
		(*(*func(*crt.TLS, uintptr, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 144 /* &.tcl_AppendToObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp), ts+9787 /* "bad variable ind..." */, -1)
		return 1
	}

	*(*int32)(unsafe.Pointer(indexPtr)) = *(*int32)(unsafe.Pointer(bp /* index */))
	return 0
}

//----------------------------------------------------------------------
//
// CheckIfVarUnset --
//
//	Utility function that checks whether a test variable is readable:
//	i.e., that varPtr[varIndex] is non-NULL.
//
// Results:
//	1 if the test variable is unset (NULL); 0 otherwise.
//
// Side effects:
//	Sets the interpreter result to an error message if the variable is
//	unset (NULL).
//
//----------------------------------------------------------------------

func CheckIfVarUnset(tls *crt.TLS, interp uintptr, varPtr uintptr, varIndex int32) int32 { /* tclTestObj.c:1518:1: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	if *(*uintptr)(unsafe.Pointer(varPtr + uintptr(varIndex)*8)) == (uintptr(0)) {
		// var buf [56]int8 at bp+8, 56

		crt.Xsprintf(tls, bp+8 /* &buf */, ts+9806 /* "variable %d is u..." */, crt.VaList(bp, varIndex))
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 1752 /* &.tcl_ResetResult */))))(tls, interp)
		(*(*func(*crt.TLS, uintptr, uintptr, int32))(unsafe.Pointer((tclStubsPtr + 144 /* &.tcl_AppendToObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp), bp+8 /* &buf */, -1)
		return 1
	}
	return 0
}

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Inline function declarations:

// Slot 69 is reserved
// Slot 70 is reserved
// Slot 71 is reserved
// Slot 72 is reserved
// Slot 77 is reserved
// Slot 79 is reserved

// !END!: Do not edit above this line.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// name and version of this package

var packageName = *(*[13]int8)(unsafe.Pointer(ts + 9834 /* "procbodytest" */)) /* tclTestProcBodyObj.c:23:19 */
var packageVersion = *(*[4]int8)(unsafe.Pointer(ts + 9847 /* "1.1" */))        /* tclTestProcBodyObj.c:24:19 */

// Name of the commands exported by this package

var procCommand = *(*[5]int8)(unsafe.Pointer(ts + 9851 /* "proc" */))   /* tclTestProcBodyObj.c:30:19 */
var checkCommand = *(*[6]int8)(unsafe.Pointer(ts + 9301 /* "check" */)) /* tclTestProcBodyObj.c:31:19 */

// this struct describes an entry in the table of command names and command
// procs

type CmdTable1 = struct {
	cmdName  uintptr
	proc     uintptr
	exportIt int32
	_        [4]byte
}

// this struct describes an entry in the table of command names and command
// procs

type CmdTable = CmdTable1 /* tclTestProcBodyObj.c:42:3 */

// List of commands to create when the package is loaded; must go after the
// declarations of the enable command procedure.

var commands = [3]CmdTable{
	{cmdName: 0, proc: 0, exportIt: 1},
	{cmdName: 0, proc: 0, exportIt: 1},
	{cmdName: uintptr(0), proc: uintptr(0), exportIt: 0},
} /* tclTestProcBodyObj.c:61:23 */

var safeCommands = [3]CmdTable{
	{cmdName: 0, proc: 0, exportIt: 1},
	{cmdName: 0, proc: 0, exportIt: 1},
	{cmdName: uintptr(0), proc: uintptr(0), exportIt: 0},
} /* tclTestProcBodyObj.c:67:23 */

//----------------------------------------------------------------------
//
// Procbodytest_Init --
//
//	This function initializes the "procbodytest" package.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func Procbodytest_Init(tls *crt.TLS, interp uintptr) int32 { /* tclTestProcBodyObj.c:90:1: */
	return ProcBodyTestInitInternal(tls, interp, 0)
}

//----------------------------------------------------------------------
//
// Procbodytest_SafeInit --
//
//	This function initializes the "procbodytest" package.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func Procbodytest_SafeInit(tls *crt.TLS, interp uintptr) int32 { /* tclTestProcBodyObj.c:114:1: */
	return ProcBodyTestInitInternal(tls, interp, 1)
}

//----------------------------------------------------------------------
//
// RegisterCommand --
//
//	This function registers a command in the context of the given
//	namespace.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func RegisterCommand(tls *crt.TLS, interp uintptr, namespace uintptr, cmdTablePtr uintptr) int32 { /* tclTestProcBodyObj.c:139:1: */
	bp := tls.Alloc(160)
	defer tls.Free(160)

	// var buf [128]int8 at bp+32, 128

	if (*CmdTable)(unsafe.Pointer(cmdTablePtr)).exportIt != 0 {
		crt.Xsprintf(tls, bp+32 /* &buf */, ts+9856, /* "namespace eval %..." */
			crt.VaList(bp, namespace, (*CmdTable)(unsafe.Pointer(cmdTablePtr)).cmdName))
		if (*(*func(*crt.TLS, uintptr, uintptr, int32, int32) int32)(unsafe.Pointer((tclStubsPtr + 2344 /* &.tcl_EvalEx */))))(tls, interp, bp+32 /* &buf */, -1, 0) != 0 {
			return 1
		}
	}

	crt.Xsprintf(tls, bp+32 /* &buf */, ts+9898 /* "%s::%s" */, crt.VaList(bp+16, namespace, (*CmdTable)(unsafe.Pointer(cmdTablePtr)).cmdName))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, bp+32 /* &buf */, (*CmdTable)(unsafe.Pointer(cmdTablePtr)).proc, uintptr(0), uintptr(0))
	return 0
}

//----------------------------------------------------------------------
//
// ProcBodyTestInitInternal --
//
//  This function initializes the Loader package.
//  The isSafe flag is 1 if the interpreter is safe, 0 otherwise.
//
// Results:
//  A standard Tcl result.
//
// Side effects:
//  None.
//
//----------------------------------------------------------------------

func ProcBodyTestInitInternal(tls *crt.TLS, interp uintptr, isSafe int32) int32 { /* tclTestProcBodyObj.c:179:1: */
	var cmdTablePtr uintptr

	if isSafe != 0 {
		cmdTablePtr = (uintptr(unsafe.Pointer(&safeCommands)) + uintptr(0)*24)
	} else {
		cmdTablePtr = (uintptr(unsafe.Pointer(&commands)) + uintptr(0)*24)
	}
	for ; (*CmdTable)(unsafe.Pointer(cmdTablePtr)).cmdName != 0; cmdTablePtr += 24 {
		if RegisterCommand(tls, interp, uintptr(unsafe.Pointer(&packageName)), cmdTablePtr) != 0 {
			return 1
		}
	}

	return (*(*func(*crt.TLS, uintptr, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 16 /* &.tcl_PkgProvideEx */))))(tls, interp, uintptr(unsafe.Pointer(&packageName)), uintptr(unsafe.Pointer(&packageVersion)), (uintptr(0)))
}

//----------------------------------------------------------------------
//
// ProcBodyTestProcObjCmd --
//
//  Implements the "procbodytest::proc" command. Here is the command
//  description:
//	procbodytest::proc newName argList bodyName
//  Looks up a procedure called $bodyName and, if the procedure exists,
//  constructs a Tcl_Obj of type "procbody" and calls Tcl_ProcObjCmd.
//  Arguments:
//    newName		the name of the procedure to be created
//    argList		the argument list for the procedure
//    bodyName		the name of an existing procedure from which the
//			body is to be copied.
//  This command can be used to trigger the branches in Tcl_ProcObjCmd that
//  construct a proc from a "procbody", for example:
//	proc a {x} {return $x}
//	a 123
//	procbodytest::proc b {x} a
//  Note the call to "a 123", which is necessary so that the Proc pointer
//  for "a" is filled in by the internal compiler; this is a hack.
//
// Results:
//  Returns a standard Tcl code.
//
// Side effects:
//  A new procedure is created.
//  Leaves an error message in the interp's result on error.
//
//----------------------------------------------------------------------

func ProcBodyTestProcObjCmd(tls *crt.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestProcBodyObj.c:230:1: */
	bp := tls.Alloc(136)
	defer tls.Free(136)

	var fullName uintptr
	var procCmd Tcl_Command
	var cmdPtr uintptr
	var procPtr uintptr = (uintptr(0))
	var bodyObjPtr uintptr
	// var myobjv [5]uintptr at bp+96, 40

	var result int32

	if objc != 4 {
		(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+9905 /* "newName argsList..." */)
		return 1
	}

	// Find the Command pointer to this procedure

	fullName = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(3)*8)))
	procCmd = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32) Tcl_Command)(unsafe.Pointer((tclIntStubsPtr + 944 /* &.tcl_FindCommand */))))(tls, interp, fullName, (uintptr(0)), 0x200)
	if procCmd == (uintptr(0)) {
		return 1
	}

	cmdPtr = procCmd

	// check that this is a procedure and not a builtin command:
	// If a procedure, cmdPtr->objClientData is TclIsProc(cmdPtr).

	if (*Command)(unsafe.Pointer(cmdPtr)).objClientData != (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclIntStubsPtr + 456 /* &.tclIsProc */))))(tls, cmdPtr) {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 136 /* &.tcl_AppendStringsToObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp),
			crt.VaList(bp, ts+9931 /* "command \"" */, fullName, ts+9941 /* "\" is not a Tcl p..." */, (uintptr(0))))
		return 1
	}

	// it is a Tcl procedure: the client data is the Proc structure

	procPtr = (*Command)(unsafe.Pointer(cmdPtr)).objClientData
	if procPtr == (uintptr(0)) {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 136 /* &.tcl_AppendStringsToObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp), crt.VaList(bp+32, ts+9966, /* "procedure \"" */
			fullName, ts+9978 /* "\" does not have ..." */, (uintptr(0))))
		return 1
	}

	// create a new object, initialize our argument vector, call into Tcl

	bodyObjPtr = (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclIntStubsPtr + 504 /* &.tclNewProcBodyObj */))))(tls, procPtr)
	if bodyObjPtr == (uintptr(0)) {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 136 /* &.tcl_AppendStringsToObj */))))(tls, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1344 /* &.tcl_GetObjResult */))))(tls, interp),
			crt.VaList(bp+64, ts+10009, /* "failed to create..." */
				fullName, ts+1804 /* "\"" */, (uintptr(0))))
		return 1
	}
	(*Tcl_Obj)(unsafe.Pointer((bodyObjPtr))).refCount++

	*(*uintptr)(unsafe.Pointer(bp + 96 /* &myobjv */ + uintptr(0)*8)) = *(*uintptr)(unsafe.Pointer(objv + uintptr(0)*8))
	*(*uintptr)(unsafe.Pointer(bp + 96 /* &myobjv */ + uintptr(1)*8)) = *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8))
	*(*uintptr)(unsafe.Pointer(bp + 96 /* &myobjv */ + uintptr(2)*8)) = *(*uintptr)(unsafe.Pointer(objv + uintptr(2)*8))
	*(*uintptr)(unsafe.Pointer(bp + 96 /* &myobjv */ + uintptr(3)*8)) = bodyObjPtr
	*(*uintptr)(unsafe.Pointer(bp + 96 /* &myobjv */ + uintptr(4)*8)) = (uintptr(0))

	result = (*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 3136 /* &.tcl_ProcObjCmd */))))(tls, (uintptr(0)), interp, objc, bp+96 /* &myobjv */)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = (bodyObjPtr)
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
		}
	}

	return result
}

//----------------------------------------------------------------------
//
// ProcBodyTestCheckObjCmd --
//
//  Implements the "procbodytest::check" command. Here is the command
//  description:
//	procbodytest::check
//
//  Performs an internal check that the Tcl_PkgPresent() command returns
//  the same version number as was registered when the procbodytest package
//  was provided.  Places a boolean in the interp result indicating the
//  test outcome.
//
// Results:
//  Returns a standard Tcl code.
//
//----------------------------------------------------------------------

func ProcBodyTestCheckObjCmd(tls *crt.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclTestProcBodyObj.c:329:1: */
	var version uintptr

	if objc != 1 {
		(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+1482 /* "" */)
		return 1
	}

	version = (*(*func(*crt.TLS, uintptr, uintptr, uintptr, int32, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2192 /* &.tcl_PkgPresentEx */))))(tls, interp, uintptr(unsafe.Pointer(&packageName)), uintptr(unsafe.Pointer(&packageVersion)), 1, (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, (crt.Bool32((crt.Bool32(crt.Xstrcmp(tls, version, uintptr(unsafe.Pointer(&packageVersion))) == 0)) != 0))))
	return 0
}

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Inline function declarations:

// Slot 69 is reserved
// Slot 70 is reserved
// Slot 71 is reserved
// Slot 72 is reserved
// Slot 77 is reserved
// Slot 79 is reserved

// !END!: Do not edit above this line.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Value to indicate that there is no limit.

// We can represent all limits.

// Type for resource quantity measurement.
type rlim_t = uint64   /* resource.h:131:18 */
type rlim64_t = uint64 /* resource.h:136:20 */

// The following macros convert between TclFile's and fd's. The conversion
// simple involves shifting fd's up by one to ensure that no valid fd is ever
// the same as NULL. Note that this code is duplicated from tclUnixPipe.c

// The stuff below is used to keep track of file handlers created and
// exercised by the "testfilehandler" command.

type Pipe1 = struct {
	readFile   TclFile
	writeFile  TclFile
	readCount  int32
	writeCount int32
}

// The following macros convert between TclFile's and fd's. The conversion
// simple involves shifting fd's up by one to ensure that no valid fd is ever
// the same as NULL. Note that this code is duplicated from tclUnixPipe.c

// The stuff below is used to keep track of file handlers created and
// exercised by the "testfilehandler" command.

type Pipe = Pipe1 /* tclUnixTest.c:50:3 */

var testPipes [10]Pipe /* tclUnixTest.c:53:13: */

// The stuff below is used by the testalarm and testgotsig ommands.

var gotsig uintptr = ts + 6695 /* "0" */ /* tclUnixTest.c:59:19 */

//----------------------------------------------------------------------
//
// TclplatformtestInit --
//
//	Defines commands that test platform specific functionality for Unix
//	platforms.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Defines new commands.
//
//----------------------------------------------------------------------

func TclplatformtestInit(tls *crt.TLS, interp uintptr) int32 { /* tclUnixTest.c:96:1: */
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+10060 /* "testchmod" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestchmodCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+10070 /* "testfilehandler" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestfilehandlerCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+10086 /* "testfilewait" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestfilewaitCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+10099 /* "testfindexecutab..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestfindexecutableCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 784 /* &.tcl_CreateObjCommand */))))(tls, interp, ts+10118 /* "testfork" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestforkObjCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+10127 /* "testgetopenfile" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestgetopenfileCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+10143 /* "testgetdefenc" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestgetdefencdirCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+10157 /* "testsetdefenc" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestsetdefencdirCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+10171 /* "testalarm" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestalarmCmd})),
		(uintptr(0)), (uintptr(0)))
	(*(*func(*crt.TLS, uintptr, uintptr, uintptr, ClientData, uintptr) Tcl_Command)(unsafe.Pointer((tclStubsPtr + 744 /* &.tcl_CreateCommand */))))(tls, interp, ts+10181 /* "testgotsig" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32
	}{TestgotsigCmd})),
		(uintptr(0)), (uintptr(0)))
	return 0
}

//----------------------------------------------------------------------
//
// TestfilehandlerCmd --
//
//	This function implements the "testfilehandler" command. It is used to
//	test Tcl_CreateFileHandler, Tcl_DeleteFileHandler, and TclWaitForFile.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestfilehandlerCmd(tls *crt.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclUnixTest.c:140:1: */
	bp := tls.Alloc(4576)
	defer tls.Free(4576)

	var pipePtr uintptr
	// var i int32 at bp+496, 4

	var mask int32
	// var timeout int32 at bp+4572, 4

	// var buffer [4000]int8 at bp+548, 4000

	var file TclFile

	// NOTE: When we make this code work on Windows also, the following
	// variable needs to be made Unix-only.

	if !(initialized != 0) {
		for *(*int32)(unsafe.Pointer(bp + 496 /* i */)) = 0; *(*int32)(unsafe.Pointer(bp + 496 /* i */)) < 10; *(*int32)(unsafe.Pointer(bp + 496 /* i */))++ {
			testPipes[*(*int32)(unsafe.Pointer(bp + 496 /* i */))].readFile = (uintptr(0))
		}
		initialized = 1
	}

	if argc < 2 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+2369 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+10192 /* " option ... \"" */, (uintptr(0))))
		return 1
	}
	pipePtr = (uintptr(0))
	if argc >= 3 {
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), bp+496 /* &i */) != 0 {
			return 1
		}
		if *(*int32)(unsafe.Pointer(bp + 496 /* i */)) >= 10 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+32, ts+10206 /* "bad index " */, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), (uintptr(0))))
			return 1
		}
		pipePtr = (uintptr(unsafe.Pointer(&testPipes)) + uintptr(*(*int32)(unsafe.Pointer(bp + 496 /* i */)))*24)
	}

	if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+10217 /* "close" */) == 0 {
		for *(*int32)(unsafe.Pointer(bp + 496 /* i */)) = 0; *(*int32)(unsafe.Pointer(bp + 496 /* i */)) < 10; *(*int32)(unsafe.Pointer(bp + 496 /* i */))++ {
			if testPipes[*(*int32)(unsafe.Pointer(bp + 496 /* i */))].readFile != (uintptr(0)) {
				(*(*func(*crt.TLS, TclFile) int32)(unsafe.Pointer((tclIntPlatStubsPtr + 24 /* &.tclpCloseFile */))))(tls, testPipes[*(*int32)(unsafe.Pointer(bp + 496 /* i */))].readFile)
				testPipes[*(*int32)(unsafe.Pointer(bp + 496 /* i */))].readFile = (uintptr(0))
				(*(*func(*crt.TLS, TclFile) int32)(unsafe.Pointer((tclIntPlatStubsPtr + 24 /* &.tclpCloseFile */))))(tls, testPipes[*(*int32)(unsafe.Pointer(bp + 496 /* i */))].writeFile)
				testPipes[*(*int32)(unsafe.Pointer(bp + 496 /* i */))].writeFile = (uintptr(0))
			}
		}
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+10223 /* "clear" */) == 0 {
		if argc != 3 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+56, ts+2369, /* "wrong # argument..." */
				*(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)), ts+10229 /* " clear index\"" */, (uintptr(0))))
			return 1
		}
		(*Pipe)(unsafe.Pointer(pipePtr)).readCount = crt.AssignPtrInt32(pipePtr+20 /* &.writeCount */, 0)
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+10243 /* "counts" */) == 0 {
		// var buf [48]int8 at bp+500, 48

		if argc != 3 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+88, ts+2369, /* "wrong # argument..." */
				*(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)), ts+10250 /* " counts index\"" */, (uintptr(0))))
			return 1
		}
		crt.Xsprintf(tls, bp+500 /* &buf */, ts+4720 /* "%d %d" */, crt.VaList(bp+120, (*Pipe)(unsafe.Pointer(pipePtr)).readCount, (*Pipe)(unsafe.Pointer(pipePtr)).writeCount))
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+136, bp+500 /* &buf */, (uintptr(0))))
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+1410 /* "create" */) == 0 {
		if argc != 5 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+152, ts+2369, /* "wrong # argument..." */
				*(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)), ts+10265 /* " create index re..." */, (uintptr(0))))
			return 1
		}
		if (*Pipe)(unsafe.Pointer(pipePtr)).readFile == (uintptr(0)) {
			if !((*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer((tclIntPlatStubsPtr + 40 /* &.tclpCreatePipe */))))(tls, (pipePtr /* &.readFile */), (pipePtr+8 /* &.writeFile */)) != 0) {
				(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+184, ts+10299, /* "couldn't open pi..." */
					(*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1648 /* &.tcl_PosixError */))))(tls, interp), (uintptr(0))))
				return 1
			}
			crt.Xfcntl(tls, ((int32(((*Pipe)(unsafe.Pointer(pipePtr)).readFile))) - 1), 4, crt.VaList(bp+208, 04000))
			crt.Xfcntl(tls, ((int32(((*Pipe)(unsafe.Pointer(pipePtr)).writeFile))) - 1), 4, crt.VaList(bp+216, 04000))
		}
		(*Pipe)(unsafe.Pointer(pipePtr)).readCount = 0
		(*Pipe)(unsafe.Pointer(pipePtr)).writeCount = 0

		if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), ts+6697 /* "readable" */) == 0 {
			(*(*func(*crt.TLS, int32, int32, uintptr, ClientData))(unsafe.Pointer((tclStubsPtr + 88 /* &.tcl_CreateFileHandler */))))(tls, ((int32(((*Pipe)(unsafe.Pointer(pipePtr)).readFile))) - 1), (int32(1) << 1),
				*(*uintptr)(unsafe.Pointer(&struct {
					f func(*crt.TLS, ClientData, int32)
				}{TestFileHandlerProc})), pipePtr)
		} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), ts+10320 /* "off" */) == 0 {
			(*(*func(*crt.TLS, int32))(unsafe.Pointer((tclStubsPtr + 96 /* &.tcl_DeleteFileHandler */))))(tls, ((int32(((*Pipe)(unsafe.Pointer(pipePtr)).readFile))) - 1))
		} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), ts+10324 /* "disabled" */) == 0 {
			(*(*func(*crt.TLS, int32, int32, uintptr, ClientData))(unsafe.Pointer((tclStubsPtr + 88 /* &.tcl_CreateFileHandler */))))(tls, ((int32(((*Pipe)(unsafe.Pointer(pipePtr)).readFile))) - 1), 0,
				*(*uintptr)(unsafe.Pointer(&struct {
					f func(*crt.TLS, ClientData, int32)
				}{TestFileHandlerProc})), pipePtr)
		} else {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+224, ts+10333 /* "bad read mode \"" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), ts+1804 /* "\"" */, (uintptr(0))))
			return 1
		}
		if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)), ts+6720 /* "writable" */) == 0 {
			(*(*func(*crt.TLS, int32, int32, uintptr, ClientData))(unsafe.Pointer((tclStubsPtr + 88 /* &.tcl_CreateFileHandler */))))(tls, ((int32(((*Pipe)(unsafe.Pointer(pipePtr)).writeFile))) - 1), (int32(1) << 2),
				*(*uintptr)(unsafe.Pointer(&struct {
					f func(*crt.TLS, ClientData, int32)
				}{TestFileHandlerProc})), pipePtr)
		} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)), ts+10320 /* "off" */) == 0 {
			(*(*func(*crt.TLS, int32))(unsafe.Pointer((tclStubsPtr + 96 /* &.tcl_DeleteFileHandler */))))(tls, ((int32(((*Pipe)(unsafe.Pointer(pipePtr)).writeFile))) - 1))
		} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)), ts+10324 /* "disabled" */) == 0 {
			(*(*func(*crt.TLS, int32, int32, uintptr, ClientData))(unsafe.Pointer((tclStubsPtr + 88 /* &.tcl_CreateFileHandler */))))(tls, ((int32(((*Pipe)(unsafe.Pointer(pipePtr)).writeFile))) - 1), 0,
				*(*uintptr)(unsafe.Pointer(&struct {
					f func(*crt.TLS, ClientData, int32)
				}{TestFileHandlerProc})), pipePtr)
		} else {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+256, ts+10333 /* "bad read mode \"" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)), ts+1804 /* "\"" */, (uintptr(0))))
			return 1
		}
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+10349 /* "empty" */) == 0 {
		if argc != 3 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+288, ts+2369, /* "wrong # argument..." */
				*(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)), ts+10355 /* " empty index\"" */, (uintptr(0))))
			return 1
		}

		for crt.Xread(tls, ((int32(((*Pipe)(unsafe.Pointer(pipePtr)).readFile)))-1), bp+548 /* &buffer */, uint64(4000)) > int64(0) {
		}
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+10369 /* "fill" */) == 0 {
		if argc != 3 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+320, ts+2369, /* "wrong # argument..." */
				*(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)), ts+10374 /* " fill index\"" */, (uintptr(0))))
			return 1
		}

		crt.Xmemset(tls, bp+548 /* &buffer */, 'a', uint64(4000))
		for crt.Xwrite(tls, ((int32(((*Pipe)(unsafe.Pointer(pipePtr)).writeFile)))-1), bp+548 /* &buffer */, uint64(4000)) > int64(0) {
		}
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+10387 /* "fillpartial" */) == 0 {
		// var buf [24]int8 at bp+4548, 24

		if argc != 3 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+352, ts+2369, /* "wrong # argument..." */
				*(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)), ts+10399 /* " fillpartial ind..." */, (uintptr(0))))
			return 1
		}

		crt.Xmemset(tls, bp+548 /* &buffer */, 'b', uint64(10))
		(*(*func(*crt.TLS, uintptr, int64) int32)(unsafe.Pointer((tclIntStubsPtr + 208 /* &.tclFormatInt */))))(tls, bp+4548 /* &buf */, crt.Xwrite(tls, ((int32(((*Pipe)(unsafe.Pointer(pipePtr)).writeFile)))-1), bp+548 /* &buffer */, uint64(10)))
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+384, bp+4548 /* &buf */, (uintptr(0))))
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+10419 /* "oneevent" */) == 0 {
		(*(*func(*crt.TLS, int32) int32)(unsafe.Pointer((tclStubsPtr + 936 /* &.tcl_DoOneEvent */))))(tls, ((int32(1) << 3) | (int32(1) << 1)))
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+10428 /* "wait" */) == 0 {
		if argc != 5 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+400, ts+2369, /* "wrong # argument..." */
				*(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)), ts+10433 /* " wait index read..." */, (uintptr(0))))
			return 1
		}
		if (*Pipe)(unsafe.Pointer(pipePtr)).readFile == (uintptr(0)) {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+432, ts+10472 /* "pipe " */, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), ts+10478 /* " doesn't exist" */, (uintptr(0))))
			return 1
		}
		if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), ts+6697 /* "readable" */) == 0 {
			mask = (int32(1) << 1)
			file = (*Pipe)(unsafe.Pointer(pipePtr)).readFile
		} else {
			mask = (int32(1) << 2)
			file = (*Pipe)(unsafe.Pointer(pipePtr)).writeFile
		}
		if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(4)*8)), bp+4572 /* &timeout */) != 0 {
			return 1
		}
		*(*int32)(unsafe.Pointer(bp + 496 /* i */)) = (*(*func(*crt.TLS, int32, int32, int32) int32)(unsafe.Pointer((tclIntPlatStubsPtr + 80 /* &.tclUnixWaitForFile */))))(tls, ((int32((file))) - 1), mask, *(*int32)(unsafe.Pointer(bp + 4572 /* timeout */)))
		if (*(*int32)(unsafe.Pointer(bp + 496 /* i */)) & (int32(1) << 1)) != 0 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+6697 /* "readable" */)
		}
		if (*(*int32)(unsafe.Pointer(bp + 496 /* i */)) & (int32(1) << 2)) != 0 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+6720 /* "writable" */)
		}
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), ts+10493 /* "windowevent" */) == 0 {
		(*(*func(*crt.TLS, int32) int32)(unsafe.Pointer((tclStubsPtr + 936 /* &.tcl_DoOneEvent */))))(tls, ((int32(1) << 2) | (int32(1) << 1)))
	} else {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+464, ts+1429 /* "bad option \"" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)),

			ts+10505 /* "\": must be close..." */, (uintptr(0))))
		return 1
	}
	return 0
}

var initialized int32 = 0 /* tclUnixTest.c:148:16 */

func TestFileHandlerProc(tls *crt.TLS, clientData ClientData, mask int32) { /* tclUnixTest.c:329:1: */
	var pipePtr uintptr = clientData

	if (mask & (int32(1) << 1)) != 0 {
		(*Pipe)(unsafe.Pointer(pipePtr)).readCount++
	}
	if (mask & (int32(1) << 2)) != 0 {
		(*Pipe)(unsafe.Pointer(pipePtr)).writeCount++
	}
}

//----------------------------------------------------------------------
//
// TestfilewaitCmd --
//
//	This function implements the "testfilewait" command. It is used to
//	test TclUnixWaitForFile.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestfilewaitCmd(tls *crt.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclUnixTest.c:362:1: */
	bp := tls.Alloc(92)
	defer tls.Free(92)

	var mask int32
	var result int32
	// var timeout int32 at bp+88, 4

	var channel Tcl_Channel
	var fd int32
	// var data ClientData at bp+80, 8

	if argc != 4 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+2369 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+10603 /* " file readable|w..." */, (uintptr(0))))
		return 1
	}
	channel = (*(*func(*crt.TLS, uintptr, uintptr, uintptr) Tcl_Channel)(unsafe.Pointer((tclStubsPtr + 1224 /* &.tcl_GetChannel */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), (uintptr(0)))
	if channel == (uintptr(0)) {
		return 1
	}
	if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), ts+6697 /* "readable" */) == 0 {
		mask = (int32(1) << 1)
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), ts+6720 /* "writable" */) == 0 {
		mask = (int32(1) << 2)
	} else if crt.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)), ts+10641 /* "both" */) == 0 {
		mask = ((int32(1) << 2) | (int32(1) << 1))
	} else {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+32, ts+6783 /* "bad argument \"" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8)),
			ts+10646 /* "\": must be reada..." */, (uintptr(0))))
		return 1
	}
	if (*(*func(*crt.TLS, Tcl_Channel, int32, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 1240 /* &.tcl_GetChannelHandle */))))(tls, channel,
		func() int32 {
			if (mask & (int32(1) << 1)) != 0 {
				return (int32(1) << 1)
			}
			return (int32(1) << 2)
		}(),
		bp+80 /* &data */) != 0 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+64, ts+10685 /* "couldn't get cha..." */, (uintptr(0))))
		return 1
	}
	fd = (int32((*(*ClientData)(unsafe.Pointer(bp + 80 /* data */)))))
	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(3)*8)), bp+88 /* &timeout */) != 0 {
		return 1
	}
	result = (*(*func(*crt.TLS, int32, int32, int32) int32)(unsafe.Pointer((tclIntPlatStubsPtr + 80 /* &.tclUnixWaitForFile */))))(tls, fd, mask, *(*int32)(unsafe.Pointer(bp + 88 /* timeout */)))
	if (result & (int32(1) << 1)) != 0 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+6697 /* "readable" */)
	}
	if (result & (int32(1) << 2)) != 0 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 568 /* &.tcl_AppendElement */))))(tls, interp, ts+6720 /* "writable" */)
	}
	return 0
}

//----------------------------------------------------------------------
//
// TestfindexecutableCmd --
//
//	This function implements the "testfindexecutable" command. It is used
//	to test TclpFindExecutable.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestfindexecutableCmd(tls *crt.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclUnixTest.c:431:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var saveName uintptr

	if argc != 2 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+2369 /* "wrong # argument..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+10711 /* " argv0\"" */, (uintptr(0))))
		return 1
	}

	saveName = (*(*func(*crt.TLS) uintptr)(unsafe.Pointer((tclIntStubsPtr + 1720 /* &.tclGetObjNameOfExecutable */))))(tls)
	(*Tcl_Obj)(unsafe.Pointer((saveName))).refCount++

	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclIntStubsPtr + 1712 /* &.tclpFindExecutable */))))(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS) uintptr)(unsafe.Pointer((tclIntStubsPtr + 1720 /* &.tclGetObjNameOfExecutable */))))(tls))

	(*(*func(*crt.TLS, uintptr, Tcl_Encoding))(unsafe.Pointer((tclIntStubsPtr + 1728 /* &.tclSetObjNameOfExecutable */))))(tls, saveName, (uintptr(0)))
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = (saveName)
		if crt.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer((_objPtr))).refCount, 1) <= 1 {
			(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 256 /* &.tclFreeObj */))))(tls, _objPtr)
		}
	}
	return 0
}

//----------------------------------------------------------------------
//
// TestgetopenfileCmd --
//
//	This function implements the "testgetopenfile" command. It is used to
//	get a FILE * value from a registered channel.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestgetopenfileCmd(tls *crt.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclUnixTest.c:474:1: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	// var filePtr ClientData at bp+48, 8

	if argc != 3 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+1483 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+10719 /* " channelName for..." */, (uintptr(0))))
		return 1
	}
	if (*(*func(*crt.TLS, uintptr, uintptr, int32, int32, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 1352 /* &.tcl_GetOpenFile */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), crt.Xatoi(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*8))), 1, bp+48 /* &filePtr */) ==
		1 {
		return 1
	}
	if *(*ClientData)(unsafe.Pointer(bp + 48 /* filePtr */)) == (uintptr(0)) {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp,
			crt.VaList(bp+32, ts+10744 /* "Tcl_GetOpenFile ..." */, (uintptr(0))))
		return 1
	}
	return 0
}

//----------------------------------------------------------------------
//
// TestsetdefencdirCmd --
//
//	This function implements the "testsetdefenc" command. It is used to
//	test Tcl_SetDefaultEncodingDir().
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestsetdefencdirCmd(tls *crt.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclUnixTest.c:517:1: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	if argc != 2 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+1483 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)),
			ts+10787 /* " defaultDir\"" */, (uintptr(0))))
		return 1
	}

	(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 2752 /* &.tcl_SetDefaultEncodingDir */))))(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)))
	return 0
}

//----------------------------------------------------------------------
//
// TestforkObjCmd --
//
//	This function implements the "testfork" command. It is used to
//	fork the Tcl process for specific test cases.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestforkObjCmd(tls *crt.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclUnixTest.c:551:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var pid pid_t

	if objc != 1 {
		(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+1482 /* "" */)
		return 1
	}
	pid = crt.Xfork(tls)
	if pid == -1 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp,
			crt.VaList(bp, ts+10800 /* "Cannot fork" */, (uintptr(0))))
		return 1
	}
	// Only needed when pthread_atfork is not present,
	// should not hurt otherwise.
	if pid == 0 {
		(*(*func(*crt.TLS) ClientData)(unsafe.Pointer((tclStubsPtr + 2472 /* &.tcl_InitNotifier */))))(tls)
	}
	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 1896 /* &.tcl_SetObjResult */))))(tls, interp, (*(*func(*crt.TLS, int32) uintptr)(unsafe.Pointer((tclStubsPtr + 432 /* &.tcl_NewIntObj */))))(tls, pid))
	return 0
}

//----------------------------------------------------------------------
//
// TestgetdefencdirCmd --
//
//	This function implements the "testgetdefenc" command. It is used to
//	test Tcl_GetDefaultEncodingDir().
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	None.
//
//----------------------------------------------------------------------

func TestgetdefencdirCmd(tls *crt.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclUnixTest.c:596:1: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	if argc != 1 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+1483 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*8)), (uintptr(0))))
		return 1
	}

	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp+24, (*(*func(*crt.TLS) uintptr)(unsafe.Pointer((tclStubsPtr + 2744 /* &.tcl_GetDefaultEncodingDir */))))(tls), (uintptr(0))))
	return 0
}

//----------------------------------------------------------------------
//
// TestalarmCmd --
//
//	Test that EINTR is handled correctly by generating and handling a
//	signal. This requires using the SA_RESTART flag when registering the
//	signal handler.
//
// Results:
//	None.
//
// Side Effects:
//	Sets up an signal and async handlers.
//
//----------------------------------------------------------------------

func TestalarmCmd(tls *crt.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclUnixTest.c:630:1: */
	bp := tls.Alloc(184)
	defer tls.Free(184)

	// var sec uint32 at bp+24, 4

	// var action sigaction at bp+32, 152

	if argc > 1 {
		(*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 312 /* &.tcl_GetInt */))))(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*8)), bp+24 /* &sec */)
	} else {
		*(*uint32)(unsafe.Pointer(bp + 24 /* sec */)) = uint32(1)
	}

	// Setup the signal handling that automatically retries any interrupted
	// I/O system calls.

	*(*uintptr)(unsafe.Pointer(bp + 32 /* &action */ /* &.__sigaction_handler */)) = *(*uintptr)(unsafe.Pointer(&struct{ f func(*crt.TLS, int32) }{AlarmHandler}))
	crt.Xmemset(tls, (bp + 32 /* &action */ + 8 /* &.sa_mask */), 0, 128)
	(*sigaction)(unsafe.Pointer(bp + 32 /* &action */)).sa_flags = 0x10000000

	if crt.Xsigaction(tls, 14, bp+32 /* &action */, (uintptr(0))) < 0 {
		(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, ts+10812 /* "sigaction: " */, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1648 /* &.tcl_PosixError */))))(tls, interp), (uintptr(0))))
		return 1
	}
	crt.Xalarm(tls, *(*uint32)(unsafe.Pointer(bp + 24 /* sec */)))
	return 0
}

//----------------------------------------------------------------------
//
// AlarmHandler --
//
//	Signal handler for the alarm command.
//
// Results:
//	None.
//
// Side effects:
// 	Calls the Tcl Async handler.
//
//----------------------------------------------------------------------

func AlarmHandler(tls *crt.TLS, signum int32) { /* tclUnixTest.c:686:1: */
	gotsig = ts + 6693 /* "1" */
}

//----------------------------------------------------------------------
//
// TestgotsigCmd --
//
// 	Verify the signal was handled after the testalarm command.
//
// Results:
//	None.
//
// Side Effects:
//	Resets the value of gotsig back to '0'.
//
//----------------------------------------------------------------------

func TestgotsigCmd(tls *crt.TLS, clientData ClientData, interp uintptr, argc int32, argv uintptr) int32 { /* tclUnixTest.c:709:1: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, gotsig, (uintptr(0))))
	gotsig = ts + 6695 /* "0" */
	return 0
}

//---------------------------------------------------------------------------
//
// TestchmodCmd --
//
//	Implements the "testchmod" cmd.  Used when testing "file" command.
//	The only attribute used by the Windows platform is the user write
//	flag; if this is not set, the file is made read-only.  Otehrwise, the
//	file is made read-write.
//
// Results:
//	A standard Tcl result.
//
// Side effects:
//	Changes permissions of specified files.
//
//---------------------------------------------------------------------------

func TestchmodCmd(tls *crt.TLS, dummy ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* tclUnixTest.c:740:1: */
	bp := tls.Alloc(256)
	defer tls.Free(256)

	var i int32
	// var mode int32 at bp+32, 4

	if objc < 2 {
		(*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 2128 /* &.tcl_WrongNumArgs */))))(tls, interp, 1, objv, ts+10824 /* "mode file ?file ..." */)
		return 1
	}

	if (*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer((tclStubsPtr + 320 /* &.tcl_GetIntFromObj */))))(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1)*8)), bp+32 /* &mode */) != 0 {
		return 1
	}

	for i = 2; i < objc; i++ {
		// var buffer Tcl_DString at bp+40, 216

		var translated uintptr

		translated = (*(*func(*crt.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2008 /* &.tcl_TranslateFileName */))))(tls, interp, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 2736 /* &.tcl_GetString */))))(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8))), bp+40 /* &buffer */)
		if translated == (uintptr(0)) {
			return 1
		}
		if crt.Xchmod(tls, translated, uint32(*(*int32)(unsafe.Pointer(bp + 32 /* mode */)))) != 0 {
			(*(*func(*crt.TLS, uintptr, uintptr))(unsafe.Pointer((tclStubsPtr + 576 /* &.tcl_AppendResult */))))(tls, interp, crt.VaList(bp, translated, ts+3814 /* ": " */, (*(*func(*crt.TLS, uintptr) uintptr)(unsafe.Pointer((tclStubsPtr + 1648 /* &.tcl_PosixError */))))(tls, interp),
				(uintptr(0))))
			return 1
		}
		(*(*func(*crt.TLS, uintptr))(unsafe.Pointer((tclStubsPtr + 976 /* &.tcl_DStringFree */))))(tls, bp+40 /* &buffer */)
	}
	return 0
}

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// tab-width: 8
// End:

func init() {
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&commands)) + 0 /* .cmdName */)) = uintptr(unsafe.Pointer(&procCommand))                                                                              // tclTestProcBodyObj.c:62:7:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&commands)) + 8 /* .proc */)) = ProcBodyTestProcObjCmd                                              // tclTestProcBodyObj.c:62:20:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&commands)) + 24 /* .cmdName */)) = uintptr(unsafe.Pointer(&checkCommand))                                                                            // tclTestProcBodyObj.c:63:7:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&commands)) + 32 /* .proc */)) = ProcBodyTestCheckObjCmd                                            // tclTestProcBodyObj.c:63:21:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&safeCommands)) + 0 /* .cmdName */)) = uintptr(unsafe.Pointer(&procCommand))                                                                          // tclTestProcBodyObj.c:68:7:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&safeCommands)) + 8 /* .proc */)) = ProcBodyTestProcObjCmd                                          // tclTestProcBodyObj.c:68:20:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&safeCommands)) + 24 /* .cmdName */)) = uintptr(unsafe.Pointer(&checkCommand))                                                                        // tclTestProcBodyObj.c:69:7:
	*(*func(*crt.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&safeCommands)) + 32 /* .proc */)) = ProcBodyTestCheckObjCmd                                        // tclTestProcBodyObj.c:69:21:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&simpleFilesystem)) + 24 /* .pathInFilesystemProc */)) = SimplePathInFilesystem                                        // tclTest.c:480:5:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&simpleFilesystem)) + 88 /* .statProc */)) = SimpleStat                                                                // tclTest.c:494:5:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&simpleFilesystem)) + 96 /* .accessProc */)) = SimpleAccess                                                              // tclTest.c:495:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32, int32) Tcl_Channel)(unsafe.Pointer(uintptr(unsafe.Pointer(&simpleFilesystem)) + 104 /* .openFileChannelProc */)) = SimpleOpenFileChannel                     // tclTest.c:496:5:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&simpleFilesystem)) + 112 /* .matchInDirectoryProc */)) = SimpleMatchInDirectory            // tclTest.c:497:5:
	*(*func(*crt.TLS) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&simpleFilesystem)) + 136 /* .listVolumesProc */)) = SimpleListVolumes                                                                 // tclTest.c:501:5:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 24 /* .pathInFilesystemProc */)) = TestReportInFilesystem                                 // tclTest.c:446:5:
	*(*func(*crt.TLS, ClientData) ClientData)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 32 /* .dupInternalRepProc */)) = TestReportDupInternalRep                                  // tclTest.c:447:5:
	*(*func(*crt.TLS, ClientData))(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 40 /* .freeInternalRepProc */)) = TestReportFreeInternalRep                                           // tclTest.c:448:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 64 /* .normalizePathProc */)) = TestReportNormalizePath                            // tclTest.c:451:5:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 88 /* .statProc */)) = TestReportStat                                                     // tclTest.c:454:5:
	*(*func(*crt.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 96 /* .accessProc */)) = TestReportAccess                                                   // tclTest.c:455:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32, int32) Tcl_Channel)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 104 /* .openFileChannelProc */)) = TestReportOpenFileChannel          // tclTest.c:456:5:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 112 /* .matchInDirectoryProc */)) = TestReportMatchInDirectory // tclTest.c:457:5:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 120 /* .utimeProc */)) = TestReportUtime                                                  // tclTest.c:458:5:
	*(*func(*crt.TLS, uintptr, uintptr, int32) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 128 /* .linkProc */)) = TestReportLink                                           // tclTest.c:459:5:
	*(*func(*crt.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 144 /* .fileAttrStringsProc */)) = TestReportFileAttrStrings                            // tclTest.c:461:5:
	*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 152 /* .fileAttrsGetProc */)) = TestReportFileAttrsGet                    // tclTest.c:462:5:
	*(*func(*crt.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 160 /* .fileAttrsSetProc */)) = TestReportFileAttrsSet                    // tclTest.c:463:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 168 /* .createDirectoryProc */)) = TestReportCreateDirectory                                       // tclTest.c:464:5:
	*(*func(*crt.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 176 /* .removeDirectoryProc */)) = TestReportRemoveDirectory                       // tclTest.c:465:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 184 /* .deleteFileProc */)) = TestReportDeleteFile                                                 // tclTest.c:466:5:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 192 /* .copyFileProc */)) = TestReportCopyFile                                            // tclTest.c:467:5:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 200 /* .renameFileProc */)) = TestReportRenameFile                                        // tclTest.c:468:5:
	*(*func(*crt.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 208 /* .copyDirectoryProc */)) = TestReportCopyDirectory                         // tclTest.c:469:5:
	*(*func(*crt.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 216 /* .lstatProc */)) = TestReportLstat                                                  // tclTest.c:470:5:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 224 /* .loadFileProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*crt.TLS, uintptr, uintptr, uintptr, uintptr) int32
	}{TestReportLoadFile})) // tclTest.c:471:5:
	*(*func(*crt.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testReportingFilesystem)) + 240 /* .chdirProc */)) = TestReportChdir // tclTest.c:473:5:
}

var ts1 = "TclOO\x00missing stub table pointer\x00Error loading \x00 (requested version \x00, actual version \x00): \x00interpreter uses an incompatible stubs mechanism\x00Tcl\x00tcl::tommath\x00epoch number mismatch\x00requires a later revision\x00Tcltest\x00tcl_rcFileName\x00~/.tclshrc\x00reporting\x00simple\x008.5\x001.1.0\x008.6.10\x00gettimes\x00noop\x00testpurebytesobj\x00testbytestring\x00testwrongnumargs\x00testfilesystem\x00testsimplefilesystem\x00testgetindexfromobjstruct\x00testasync\x00testbumpinterpepoch\x00testchannel\x00testchannelevent\x00testcmdtoken\x00testcmdinfo\x00testcmdtrace\x00testconcatobj\x00testcreatecommand\x00testdcall\x00testdel\x00testdelassocdata\x00testdoubledigits\x00testdstring\x00testencoding\x00testevalex\x00testevalobjv\x00testevent\x00testexithandler\x00testexprlong\x00testexprlongobj\x00testexprdouble\x00testexprdoubleobj\x00testexprparser\x00testexprstring\x00testfevent\x00testfilelink\x00testfile\x00testhashsystemhash\x00testgetassocdata\x00testgetint\x00testgetplatform\x00testgetvarfullname\x00testinterpdelete\x00testlink\x00testlocale\x00testpanic\x00testparseargs\x00testparser\x00testparsevar\x00testparsevarname\x00testregexp\x00testreturn\x00testsaveresult\x00testsetassocdata\x00testsetnoerr\x00testseterr\x00testset2\x00testseterrorcode\x00testsetobjerrorcode\x00testnumutfchars\x00testfindfirst\x00testfindlast\x00testsetplatform\x00teststaticpkg\x00testtranslatefilename\x00testupvar\x00T1\x00T2\x00testmainthread\x00testsetmainloop\x00testexitmainloop\x00T3\x00testnreunwind\x00testnrelevels\x00testinterpresolver\x00argv\x00stderr\x00-appinitprocerror\x00-appinitprocdeleteinterp\x00-appinitprocclosestderr\x00-appinitprocsetrcfile\x00wrong # args\x00create\x00delete\x00mark\x00bad option \"\x00\": must be create, delete, int, or mark\x00\x00wrong # args: should be \"\x00 option cmdName\"\x00original\x00get\x00??\x00CmdProc1\x00 \x00CmdProc2\x00unknown\x00 CmdDelProc1\x00 CmdDelProc2\x00 unknown\x00 nativeObjectProc\x00 stringProc\x00modify\x00new_command_data\x00new_delete_data\x00\": must be create, delete, get, or modify\x00CmdProc1 \x00CmdProc2 \x00CmdDelProc1 \x00CmdDelProc2 \x00 option arg\"\x00%p\x00name\x00bad command token \"\x00\"\x00\": must be create or name\x00 option script\"\x00tracetest\x00deletetest\x00leveltest\x00resulttest\x00Delete wasn't called\x00doubletest\x00\": must be tracetest, deletetest, doubletest or resulttest\x00Error\x00Break\x00Continue\x00Return\x00OtherStatus\x00 option\"\x00test_ns_basic::createdcommand\x00create2\x00value:at:\x00delete2\x00\": must be create, delete, create2, or delete2\x00CreatedCommandProc could not get command info for test_ns_basic::createdcommand\x00CreatedCommandProc in \x00CreatedCommandProc2 could not get command info for test_ns_basic::createdcommand\x00CreatedCommandProc2 in \x00bogus interpreter argument!\x00wrong # arguments: should be \"\x00 data_key\"\x00fpval ndigits type ?shorten?\x00double\x00conversion type\x00bad value? %g\n\x00shorten\x00bad flag\x00-\x00+\x00shortest\x00Steele\x00e\x00f\x00append\x00element\x00end\x00free\x00gresult\x00staticsmall\x00short\x00staticlarge\x00first0 first1 first2 first3 first4 first5 first6 first7 first8 first9\nsecond0 second1 second2 second3 second4 second5 second6 second7 second8 second9\nthird0 third1 third2 third3 third4 third5 third6 third7 third8 third9\nfourth0 fourth1 fourth2 fourth3 fourth4 fourth5 fourth6 fourth7 fourth8 fourth9\nfifth0 fifth1 fifth2 fifth3 fifth4 fifth5 fifth6 fifth7 fifth8 fifth9\nsixth0 sixth1 sixth2 sixth3 sixth4 sixth5 sixth6 sixth7 sixth8 sixth9\nseventh0 seventh1 seventh2 seventh3 seventh4 seventh5 seventh6 seventh7 seventh8 seventh9\n\x00This is a malloc-ed string\x00special\x00This is a specially-allocated string\x00bad gresult option \"\x00\": must be staticsmall, staticlarge, free, or special\x00length\x00result\x00trunc\x00start\x00\": must be append, element, end, free, get, length, result, trunc, or start\x00option\x00global\x00bad value \"\x00\": must be global\x00script ?global?\x00global word ?word ...?\x00subcommand ?arg ...?\x00subcommand\x00name position script\x00position specifier\x00queue\x00head\x00tail\x00    (command bound to \"testevent\" callback)\x00    (return value from \"testevent\" callback)\x00 create|delete value\"\x00\": must be create or delete\x00odd %d\n\x00ExitProcOdd: unable to write to stdout\x00even %d\n\x00ExitProcEven: unable to write to stdout\x00 expression\"\x00This is a result\x00: %ld\x00expression\x00: \x00source ?target?\x00could not create link from \"\x00\" to \"\x00\": \x00could not read link \"\x00unix\x00mac\x00windows\x00 path\"\x00 option ?arg arg arg arg arg arg arg arg arg arg arg arg arg arg?\"\x00 intRO realRO boolRO stringRO wideRO charRO ucharRO shortRO ushortRO uintRO longRO ulongRO floatRO uwideRO\"\x00int\x00real\x00bool\x00string\x00wide\x00char\x00uchar\x00ushort\x00uint\x00long\x00ulong\x00float\x00uwide\x00set\x00 intValue realValue boolValue stringValue wideValue charValue ucharValue shortValue ushortValue uintValue longValue ulongValue floatValue uwideValue\"\x00update\x00\": should be create, delete, get, set, or update\x00category ?locale?\x00ctype\x00numeric\x00time\x00collate\x00monetary\x00all\x00T3: wrong type for arg 2\x00T3: wrong type for arg 1\x00script length\x00\n    (remainder of script: \"\x00\")\x00expr length\x00\n    (remainder of expr: \"\x00expand\x00word\x00text\x00backslash\x00command\x00variable\x00subexpr\x00operator\x00varName\x00script length append\x00switch\x00?-switch ...? exp string ?matchVar? ?subMatchVar ...?\x00%d %d\x00couldn't set variable \"\x00%ld\x00-indices\x00-nocase\x00-about\x00-expanded\x00-line\x00-linestop\x00-lineanchor\x00-xflags\x00--\x00 data_key data_item\"\x00 platform\"\x00unsupported platform: should be one of unix, or windows\x00 pkgName safe loaded\"\x00x\x00loaded\x00 level name ?name2? dest global\"\x00namespace\x00too many args\x00NONE\x00 option ?arg ...?\x00cmd\x00 cmd script\x00called \"testfevent code\" before \"testfevent create\"\x00share\x00%s\x00-force\x00mv\x00cp\x00rm\x00mkdir\x00cpdir\x00rmdir\x00name scope\x00::test_ns_var\x00alloc & free 100000 6 word items\n\x00   %.3f usec per alloc+free\n\x00alloc 5000 6 word items\n\x00   %.3f usec per alloc\n\x00free 5000 6 word items\n\x00   %.3f usec per free\n\x00Tcl_NewObj 5000 times\n\x00   %.3f usec per Tcl_NewObj\n\x00Tcl_DecrRefCount 5000 times\n\x00   %.3f usec per Tcl_DecrRefCount\n\x00TclGetStringFromObj of \"12345\" 100000 times\n\x0012345\x00   %.3f usec per TclGetStringFromObj of \"12345\"\n\x00Tcl_GetIntFromObj of \"12345\" 100000 times\n\x00   %.3f usec per Tcl_GetIntFromObj of \"12345\"\n\x00Tcl_GetInt of \"12345\" 100000 times\n\x00   %.3f usec per Tcl_GetInt of \"12345\"\n\x00sprintf of 12345 100000 times\n\x00%d\x00   %.3f usec per sprintf of 12345\n\x00hashtable lookup of \"gettimes\" 100000 times\n\x00   %.3f usec per hashtable lookup of \"gettimes\"\n\x00Tcl_SetVar of \"12345\" 100000 times\n\x00a\x00   %.3f usec per Tcl_SetVar of a to \"12345\"\n\x00Tcl_GetVar of a==\"12345\" 100000 times\n\x00   %.3f usec per Tcl_GetVar of a==\"12345\"\n\x00?string?\x00bytearray\x00before get\x00before set\x00 varName ?newValue?\"\x00 varName elemName ?newValue?\"\x00type script discard\x00small result\x00append result\x00free result\x00dynamic result\x00object result\x00called\x00notCalled\x00present\x00missing\x00same\x00different\x00dynamic\x00object\x00small\x00Exit MainLoop\n\x00 subcommand ?additional args..?\"\x00splice\x00setchannelerror\x00setchannelerrorinterp\x00cut\x00 cut channelName\"\x00clearchannelhandlers\x00 clearchannelhandlers channelName\"\x00info\x00 info channelName\"\x00read\x00write\x00nonblocking\x00blocking\x00line\x00none\x00full\x00async_flush\x00eof\x00blocked\x00unblocked\x00auto\x00saw_cr\x00lf\x00cr\x00crlf\x00queued_cr\x00inputbuffered\x00channel name required\x00isshared\x00isstandard\x00mode\x00mthread\x00open\x00tclIO\x00outputbuffered\x00queuedcr\x001\x000\x00readable\x00refcount\x00type\x00writable\x00transform\x00 transform channelId -command cmd\"\x00-command\x00bad argument \"\x00\": should be \"-command\"\x00unstack\x00 unstack channel\"\x00\": should be cut, clearchannelhandlers, info, isshared, mode, open, readable, splice, writable, transform, unstack\x00 channelName cmd ?arg1? ?arg2?\"\x00add\x00 channelName add eventSpec script\"\x00bad event name \"\x00\": must be readable, writable, or none\x00 channelName delete index\"\x00bad event index: \x00: must be nonnegative\x00bad event index \x00: out of range\x00TestChannelEventCmd: damaged event script list\x00list\x00 channelName list\"\x00removeall\x00 channelName removeall\"\x00 channelName delete index event\"\x00bad command \x00, must be one of add, delete, list, set, or removeall\x00insufficient arguments\x00b\x00c\x00d\x00argument targetvalue\x00dummy\x00index value comparison failed: got \x00 when \x00 expected\x00boolean\x00registered\x00failed\x00unregistered\x00lappend filesystemReport \x00stat\x00lstat\x00access\x00matchmounts\x00matchindirectory\x00chdir\x00loadfile\x00link\x00renamefile\x00copyfile\x00deletefile\x00createdirectory\x00copydirectory\x00removedirectory\x00fileattributestrings\x00fileattributesget\x00fileattributesset\x00utime\x00normalizepath\x00simplefs:/\x00read-only\x00r\x00non-zero initial size\x00 creation problem\x00unexpected maximal size\x00 lookup problem\x00 value problem\x00non-zero final size\x00OK\x00Tcl_ConcatObj is unsafe:\x00foo bar sum\x00eeny meeny\x00\n\t* (a) concatObj does not have refCount 0\x00\n\t* (a) concatObj is not a new obj \x00(no new refCount)\x00(refCount added)\x00(more than one refCount added!)\x00extremely unsafe behaviour by Tcl_ConcatObj()\x00\n\t* (b) concatObj does not have refCount 0\x00\n\t* (b) concatObj is not a new obj \x00(refCount removed?)\x00\n\t* (c) concatObj does not have refCount 0\x00\n\t* (c) concatObj is not a new obj \x00\n\t* (d) concatObj does not have refCount 0\x00\n\t* (d) concatObj is not a new obj \x00\n\t* (e) concatObj does not have refCount 0\x00\n\t* (e) concatObj is not a new obj \x00(failed to concat)\x00(corrupted input!)\x00\n\t* (f) concatObj does not have refCount 0\x00\n\t* (f) concatObj is not a new obj \x00\n\t* (g) concatObj does not have refCount 0\x00\n\t* (g) concatObj is not a new obj \x00-bool\x00booltest\x00Marks the end of the options\x00-help\x00Print summary of command-line options and abort\x00::ns2\x00y\x00(NULL)\x00ctx1\x00ctx2\x00Y\x00up|down ?interp?\x00provided interpreter not found\x00operation\x00testInterpResolver\x00could not remove the resolver scheme\x00down\x00up\x00TCLOBJTEST_VARPTR\x00testbignumobj\x00testbooleanobj\x00testdoubleobj\x00testintobj\x00testindexobj\x00testlistobj\x00testobj\x00teststringobj\x00mult10\x00div10\x00iseven\x00radixsize\x00option ?arg ...?\x00var value\x00error in mp_init\x00error in mp_read_radix\x00varIndex\x00error in mp_mul_d\x00error in mp_div_d\x00option arg ?arg ...?\x00not\x00\": must be set, get, or not\x00\": must be set, get, mult10, or div10\x00check\x00token\x00index\x00set2\x00setlong\x00setmaxlong\x00ismaxlong\x00get2\x00inttoobigtest\x00\": must be set, get, get2, mult10, or div10\x00replace\x00option arg ?arg...?\x00varIndex start count ?element...?\x00assign\x00bug3598580\x00convert\x00no type \x00 found\x00duplicate\x00freeallvars\x00invalidateStringRep\x00newobj\x00objtype\x00types\x00\": must be assign, convert, duplicate, freeallvars, newobj, objcount, objtype, refcount, type, or types\x00index value out of range\x00appendstrings\x00length2\x00setlength\x00maxchars\x00getunicode\x00appendself\x00appendself2\x00bad variable index\x00variable %d is unset (NULL)\x00procbodytest\x001.1\x00proc\x00namespace eval %s { namespace export %s }\x00%s::%s\x00newName argsList bodyName\x00command \"\x00\" is not a Tcl procedure\x00procedure \"\x00\" does not have a Proc struct!\x00failed to create a procbody object for procedure \"\x00testchmod\x00testfilehandler\x00testfilewait\x00testfindexecutable\x00testfork\x00testgetopenfile\x00testgetdefenc\x00testsetdefenc\x00testalarm\x00testgotsig\x00 option ... \"\x00bad index \x00close\x00clear\x00 clear index\"\x00counts\x00 counts index\"\x00 create index readMode writeMode\"\x00couldn't open pipe: \x00off\x00disabled\x00bad read mode \"\x00empty\x00 empty index\"\x00fill\x00 fill index\"\x00fillpartial\x00 fillpartial index\"\x00oneevent\x00wait\x00 wait index readable|writable timeout\"\x00pipe \x00 doesn't exist\x00windowevent\x00\": must be close, clear, counts, create, empty, fill, fillpartial, oneevent, wait, or windowevent\x00 file readable|writable|both timeout\"\x00both\x00\": must be readable, writable, or both\x00couldn't get channel file\x00 argv0\"\x00 channelName forWriting\"\x00Tcl_GetOpenFile succeeded but FILE * NULL!\x00 defaultDir\"\x00Cannot fork\x00sigaction: \x00mode file ?file ...?\x00"
var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data
